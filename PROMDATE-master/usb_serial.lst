   1               		.file	"usb_serial.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.text
   9               	.Ltext0:
  10               		.cfi_sections	.debug_frame
  11               		.section	.text.usb_wait_in_ready,"ax",@progbits
  13               	usb_wait_in_ready:
  14               	.LFB17:
  15               		.file 1 "usb_serial.c"
   1:usb_serial.c  **** /* USB Serial Example for Teensy USB Development Board
   2:usb_serial.c  ****  * http://www.pjrc.com/teensy/usb_serial.html
   3:usb_serial.c  ****  * Copyright (c) 2008,2010,2011 PJRC.COM, LLC
   4:usb_serial.c  ****  * 
   5:usb_serial.c  ****  * Permission is hereby granted, free of charge, to any person obtaining a copy
   6:usb_serial.c  ****  * of this software and associated documentation files (the "Software"), to deal
   7:usb_serial.c  ****  * in the Software without restriction, including without limitation the rights
   8:usb_serial.c  ****  * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   9:usb_serial.c  ****  * copies of the Software, and to permit persons to whom the Software is
  10:usb_serial.c  ****  * furnished to do so, subject to the following conditions:
  11:usb_serial.c  ****  * 
  12:usb_serial.c  ****  * The above copyright notice and this permission notice shall be included in
  13:usb_serial.c  ****  * all copies or substantial portions of the Software.
  14:usb_serial.c  ****  * 
  15:usb_serial.c  ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  16:usb_serial.c  ****  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  17:usb_serial.c  ****  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  18:usb_serial.c  ****  * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  19:usb_serial.c  ****  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  20:usb_serial.c  ****  * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
  21:usb_serial.c  ****  * THE SOFTWARE.
  22:usb_serial.c  ****  */
  23:usb_serial.c  **** 
  24:usb_serial.c  **** // Version 1.0: Initial Release
  25:usb_serial.c  **** // Version 1.1: support Teensy++
  26:usb_serial.c  **** // Version 1.2: fixed usb_serial_available
  27:usb_serial.c  **** // Version 1.3: added transmit bandwidth test
  28:usb_serial.c  **** // Version 1.4: added usb_serial_write
  29:usb_serial.c  **** // Version 1.5: add support for Teensy 2.0
  30:usb_serial.c  **** // Version 1.6: fix zero length packet bug
  31:usb_serial.c  **** // Version 1.7: fix usb_serial_set_control
  32:usb_serial.c  **** 
  33:usb_serial.c  **** #define USB_SERIAL_PRIVATE_INCLUDE
  34:usb_serial.c  **** #include "usb_serial.h"
  35:usb_serial.c  **** 
  36:usb_serial.c  **** #include <usb.h>
  37:usb_serial.c  **** 
  38:usb_serial.c  **** 
  39:usb_serial.c  **** /**************************************************************************
  40:usb_serial.c  ****  *
  41:usb_serial.c  ****  *  Configurable Options
  42:usb_serial.c  ****  *
  43:usb_serial.c  ****  **************************************************************************/
  44:usb_serial.c  **** 
  45:usb_serial.c  **** // You can change these to give your code its own name.  On Windows,
  46:usb_serial.c  **** // these are only used before an INF file (driver install) is loaded.
  47:usb_serial.c  **** #define STR_MANUFACTURER	L"Your Name"
  48:usb_serial.c  **** #define STR_PRODUCT		L"USB Serial"
  49:usb_serial.c  **** 
  50:usb_serial.c  **** // All USB serial devices are supposed to have a serial number
  51:usb_serial.c  **** // (according to Microsoft).  On windows, a new COM port is created
  52:usb_serial.c  **** // for every unique serial/vendor/product number combination.  If
  53:usb_serial.c  **** // you program 2 identical boards with 2 different serial numbers
  54:usb_serial.c  **** // and they are assigned COM7 and COM8, each will always get the
  55:usb_serial.c  **** // same COM port number because Windows remembers serial numbers.
  56:usb_serial.c  **** //
  57:usb_serial.c  **** // On Mac OS-X, a device file is created automatically which
  58:usb_serial.c  **** // incorperates the serial number, eg, /dev/cu-usbmodem12341
  59:usb_serial.c  **** //
  60:usb_serial.c  **** // Linux by default ignores the serial number, and creates device
  61:usb_serial.c  **** // files named /dev/ttyACM0, /dev/ttyACM1... in the order connected.
  62:usb_serial.c  **** // Udev rules (in /etc/udev/rules.d) can define persistent device
  63:usb_serial.c  **** // names linked to this serial number, as well as permissions, owner
  64:usb_serial.c  **** // and group settings.
  65:usb_serial.c  **** #define STR_SERIAL_NUMBER	L"12345"
  66:usb_serial.c  **** 
  67:usb_serial.c  **** // Mac OS-X and Linux automatically load the correct drivers.  On
  68:usb_serial.c  **** // Windows, even though the driver is supplied by Microsoft, an
  69:usb_serial.c  **** // INF file is needed to load the driver.  These numbers need to
  70:usb_serial.c  **** // match the INF file.
  71:usb_serial.c  **** #define VENDOR_ID		0x16C0
  72:usb_serial.c  **** #define PRODUCT_ID		0x047A
  73:usb_serial.c  **** 
  74:usb_serial.c  **** // When you write data, it goes into a USB endpoint buffer, which
  75:usb_serial.c  **** // is transmitted to the PC when it becomes full, or after a timeout
  76:usb_serial.c  **** // with no more writes.  Even if you write in exactly packet-size
  77:usb_serial.c  **** // increments, this timeout is used to send a "zero length packet"
  78:usb_serial.c  **** // that tells the PC no more data is expected and it should pass
  79:usb_serial.c  **** // any buffered data to the application that may be waiting.  If
  80:usb_serial.c  **** // you want data sent immediately, call usb_serial_flush_output().
  81:usb_serial.c  **** #define TRANSMIT_FLUSH_TIMEOUT	5   /* in milliseconds */
  82:usb_serial.c  **** 
  83:usb_serial.c  **** // If the PC is connected but not "listening", this is the length
  84:usb_serial.c  **** // of time before usb_serial_getchar() returns with an error.  This
  85:usb_serial.c  **** // is roughly equivilant to a real UART simply transmitting the
  86:usb_serial.c  **** // bits on a wire where nobody is listening, except you get an error
  87:usb_serial.c  **** // code which you can ignore for serial-like discard of data, or
  88:usb_serial.c  **** // use to know your data wasn't sent.
  89:usb_serial.c  **** #define TRANSMIT_TIMEOUT	25   /* in milliseconds */
  90:usb_serial.c  **** 
  91:usb_serial.c  **** // USB devices are supposed to implment a halt feature, which is
  92:usb_serial.c  **** // rarely (if ever) used.  If you comment this line out, the halt
  93:usb_serial.c  **** // code will be removed, saving 116 bytes of space (gcc 4.3.0).
  94:usb_serial.c  **** // This is not strictly USB compliant, but works with all major
  95:usb_serial.c  **** // operating systems.
  96:usb_serial.c  **** #define SUPPORT_ENDPOINT_HALT
  97:usb_serial.c  **** 
  98:usb_serial.c  **** 
  99:usb_serial.c  **** 
 100:usb_serial.c  **** /**************************************************************************
 101:usb_serial.c  ****  *
 102:usb_serial.c  ****  *  Endpoint Buffer Configuration
 103:usb_serial.c  ****  *
 104:usb_serial.c  ****  **************************************************************************/
 105:usb_serial.c  **** 
 106:usb_serial.c  **** // These buffer sizes are best for most applications, but perhaps if you
 107:usb_serial.c  **** // want more buffering on some endpoint at the expense of others, this
 108:usb_serial.c  **** // is where you can make such changes.  The AT90USB162 has only 176 bytes
 109:usb_serial.c  **** // of DPRAM (USB buffers) and only endpoints 3 & 4 can double buffer.
 110:usb_serial.c  **** 
 111:usb_serial.c  **** #define ENDPOINT0_SIZE		16
 112:usb_serial.c  **** #define CDC_ACM_ENDPOINT	2
 113:usb_serial.c  **** #define CDC_RX_ENDPOINT		3
 114:usb_serial.c  **** #define CDC_TX_ENDPOINT		4
 115:usb_serial.c  **** #if defined(__AVR_AT90USB162__)
 116:usb_serial.c  **** #define CDC_ACM_SIZE		16
 117:usb_serial.c  **** #define CDC_ACM_BUFFER		EP_SINGLE_BUFFER
 118:usb_serial.c  **** #define CDC_RX_SIZE		32
 119:usb_serial.c  **** #define CDC_RX_BUFFER 		EP_DOUBLE_BUFFER
 120:usb_serial.c  **** #define CDC_TX_SIZE		32
 121:usb_serial.c  **** #define CDC_TX_BUFFER		EP_DOUBLE_BUFFER
 122:usb_serial.c  **** #else
 123:usb_serial.c  **** #define CDC_ACM_SIZE		16
 124:usb_serial.c  **** #define CDC_ACM_BUFFER		EP_SINGLE_BUFFER
 125:usb_serial.c  **** #define CDC_RX_SIZE		64
 126:usb_serial.c  **** #define CDC_RX_BUFFER 		EP_DOUBLE_BUFFER
 127:usb_serial.c  **** #define CDC_TX_SIZE		64
 128:usb_serial.c  **** #define CDC_TX_BUFFER		EP_DOUBLE_BUFFER
 129:usb_serial.c  **** #endif
 130:usb_serial.c  **** 
 131:usb_serial.c  **** static const uint8_t PROGMEM endpoint_config_table[] = {
 132:usb_serial.c  **** 	0,
 133:usb_serial.c  **** 	1, EP_TYPE_INTERRUPT_IN,  EP_SIZE(CDC_ACM_SIZE) | CDC_ACM_BUFFER,
 134:usb_serial.c  **** 	1, EP_TYPE_BULK_OUT,      EP_SIZE(CDC_RX_SIZE) | CDC_RX_BUFFER,
 135:usb_serial.c  **** 	1, EP_TYPE_BULK_IN,       EP_SIZE(CDC_TX_SIZE) | CDC_TX_BUFFER
 136:usb_serial.c  **** };
 137:usb_serial.c  **** 
 138:usb_serial.c  **** 
 139:usb_serial.c  **** /**************************************************************************
 140:usb_serial.c  ****  *
 141:usb_serial.c  ****  *  Descriptor Data
 142:usb_serial.c  ****  *
 143:usb_serial.c  ****  **************************************************************************/
 144:usb_serial.c  **** 
 145:usb_serial.c  **** // Descriptors are the data that your computer reads when it auto-detects
 146:usb_serial.c  **** // this USB device (called "enumeration" in USB lingo).  The most commonly
 147:usb_serial.c  **** // changed items are editable at the top of this file.  Changing things
 148:usb_serial.c  **** // in here should only be done by those who've read chapter 9 of the USB
 149:usb_serial.c  **** // spec and relevant portions of any USB class specifications!
 150:usb_serial.c  **** 
 151:usb_serial.c  **** const static struct usb_device_descriptor PROGMEM device_descriptor = {
 152:usb_serial.c  **** 	.bLength		= sizeof(device_descriptor),
 153:usb_serial.c  **** 	.bDescriptorType	= 1,
 154:usb_serial.c  **** 	.bcdUSB			= 0x0200,
 155:usb_serial.c  **** 	.bDeviceClass		= USB_CLASS_COMM,
 156:usb_serial.c  **** 	.bDeviceSubClass	= 0,
 157:usb_serial.c  **** 	.bDeviceProtocol	= 0,
 158:usb_serial.c  **** 	.bMaxPacketSize0	= ENDPOINT0_SIZE,
 159:usb_serial.c  **** 	.idVendor		= VENDOR_ID,
 160:usb_serial.c  **** 	.idProduct		= PRODUCT_ID,
 161:usb_serial.c  **** 	.bcdDevice		= 0x0100,
 162:usb_serial.c  **** 	.iManufacturer		= 1,
 163:usb_serial.c  **** 	.iProduct		= 2,
 164:usb_serial.c  **** 	.iSerialNumber		= 3,
 165:usb_serial.c  **** 	.bNumConfigurations	= 1,
 166:usb_serial.c  **** };
 167:usb_serial.c  **** 
 168:usb_serial.c  **** 
 169:usb_serial.c  **** #define CONFIG1_DESC_SIZE (9+9+5+5+4+5+7+9+7+7)
 170:usb_serial.c  **** #if 1
 171:usb_serial.c  **** const static uint8_t PROGMEM config1_descriptor[CONFIG1_DESC_SIZE] = {
 172:usb_serial.c  **** 	// configuration descriptor, USB spec 9.6.3, page 264-266, Table 9-10
 173:usb_serial.c  **** 	9, 					// bLength;
 174:usb_serial.c  **** 	2,					// bDescriptorType;
 175:usb_serial.c  **** 	LSB(CONFIG1_DESC_SIZE),			// wTotalLength
 176:usb_serial.c  **** 	MSB(CONFIG1_DESC_SIZE),
 177:usb_serial.c  **** 	2,					// bNumInterfaces
 178:usb_serial.c  **** 	1,					// bConfigurationValue
 179:usb_serial.c  **** 	0,					// iConfiguration
 180:usb_serial.c  **** 	0xC0,					// bmAttributes
 181:usb_serial.c  **** 	50,					// bMaxPower
 182:usb_serial.c  **** 
 183:usb_serial.c  **** 	// interface descriptor, USB spec 9.6.5, page 267-269, Table 9-12
 184:usb_serial.c  **** 	9,					// bLength
 185:usb_serial.c  **** 	4,					// bDescriptorType
 186:usb_serial.c  **** 	0,					// bInterfaceNumber
 187:usb_serial.c  **** 	0,					// bAlternateSetting
 188:usb_serial.c  **** 	1,					// bNumEndpoints
 189:usb_serial.c  **** 	0x02,					// bInterfaceClass
 190:usb_serial.c  **** 	0x02,					// bInterfaceSubClass
 191:usb_serial.c  **** 	0x01,					// bInterfaceProtocol
 192:usb_serial.c  **** 	0,					// iInterface
 193:usb_serial.c  **** 	// CDC Header Functional Descriptor, CDC Spec 5.2.3.1, Table 26
 194:usb_serial.c  **** 	5,					// bFunctionLength
 195:usb_serial.c  **** 	0x24,					// bDescriptorType
 196:usb_serial.c  **** 	0x00,					// bDescriptorSubtype
 197:usb_serial.c  **** 	0x10, 0x01,				// bcdCDC
 198:usb_serial.c  **** 	// Call Management Functional Descriptor, CDC Spec 5.2.3.2, Table 27
 199:usb_serial.c  **** 	5,					// bFunctionLength
 200:usb_serial.c  **** 	0x24,					// bDescriptorType
 201:usb_serial.c  **** 	0x01,					// bDescriptorSubtype
 202:usb_serial.c  **** 	0x01,					// bmCapabilities
 203:usb_serial.c  **** 	1,					// bDataInterface
 204:usb_serial.c  **** 	// Abstract Control Management Functional Descriptor, CDC Spec 5.2.3.3, Table 28
 205:usb_serial.c  **** 	4,					// bFunctionLength
 206:usb_serial.c  **** 	0x24,					// bDescriptorType
 207:usb_serial.c  **** 	0x02,					// bDescriptorSubtype
 208:usb_serial.c  **** 	0x06,					// bmCapabilities
 209:usb_serial.c  **** 	// Union Functional Descriptor, CDC Spec 5.2.3.8, Table 33
 210:usb_serial.c  **** 	5,					// bFunctionLength
 211:usb_serial.c  **** 	0x24,					// bDescriptorType
 212:usb_serial.c  **** 	0x06,					// bDescriptorSubtype
 213:usb_serial.c  **** 	0,					// bMasterInterface
 214:usb_serial.c  **** 	1,					// bSlaveInterface0
 215:usb_serial.c  **** 	// endpoint descriptor, USB spec 9.6.6, page 269-271, Table 9-13
 216:usb_serial.c  **** 	7,					// bLength
 217:usb_serial.c  **** 	5,					// bDescriptorType
 218:usb_serial.c  **** 	CDC_ACM_ENDPOINT | 0x80,		// bEndpointAddress
 219:usb_serial.c  **** 	0x03,					// bmAttributes (0x03=intr)
 220:usb_serial.c  **** 	CDC_ACM_SIZE, 0,			// wMaxPacketSize
 221:usb_serial.c  **** 	64,					// bInterval
 222:usb_serial.c  **** 	// interface descriptor, USB spec 9.6.5, page 267-269, Table 9-12
 223:usb_serial.c  **** 	9,					// bLength
 224:usb_serial.c  **** 	4,					// bDescriptorType
 225:usb_serial.c  **** 	1,					// bInterfaceNumber
 226:usb_serial.c  **** 	0,					// bAlternateSetting
 227:usb_serial.c  **** 	2,					// bNumEndpoints
 228:usb_serial.c  **** 	0x0A,					// bInterfaceClass
 229:usb_serial.c  **** 	0x00,					// bInterfaceSubClass
 230:usb_serial.c  **** 	0x00,					// bInterfaceProtocol
 231:usb_serial.c  **** 	0,					// iInterface
 232:usb_serial.c  **** 	// endpoint descriptor, USB spec 9.6.6, page 269-271, Table 9-13
 233:usb_serial.c  **** 	7,					// bLength
 234:usb_serial.c  **** 	5,					// bDescriptorType
 235:usb_serial.c  **** 	CDC_RX_ENDPOINT,			// bEndpointAddress
 236:usb_serial.c  **** 	0x02,					// bmAttributes (0x02=bulk)
 237:usb_serial.c  **** 	CDC_RX_SIZE, 0,				// wMaxPacketSize
 238:usb_serial.c  **** 	0,					// bInterval
 239:usb_serial.c  **** 	// endpoint descriptor, USB spec 9.6.6, page 269-271, Table 9-13
 240:usb_serial.c  **** 	7,					// bLength
 241:usb_serial.c  **** 	5,					// bDescriptorType
 242:usb_serial.c  **** 	CDC_TX_ENDPOINT | 0x80,			// bEndpointAddress
 243:usb_serial.c  **** 	0x02,					// bmAttributes (0x02=bulk)
 244:usb_serial.c  **** 	CDC_TX_SIZE, 0,				// wMaxPacketSize
 245:usb_serial.c  **** 	0					// bInterval
 246:usb_serial.c  **** };
 247:usb_serial.c  **** #else
 248:usb_serial.c  **** static struct usb_config_descriptor PROGMEM config1_descriptor = {
 249:usb_serial.c  **** 	.bLength		= USB_DT_CONFIG_SIZE,
 250:usb_serial.c  **** 	.bDescriptorType	= USB_DT_CONFIG,
 251:usb_serial.c  **** 	.wTotalLength		= CONFIG1_DESC_SIZE, // \todo compute
 252:usb_serial.c  **** 	.bNumInterfaces		= 2,
 253:usb_serial.c  **** 	.bConfigurationValue	= 1, // \todo ?
 254:usb_serial.c  **** 	.iConfiguration		= 0, // \todo ?
 255:usb_serial.c  **** 	.bmAttributes		= 0xC0, // \todo ?
 256:usb_serial.c  **** 	.bMaxPower		= 50, // mA?
 257:usb_serial.c  **** 	.interfaces		= {
 258:usb_serial.c  **** 		{
 259:usb_serial.c  **** 			.bLength		= USB_DT_INTERFACE_SIZE,
 260:usb_serial.c  **** 			.bDescriptorType	= USB_DT_INTERFACE,
 261:usb_serial.c  **** 			.bInterfaceNumber	= 0,
 262:usb_serial.c  **** 			.bAlternateSetting	= 0,
 263:usb_serial.c  **** 			.bNumEndPoints		= 0,
 264:usb_serial.c  **** 			.bInterfaceClass	= USB_CLASS_COMM,
 265:usb_serial.c  **** 			.bInterfaceSubClass	= USB_CLASS_COMM,
 266:usb_serial.c  **** 			.bInterfaceProtocol	= 1, // \todo ?
 267:usb_serial.c  **** 			.iInterface		= 0,
 268:usb_serial.c  **** 			.endpoint		= {
 269:usb_serial.c  **** 				.bLength		= USB_
 270:usb_serial.c  **** 		},
 271:usb_serial.c  **** 		{
 272:usb_serial.c  **** 		},
 273:usb_serial.c  **** 	},
 274:usb_serial.c  **** };
 275:usb_serial.c  **** #endif
 276:usb_serial.c  **** 
 277:usb_serial.c  **** // If you're desperate for a little extra code memory, these strings
 278:usb_serial.c  **** // can be completely removed if iManufacturer, iProduct, iSerialNumber
 279:usb_serial.c  **** // in the device desciptor are changed to zeros.
 280:usb_serial.c  **** struct usb_string_descriptor_struct {
 281:usb_serial.c  **** 	uint8_t bLength;
 282:usb_serial.c  **** 	uint8_t bDescriptorType;
 283:usb_serial.c  **** 	int16_t wString[];
 284:usb_serial.c  **** };
 285:usb_serial.c  **** const static struct usb_string_descriptor_struct PROGMEM string0 = {
 286:usb_serial.c  **** 	4,
 287:usb_serial.c  **** 	3,
 288:usb_serial.c  **** 	{0x0409}
 289:usb_serial.c  **** };
 290:usb_serial.c  **** const static struct usb_string_descriptor_struct PROGMEM string1 = {
 291:usb_serial.c  **** 	sizeof(STR_MANUFACTURER),
 292:usb_serial.c  **** 	3,
 293:usb_serial.c  **** 	STR_MANUFACTURER
 294:usb_serial.c  **** };
 295:usb_serial.c  **** const static struct usb_string_descriptor_struct PROGMEM string2 = {
 296:usb_serial.c  **** 	sizeof(STR_PRODUCT),
 297:usb_serial.c  **** 	3,
 298:usb_serial.c  **** 	STR_PRODUCT
 299:usb_serial.c  **** };
 300:usb_serial.c  **** const static struct usb_string_descriptor_struct PROGMEM string3 = {
 301:usb_serial.c  **** 	sizeof(STR_SERIAL_NUMBER),
 302:usb_serial.c  **** 	3,
 303:usb_serial.c  **** 	STR_SERIAL_NUMBER
 304:usb_serial.c  **** };
 305:usb_serial.c  **** 
 306:usb_serial.c  **** // This table defines which descriptor data is sent for each specific
 307:usb_serial.c  **** // request from the host (in wValue and wIndex).
 308:usb_serial.c  **** const static struct descriptor_list_struct {
 309:usb_serial.c  **** 	uint16_t	wValue;
 310:usb_serial.c  **** 	uint16_t	wIndex;
 311:usb_serial.c  **** 	const uint8_t	*addr;
 312:usb_serial.c  **** 	uint8_t		length;
 313:usb_serial.c  **** } PROGMEM descriptor_list[] = {
 314:usb_serial.c  **** 	{0x0100, 0x0000, (const void *) &device_descriptor, sizeof(device_descriptor)},
 315:usb_serial.c  **** 	{0x0200, 0x0000, config1_descriptor, sizeof(config1_descriptor)},
 316:usb_serial.c  **** 	{0x0300, 0x0000, (const uint8_t *)&string0, 4},
 317:usb_serial.c  **** 	{0x0301, 0x0409, (const uint8_t *)&string1, sizeof(STR_MANUFACTURER)},
 318:usb_serial.c  **** 	{0x0302, 0x0409, (const uint8_t *)&string2, sizeof(STR_PRODUCT)},
 319:usb_serial.c  **** 	{0x0303, 0x0409, (const uint8_t *)&string3, sizeof(STR_SERIAL_NUMBER)}
 320:usb_serial.c  **** };
 321:usb_serial.c  **** #define NUM_DESC_LIST (sizeof(descriptor_list)/sizeof(struct descriptor_list_struct))
 322:usb_serial.c  **** 
 323:usb_serial.c  **** 
 324:usb_serial.c  **** /**************************************************************************
 325:usb_serial.c  ****  *
 326:usb_serial.c  ****  *  Variables - these are the only non-stack RAM usage
 327:usb_serial.c  ****  *
 328:usb_serial.c  ****  **************************************************************************/
 329:usb_serial.c  **** 
 330:usb_serial.c  **** // zero when we are not configured, non-zero when enumerated
 331:usb_serial.c  **** static volatile uint8_t usb_configuration=0;
 332:usb_serial.c  **** 
 333:usb_serial.c  **** // the time remaining before we transmit any partially full
 334:usb_serial.c  **** // packet, or send a zero length packet.
 335:usb_serial.c  **** static volatile uint8_t transmit_flush_timer=0;
 336:usb_serial.c  **** static uint8_t transmit_previous_timeout=0;
 337:usb_serial.c  **** 
 338:usb_serial.c  **** // serial port settings (baud rate, control signals, etc) set
 339:usb_serial.c  **** // by the PC.  These are ignored, but kept in RAM.
 340:usb_serial.c  **** static uint8_t cdc_line_coding[7]={0x00, 0xE1, 0x00, 0x00, 0x00, 0x00, 0x08};
 341:usb_serial.c  **** static uint8_t cdc_line_rtsdtr=0;
 342:usb_serial.c  **** 
 343:usb_serial.c  **** 
 344:usb_serial.c  **** /**************************************************************************
 345:usb_serial.c  ****  *
 346:usb_serial.c  ****  *  Public Functions - these are the API intended for the user
 347:usb_serial.c  ****  *
 348:usb_serial.c  ****  **************************************************************************/
 349:usb_serial.c  **** 
 350:usb_serial.c  **** // initialize USB serial
 351:usb_serial.c  **** void usb_init(void)
 352:usb_serial.c  **** {
 353:usb_serial.c  **** 	HW_CONFIG();
 354:usb_serial.c  ****         USB_FREEZE();				// enable USB
 355:usb_serial.c  ****         PLL_CONFIG();				// config PLL, 16 MHz xtal
 356:usb_serial.c  ****         while (!(PLLCSR & (1<<PLOCK))) ;	// wait for PLL lock
 357:usb_serial.c  ****         USB_CONFIG();				// start USB clock
 358:usb_serial.c  ****         UDCON = 0;				// enable attach resistor
 359:usb_serial.c  **** 	usb_configuration = 0;
 360:usb_serial.c  **** 	cdc_line_rtsdtr = 0;
 361:usb_serial.c  ****         UDIEN = (1<<EORSTE)|(1<<SOFE);
 362:usb_serial.c  **** 	sei();
 363:usb_serial.c  **** }
 364:usb_serial.c  **** 
 365:usb_serial.c  **** // return 0 if the USB is not configured, or the configuration
 366:usb_serial.c  **** // number selected by the HOST
 367:usb_serial.c  **** uint8_t usb_configured(void)
 368:usb_serial.c  **** {
 369:usb_serial.c  **** 	return usb_configuration;
 370:usb_serial.c  **** }
 371:usb_serial.c  **** 
 372:usb_serial.c  **** // get the next character, or -1 if nothing received
 373:usb_serial.c  **** int16_t usb_serial_getchar(void)
 374:usb_serial.c  **** {
 375:usb_serial.c  **** 	uint8_t c, intr_state;
 376:usb_serial.c  **** 
 377:usb_serial.c  **** 	// interrupts are disabled so these functions can be
 378:usb_serial.c  **** 	// used from the main program or interrupt context,
 379:usb_serial.c  **** 	// even both in the same program!
 380:usb_serial.c  **** 	intr_state = SREG;
 381:usb_serial.c  **** 	cli();
 382:usb_serial.c  **** 	if (!usb_configuration) {
 383:usb_serial.c  **** 		SREG = intr_state;
 384:usb_serial.c  **** 		return -1;
 385:usb_serial.c  **** 	}
 386:usb_serial.c  **** 	UENUM = CDC_RX_ENDPOINT;
 387:usb_serial.c  **** 	retry:
 388:usb_serial.c  **** 	c = UEINTX;
 389:usb_serial.c  **** 	if (!(c & (1<<RWAL))) {
 390:usb_serial.c  **** 		// no data in buffer
 391:usb_serial.c  **** 		if (c & (1<<RXOUTI)) {
 392:usb_serial.c  **** 			UEINTX = 0x6B;
 393:usb_serial.c  **** 			goto retry;
 394:usb_serial.c  **** 		}	
 395:usb_serial.c  **** 		SREG = intr_state;
 396:usb_serial.c  **** 		return -1;
 397:usb_serial.c  **** 	}
 398:usb_serial.c  **** 	// take one byte out of the buffer
 399:usb_serial.c  **** 	c = UEDATX;
 400:usb_serial.c  **** 	// if buffer completely used, release it
 401:usb_serial.c  **** 	if (!(UEINTX & (1<<RWAL))) UEINTX = 0x6B;
 402:usb_serial.c  **** 	SREG = intr_state;
 403:usb_serial.c  **** 	return c;
 404:usb_serial.c  **** }
 405:usb_serial.c  **** 
 406:usb_serial.c  **** // number of bytes available in the receive buffer
 407:usb_serial.c  **** uint8_t usb_serial_available(void)
 408:usb_serial.c  **** {
 409:usb_serial.c  **** 	uint8_t n=0, i, intr_state;
 410:usb_serial.c  **** 
 411:usb_serial.c  **** 	intr_state = SREG;
 412:usb_serial.c  **** 	cli();
 413:usb_serial.c  **** 	if (usb_configuration) {
 414:usb_serial.c  **** 		UENUM = CDC_RX_ENDPOINT;
 415:usb_serial.c  **** 		n = UEBCLX;
 416:usb_serial.c  **** 		if (!n) {
 417:usb_serial.c  **** 			i = UEINTX;
 418:usb_serial.c  **** 			if (i & (1<<RXOUTI) && !(i & (1<<RWAL))) UEINTX = 0x6B;
 419:usb_serial.c  **** 		}
 420:usb_serial.c  **** 	}
 421:usb_serial.c  **** 	SREG = intr_state;
 422:usb_serial.c  **** 	return n;
 423:usb_serial.c  **** }
 424:usb_serial.c  **** 
 425:usb_serial.c  **** // discard any buffered input
 426:usb_serial.c  **** void usb_serial_flush_input(void)
 427:usb_serial.c  **** {
 428:usb_serial.c  **** 	uint8_t intr_state;
 429:usb_serial.c  **** 
 430:usb_serial.c  **** 	if (usb_configuration) {
 431:usb_serial.c  **** 		intr_state = SREG;
 432:usb_serial.c  **** 		cli();
 433:usb_serial.c  **** 		UENUM = CDC_RX_ENDPOINT;
 434:usb_serial.c  **** 		while ((UEINTX & (1<<RWAL))) {
 435:usb_serial.c  **** 			UEINTX = 0x6B; 
 436:usb_serial.c  **** 		}
 437:usb_serial.c  **** 		SREG = intr_state;
 438:usb_serial.c  **** 	}
 439:usb_serial.c  **** }
 440:usb_serial.c  **** 
 441:usb_serial.c  **** 
 442:usb_serial.c  **** #if 0
 443:usb_serial.c  **** /**
 444:usb_serial.c  ****  * Copy the receive buffer into a user space array, of at least 64 bytes.
 445:usb_serial.c  ****  *
 446:usb_serial.c  ****  * \return Number of bytes copied in this packet, 0 if none, -1 on error.
 447:usb_serial.c  ****  */
 448:usb_serial.c  **** int8_t
 449:usb_serial.c  **** usb_serial_recv(
 450:usb_serial.c  **** 	uint8_t * buf
 451:usb_serial.c  **** )
 452:usb_serial.c  **** {
 453:usb_serial.c  **** 	// interrupts are disabled so these functions can be
 454:usb_serial.c  **** 	// used from the main program or interrupt context,
 455:usb_serial.c  **** 	// even both in the same program!
 456:usb_serial.c  **** 	const uint8_t intr_state = SREG;
 457:usb_serial.c  **** 	cli();
 458:usb_serial.c  **** 	if (!usb_configuration)
 459:usb_serial.c  **** 	{
 460:usb_serial.c  **** 		SREG = intr_state;
 461:usb_serial.c  **** 		return -1;
 462:usb_serial.c  **** 	}
 463:usb_serial.c  **** 
 464:usb_serial.c  **** 	int offset = 0;
 465:usb_serial.c  **** 
 466:usb_serial.c  **** 	UENUM = CDC_RX_ENDPOINT;
 467:usb_serial.c  **** 	while (1)
 468:usb_serial.c  **** 	{
 469:usb_serial.c  **** 		if (bit_is_clear(UEINTX, RWAL))
 470:usb_serial.c  **** 		{
 471:usb_serial.c  **** 			// No data in the buffer .
 472:usb_serial.c  **** 			if (bit_is_clear(UEINTX, RXOUTI))
 473:usb_serial.c  **** 			{
 474:usb_serial.c  **** 				UEINTX = 0x6B;
 475:usb_serial.c  **** 				goto retry;
 476:usb_serial.c  **** 			}	
 477:usb_serial.c  **** 			SREG = intr_state;
 478:usb_serial.c  **** 			return -1;
 479:usb_serial.c  **** 		}
 480:usb_serial.c  **** 
 481:usb_serial.c  **** 		// take one byte out of the buffer
 482:usb_serial.c  **** 		c = UEDATX;
 483:usb_serial.c  **** 		// if buffer completely used, release it
 484:usb_serial.c  **** 	if (!(UEINTX & (1<<RWAL))) UEINTX = 0x6B;
 485:usb_serial.c  **** 	SREG = intr_state;
 486:usb_serial.c  **** 	return c;
 487:usb_serial.c  **** }
 488:usb_serial.c  **** #endif
 489:usb_serial.c  **** 
 490:usb_serial.c  **** // transmit a character.  0 returned on success, -1 on error
 491:usb_serial.c  **** int8_t usb_serial_putchar(uint8_t c)
 492:usb_serial.c  **** {
 493:usb_serial.c  **** 	uint8_t timeout, intr_state;
 494:usb_serial.c  **** 
 495:usb_serial.c  **** 	// if we're not online (enumerated and configured), error
 496:usb_serial.c  **** 	if (!usb_configuration) return -1;
 497:usb_serial.c  **** 	// interrupts are disabled so these functions can be
 498:usb_serial.c  **** 	// used from the main program or interrupt context,
 499:usb_serial.c  **** 	// even both in the same program!
 500:usb_serial.c  **** 	intr_state = SREG;
 501:usb_serial.c  **** 	cli();
 502:usb_serial.c  **** 	UENUM = CDC_TX_ENDPOINT;
 503:usb_serial.c  **** 	// if we gave up due to timeout before, don't wait again
 504:usb_serial.c  **** 	if (transmit_previous_timeout) {
 505:usb_serial.c  **** 		if (!(UEINTX & (1<<RWAL))) {
 506:usb_serial.c  **** 			SREG = intr_state;
 507:usb_serial.c  **** 			return -1;
 508:usb_serial.c  **** 		}
 509:usb_serial.c  **** 		transmit_previous_timeout = 0;
 510:usb_serial.c  **** 	}
 511:usb_serial.c  **** 	// wait for the FIFO to be ready to accept data
 512:usb_serial.c  **** 	timeout = UDFNUML + TRANSMIT_TIMEOUT;
 513:usb_serial.c  **** 	while (1) {
 514:usb_serial.c  **** 		// are we ready to transmit?
 515:usb_serial.c  **** 		if (UEINTX & (1<<RWAL)) break;
 516:usb_serial.c  **** 		SREG = intr_state;
 517:usb_serial.c  **** 		// have we waited too long?  This happens if the user
 518:usb_serial.c  **** 		// is not running an application that is listening
 519:usb_serial.c  **** 		if (UDFNUML == timeout) {
 520:usb_serial.c  **** 			transmit_previous_timeout = 1;
 521:usb_serial.c  **** 			return -1;
 522:usb_serial.c  **** 		}
 523:usb_serial.c  **** 		// has the USB gone offline?
 524:usb_serial.c  **** 		if (!usb_configuration) return -1;
 525:usb_serial.c  **** 		// get ready to try checking again
 526:usb_serial.c  **** 		intr_state = SREG;
 527:usb_serial.c  **** 		cli();
 528:usb_serial.c  **** 		UENUM = CDC_TX_ENDPOINT;
 529:usb_serial.c  **** 	}
 530:usb_serial.c  **** 	// actually write the byte into the FIFO
 531:usb_serial.c  **** 	UEDATX = c;
 532:usb_serial.c  **** 	// if this completed a packet, transmit it now!
 533:usb_serial.c  **** 	if (!(UEINTX & (1<<RWAL))) UEINTX = 0x3A;
 534:usb_serial.c  **** 	transmit_flush_timer = TRANSMIT_FLUSH_TIMEOUT;
 535:usb_serial.c  **** 	SREG = intr_state;
 536:usb_serial.c  **** 	return 0;
 537:usb_serial.c  **** }
 538:usb_serial.c  **** 
 539:usb_serial.c  **** 
 540:usb_serial.c  **** // transmit a character, but do not wait if the buffer is full,
 541:usb_serial.c  **** //   0 returned on success, -1 on buffer full or error 
 542:usb_serial.c  **** int8_t usb_serial_putchar_nowait(uint8_t c)
 543:usb_serial.c  **** {
 544:usb_serial.c  **** 	uint8_t intr_state;
 545:usb_serial.c  **** 
 546:usb_serial.c  **** 	if (!usb_configuration) return -1;
 547:usb_serial.c  **** 	intr_state = SREG;
 548:usb_serial.c  **** 	cli();
 549:usb_serial.c  **** 	UENUM = CDC_TX_ENDPOINT;
 550:usb_serial.c  **** 	if (!(UEINTX & (1<<RWAL))) {
 551:usb_serial.c  **** 		// buffer is full
 552:usb_serial.c  **** 		SREG = intr_state;
 553:usb_serial.c  **** 		return -1;
 554:usb_serial.c  **** 	}
 555:usb_serial.c  **** 	// actually write the byte into the FIFO
 556:usb_serial.c  **** 	UEDATX = c;
 557:usb_serial.c  **** 		// if this completed a packet, transmit it now!
 558:usb_serial.c  **** 	if (!(UEINTX & (1<<RWAL))) UEINTX = 0x3A;
 559:usb_serial.c  **** 	transmit_flush_timer = TRANSMIT_FLUSH_TIMEOUT;
 560:usb_serial.c  **** 	SREG = intr_state;
 561:usb_serial.c  **** 	return 0;
 562:usb_serial.c  **** }
 563:usb_serial.c  **** 
 564:usb_serial.c  **** // transmit a buffer.
 565:usb_serial.c  **** //  0 returned on success, -1 on error
 566:usb_serial.c  **** // This function is optimized for speed!  Each call takes approx 6.1 us overhead
 567:usb_serial.c  **** // plus 0.25 us per byte.  12 Mbit/sec USB has 8.67 us per-packet overhead and
 568:usb_serial.c  **** // takes 0.67 us per byte.  If called with 64 byte packet-size blocks, this function
 569:usb_serial.c  **** // can transmit at full USB speed using 43% CPU time.  The maximum theoretical speed
 570:usb_serial.c  **** // is 19 packets per USB frame, or 1216 kbytes/sec.  However, bulk endpoints have the
 571:usb_serial.c  **** // lowest priority, so any other USB devices will likely reduce the speed.  Speed
 572:usb_serial.c  **** // can also be limited by how quickly the PC-based software reads data, as the host
 573:usb_serial.c  **** // controller in the PC will not allocate bandwitdh without a pending read request.
 574:usb_serial.c  **** // (thanks to Victor Suarez for testing and feedback and initial code)
 575:usb_serial.c  **** 
 576:usb_serial.c  **** int8_t usb_serial_write(const uint8_t *buffer, uint16_t size)
 577:usb_serial.c  **** {
 578:usb_serial.c  **** 	uint8_t timeout, intr_state, write_size;
 579:usb_serial.c  **** 
 580:usb_serial.c  **** 	// if we're not online (enumerated and configured), error
 581:usb_serial.c  **** 	if (!usb_configuration) return -1;
 582:usb_serial.c  **** 	// interrupts are disabled so these functions can be
 583:usb_serial.c  **** 	// used from the main program or interrupt context,
 584:usb_serial.c  **** 	// even both in the same program!
 585:usb_serial.c  **** 	intr_state = SREG;
 586:usb_serial.c  **** 	cli();
 587:usb_serial.c  **** 	UENUM = CDC_TX_ENDPOINT;
 588:usb_serial.c  **** 	// if we gave up due to timeout before, don't wait again
 589:usb_serial.c  **** 	if (transmit_previous_timeout) {
 590:usb_serial.c  **** 		if (!(UEINTX & (1<<RWAL))) {
 591:usb_serial.c  **** 			SREG = intr_state;
 592:usb_serial.c  **** 			return -1;
 593:usb_serial.c  **** 		}
 594:usb_serial.c  **** 		transmit_previous_timeout = 0;
 595:usb_serial.c  **** 	}
 596:usb_serial.c  **** 	// each iteration of this loop transmits a packet
 597:usb_serial.c  **** 	while (size) {
 598:usb_serial.c  **** 		// wait for the FIFO to be ready to accept data
 599:usb_serial.c  **** 		timeout = UDFNUML + TRANSMIT_TIMEOUT;
 600:usb_serial.c  **** 		while (1) {
 601:usb_serial.c  **** 			// are we ready to transmit?
 602:usb_serial.c  **** 			if (UEINTX & (1<<RWAL)) break;
 603:usb_serial.c  **** 			SREG = intr_state;
 604:usb_serial.c  **** 			// have we waited too long?  This happens if the user
 605:usb_serial.c  **** 			// is not running an application that is listening
 606:usb_serial.c  **** 			if (UDFNUML == timeout) {
 607:usb_serial.c  **** 				transmit_previous_timeout = 1;
 608:usb_serial.c  **** 				return -1;
 609:usb_serial.c  **** 			}
 610:usb_serial.c  **** 			// has the USB gone offline?
 611:usb_serial.c  **** 			if (!usb_configuration) return -1;
 612:usb_serial.c  **** 			// get ready to try checking again
 613:usb_serial.c  **** 			intr_state = SREG;
 614:usb_serial.c  **** 			cli();
 615:usb_serial.c  **** 			UENUM = CDC_TX_ENDPOINT;
 616:usb_serial.c  **** 		}
 617:usb_serial.c  **** 
 618:usb_serial.c  **** 		// compute how many bytes will fit into the next packet
 619:usb_serial.c  **** 		write_size = CDC_TX_SIZE - UEBCLX;
 620:usb_serial.c  **** 		if (write_size > size) write_size = size;
 621:usb_serial.c  **** 		size -= write_size;
 622:usb_serial.c  **** 
 623:usb_serial.c  **** 		// write the packet
 624:usb_serial.c  **** 		switch (write_size) {
 625:usb_serial.c  **** 			#if (CDC_TX_SIZE == 64)
 626:usb_serial.c  **** 			case 64: UEDATX = *buffer++;
 627:usb_serial.c  **** 			case 63: UEDATX = *buffer++;
 628:usb_serial.c  **** 			case 62: UEDATX = *buffer++;
 629:usb_serial.c  **** 			case 61: UEDATX = *buffer++;
 630:usb_serial.c  **** 			case 60: UEDATX = *buffer++;
 631:usb_serial.c  **** 			case 59: UEDATX = *buffer++;
 632:usb_serial.c  **** 			case 58: UEDATX = *buffer++;
 633:usb_serial.c  **** 			case 57: UEDATX = *buffer++;
 634:usb_serial.c  **** 			case 56: UEDATX = *buffer++;
 635:usb_serial.c  **** 			case 55: UEDATX = *buffer++;
 636:usb_serial.c  **** 			case 54: UEDATX = *buffer++;
 637:usb_serial.c  **** 			case 53: UEDATX = *buffer++;
 638:usb_serial.c  **** 			case 52: UEDATX = *buffer++;
 639:usb_serial.c  **** 			case 51: UEDATX = *buffer++;
 640:usb_serial.c  **** 			case 50: UEDATX = *buffer++;
 641:usb_serial.c  **** 			case 49: UEDATX = *buffer++;
 642:usb_serial.c  **** 			case 48: UEDATX = *buffer++;
 643:usb_serial.c  **** 			case 47: UEDATX = *buffer++;
 644:usb_serial.c  **** 			case 46: UEDATX = *buffer++;
 645:usb_serial.c  **** 			case 45: UEDATX = *buffer++;
 646:usb_serial.c  **** 			case 44: UEDATX = *buffer++;
 647:usb_serial.c  **** 			case 43: UEDATX = *buffer++;
 648:usb_serial.c  **** 			case 42: UEDATX = *buffer++;
 649:usb_serial.c  **** 			case 41: UEDATX = *buffer++;
 650:usb_serial.c  **** 			case 40: UEDATX = *buffer++;
 651:usb_serial.c  **** 			case 39: UEDATX = *buffer++;
 652:usb_serial.c  **** 			case 38: UEDATX = *buffer++;
 653:usb_serial.c  **** 			case 37: UEDATX = *buffer++;
 654:usb_serial.c  **** 			case 36: UEDATX = *buffer++;
 655:usb_serial.c  **** 			case 35: UEDATX = *buffer++;
 656:usb_serial.c  **** 			case 34: UEDATX = *buffer++;
 657:usb_serial.c  **** 			case 33: UEDATX = *buffer++;
 658:usb_serial.c  **** 			#endif
 659:usb_serial.c  **** 			#if (CDC_TX_SIZE >= 32)
 660:usb_serial.c  **** 			case 32: UEDATX = *buffer++;
 661:usb_serial.c  **** 			case 31: UEDATX = *buffer++;
 662:usb_serial.c  **** 			case 30: UEDATX = *buffer++;
 663:usb_serial.c  **** 			case 29: UEDATX = *buffer++;
 664:usb_serial.c  **** 			case 28: UEDATX = *buffer++;
 665:usb_serial.c  **** 			case 27: UEDATX = *buffer++;
 666:usb_serial.c  **** 			case 26: UEDATX = *buffer++;
 667:usb_serial.c  **** 			case 25: UEDATX = *buffer++;
 668:usb_serial.c  **** 			case 24: UEDATX = *buffer++;
 669:usb_serial.c  **** 			case 23: UEDATX = *buffer++;
 670:usb_serial.c  **** 			case 22: UEDATX = *buffer++;
 671:usb_serial.c  **** 			case 21: UEDATX = *buffer++;
 672:usb_serial.c  **** 			case 20: UEDATX = *buffer++;
 673:usb_serial.c  **** 			case 19: UEDATX = *buffer++;
 674:usb_serial.c  **** 			case 18: UEDATX = *buffer++;
 675:usb_serial.c  **** 			case 17: UEDATX = *buffer++;
 676:usb_serial.c  **** 			#endif
 677:usb_serial.c  **** 			#if (CDC_TX_SIZE >= 16)
 678:usb_serial.c  **** 			case 16: UEDATX = *buffer++;
 679:usb_serial.c  **** 			case 15: UEDATX = *buffer++;
 680:usb_serial.c  **** 			case 14: UEDATX = *buffer++;
 681:usb_serial.c  **** 			case 13: UEDATX = *buffer++;
 682:usb_serial.c  **** 			case 12: UEDATX = *buffer++;
 683:usb_serial.c  **** 			case 11: UEDATX = *buffer++;
 684:usb_serial.c  **** 			case 10: UEDATX = *buffer++;
 685:usb_serial.c  **** 			case  9: UEDATX = *buffer++;
 686:usb_serial.c  **** 			#endif
 687:usb_serial.c  **** 			case  8: UEDATX = *buffer++;
 688:usb_serial.c  **** 			case  7: UEDATX = *buffer++;
 689:usb_serial.c  **** 			case  6: UEDATX = *buffer++;
 690:usb_serial.c  **** 			case  5: UEDATX = *buffer++;
 691:usb_serial.c  **** 			case  4: UEDATX = *buffer++;
 692:usb_serial.c  **** 			case  3: UEDATX = *buffer++;
 693:usb_serial.c  **** 			case  2: UEDATX = *buffer++;
 694:usb_serial.c  **** 			default:
 695:usb_serial.c  **** 			case  1: UEDATX = *buffer++;
 696:usb_serial.c  **** 			case  0: break;
 697:usb_serial.c  **** 		}
 698:usb_serial.c  **** 		// if this completed a packet, transmit it now!
 699:usb_serial.c  **** 		if (!(UEINTX & (1<<RWAL))) UEINTX = 0x3A;
 700:usb_serial.c  **** 		transmit_flush_timer = TRANSMIT_FLUSH_TIMEOUT;
 701:usb_serial.c  **** 		SREG = intr_state;
 702:usb_serial.c  **** 	}
 703:usb_serial.c  **** 	return 0;
 704:usb_serial.c  **** }
 705:usb_serial.c  **** 
 706:usb_serial.c  **** 
 707:usb_serial.c  **** // immediately transmit any buffered output.
 708:usb_serial.c  **** // This doesn't actually transmit the data - that is impossible!
 709:usb_serial.c  **** // USB devices only transmit when the host allows, so the best
 710:usb_serial.c  **** // we can do is release the FIFO buffer for when the host wants it
 711:usb_serial.c  **** void usb_serial_flush_output(void)
 712:usb_serial.c  **** {
 713:usb_serial.c  **** 	uint8_t intr_state;
 714:usb_serial.c  **** 
 715:usb_serial.c  **** 	intr_state = SREG;
 716:usb_serial.c  **** 	cli();
 717:usb_serial.c  **** 	if (transmit_flush_timer) {
 718:usb_serial.c  **** 		UENUM = CDC_TX_ENDPOINT;
 719:usb_serial.c  **** 		UEINTX = 0x3A;
 720:usb_serial.c  **** 		transmit_flush_timer = 0;
 721:usb_serial.c  **** 	}
 722:usb_serial.c  **** 	SREG = intr_state;
 723:usb_serial.c  **** }
 724:usb_serial.c  **** 
 725:usb_serial.c  **** // functions to read the various async serial settings.  These
 726:usb_serial.c  **** // aren't actually used by USB at all (communication is always
 727:usb_serial.c  **** // at full USB speed), but they are set by the host so we can
 728:usb_serial.c  **** // set them properly if we're converting the USB to a real serial
 729:usb_serial.c  **** // communication
 730:usb_serial.c  **** uint32_t usb_serial_get_baud(void)
 731:usb_serial.c  **** {
 732:usb_serial.c  **** 	return *(uint32_t *)cdc_line_coding;
 733:usb_serial.c  **** }
 734:usb_serial.c  **** uint8_t usb_serial_get_stopbits(void)
 735:usb_serial.c  **** {
 736:usb_serial.c  **** 	return cdc_line_coding[4];
 737:usb_serial.c  **** }
 738:usb_serial.c  **** uint8_t usb_serial_get_paritytype(void)
 739:usb_serial.c  **** {
 740:usb_serial.c  **** 	return cdc_line_coding[5];
 741:usb_serial.c  **** }
 742:usb_serial.c  **** uint8_t usb_serial_get_numbits(void)
 743:usb_serial.c  **** {
 744:usb_serial.c  **** 	return cdc_line_coding[6];
 745:usb_serial.c  **** }
 746:usb_serial.c  **** uint8_t usb_serial_get_control(void)
 747:usb_serial.c  **** {
 748:usb_serial.c  **** 	return cdc_line_rtsdtr;
 749:usb_serial.c  **** }
 750:usb_serial.c  **** // write the control signals, DCD, DSR, RI, etc
 751:usb_serial.c  **** // There is no CTS signal.  If software on the host has transmitted
 752:usb_serial.c  **** // data to you but you haven't been calling the getchar function,
 753:usb_serial.c  **** // it remains buffered (either here or on the host) and can not be
 754:usb_serial.c  **** // lost because you weren't listening at the right time, like it
 755:usb_serial.c  **** // would in real serial communication.
 756:usb_serial.c  **** int8_t usb_serial_set_control(uint8_t signals)
 757:usb_serial.c  **** {
 758:usb_serial.c  **** 	uint8_t intr_state;
 759:usb_serial.c  **** 
 760:usb_serial.c  **** 	intr_state = SREG;
 761:usb_serial.c  **** 	cli();
 762:usb_serial.c  **** 	if (!usb_configuration) {
 763:usb_serial.c  **** 		// we're not enumerated/configured
 764:usb_serial.c  **** 		SREG = intr_state;
 765:usb_serial.c  **** 		return -1;
 766:usb_serial.c  **** 	}
 767:usb_serial.c  **** 
 768:usb_serial.c  **** 	UENUM = CDC_ACM_ENDPOINT;
 769:usb_serial.c  **** 	if (!(UEINTX & (1<<RWAL))) {
 770:usb_serial.c  **** 		// unable to write
 771:usb_serial.c  **** 		// TODO; should this try to abort the previously
 772:usb_serial.c  **** 		// buffered message??
 773:usb_serial.c  **** 		SREG = intr_state;
 774:usb_serial.c  **** 		return -1;
 775:usb_serial.c  **** 	}
 776:usb_serial.c  **** 	UEDATX = 0xA1;
 777:usb_serial.c  **** 	UEDATX = 0x20;
 778:usb_serial.c  **** 	UEDATX = 0;
 779:usb_serial.c  **** 	UEDATX = 0;
 780:usb_serial.c  **** 	UEDATX = 0; // 0 seems to work nicely.  what if this is 1??
 781:usb_serial.c  **** 	UEDATX = 0;
 782:usb_serial.c  **** 	UEDATX = 1;
 783:usb_serial.c  **** 	UEDATX = 0;
 784:usb_serial.c  **** 	UEDATX = signals;
 785:usb_serial.c  **** 	UEINTX = 0x3A;
 786:usb_serial.c  **** 	SREG = intr_state;
 787:usb_serial.c  **** 	return 0;
 788:usb_serial.c  **** }
 789:usb_serial.c  **** 
 790:usb_serial.c  **** 
 791:usb_serial.c  **** 
 792:usb_serial.c  **** /**************************************************************************
 793:usb_serial.c  ****  *
 794:usb_serial.c  ****  *  Private Functions - not intended for general user consumption....
 795:usb_serial.c  ****  *
 796:usb_serial.c  ****  **************************************************************************/
 797:usb_serial.c  **** 
 798:usb_serial.c  **** 
 799:usb_serial.c  **** // USB Device Interrupt - handle all device-level events
 800:usb_serial.c  **** // the transmit buffer flushing is triggered by the start of frame
 801:usb_serial.c  **** //
 802:usb_serial.c  **** ISR(USB_GEN_vect)
 803:usb_serial.c  **** {
 804:usb_serial.c  **** 	uint8_t intbits, t;
 805:usb_serial.c  **** 
 806:usb_serial.c  ****         intbits = UDINT;
 807:usb_serial.c  ****         UDINT = 0;
 808:usb_serial.c  ****         if (intbits & (1<<EORSTI)) {
 809:usb_serial.c  **** 		UENUM = 0;
 810:usb_serial.c  **** 		UECONX = 1;
 811:usb_serial.c  **** 		UECFG0X = EP_TYPE_CONTROL;
 812:usb_serial.c  **** 		UECFG1X = EP_SIZE(ENDPOINT0_SIZE) | EP_SINGLE_BUFFER;
 813:usb_serial.c  **** 		UEIENX = (1<<RXSTPE);
 814:usb_serial.c  **** 		usb_configuration = 0;
 815:usb_serial.c  **** 		cdc_line_rtsdtr = 0;
 816:usb_serial.c  ****         }
 817:usb_serial.c  **** 	if (intbits & (1<<SOFI)) {
 818:usb_serial.c  **** 		if (usb_configuration) {
 819:usb_serial.c  **** 			t = transmit_flush_timer;
 820:usb_serial.c  **** 			if (t) {
 821:usb_serial.c  **** 				transmit_flush_timer = --t;
 822:usb_serial.c  **** 				if (!t) {
 823:usb_serial.c  **** 					UENUM = CDC_TX_ENDPOINT;
 824:usb_serial.c  **** 					UEINTX = 0x3A;
 825:usb_serial.c  **** 				}
 826:usb_serial.c  **** 			}
 827:usb_serial.c  **** 		}
 828:usb_serial.c  **** 	}
 829:usb_serial.c  **** }
 830:usb_serial.c  **** 
 831:usb_serial.c  **** 
 832:usb_serial.c  **** // Misc functions to wait for ready and send/receive packets
 833:usb_serial.c  **** static inline void usb_wait_in_ready(void)
 834:usb_serial.c  **** {
  16               		.loc 1 834 0
  17               		.cfi_startproc
  18               	/* prologue: function */
  19               	/* frame size = 0 */
  20               	/* stack size = 0 */
  21               	.L__stack_usage = 0
  22               	.L2:
 835:usb_serial.c  **** 	while (!(UEINTX & (1<<TXINI))) ;
  23               		.loc 1 835 0 discriminator 1
  24 0000 8091 E800 		lds r24,232
  25 0004 80FF      		sbrs r24,0
  26 0006 00C0      		rjmp .L2
  27               	/* epilogue start */
 836:usb_serial.c  **** }
  28               		.loc 1 836 0
  29 0008 0895      		ret
  30               		.cfi_endproc
  31               	.LFE17:
  33               		.section	.text.usb_init,"ax",@progbits
  34               	.global	usb_init
  36               	usb_init:
  37               	.LFB1:
 352:usb_serial.c  **** 	HW_CONFIG();
  38               		.loc 1 352 0
  39               		.cfi_startproc
  40               	/* prologue: function */
  41               	/* frame size = 0 */
  42               	/* stack size = 0 */
  43               	.L__stack_usage = 0
 353:usb_serial.c  ****         USB_FREEZE();				// enable USB
  44               		.loc 1 353 0
  45 0000 81E8      		ldi r24,lo8(-127)
  46 0002 8093 D700 		sts 215,r24
 354:usb_serial.c  ****         PLL_CONFIG();				// config PLL, 16 MHz xtal
  47               		.loc 1 354 0
  48 0006 80EA      		ldi r24,lo8(-96)
  49 0008 8093 D800 		sts 216,r24
 355:usb_serial.c  ****         while (!(PLLCSR & (1<<PLOCK))) ;	// wait for PLL lock
  50               		.loc 1 355 0
  51 000c 86E1      		ldi r24,lo8(22)
  52 000e 89BD      		out 0x29,r24
  53               	.L7:
 356:usb_serial.c  ****         USB_CONFIG();				// start USB clock
  54               		.loc 1 356 0 discriminator 1
  55 0010 09B4      		in __tmp_reg__,0x29
  56 0012 00FE      		sbrs __tmp_reg__,0
  57 0014 00C0      		rjmp .L7
 357:usb_serial.c  ****         UDCON = 0;				// enable attach resistor
  58               		.loc 1 357 0
  59 0016 80E9      		ldi r24,lo8(-112)
  60 0018 8093 D800 		sts 216,r24
 358:usb_serial.c  **** 	usb_configuration = 0;
  61               		.loc 1 358 0
  62 001c 1092 E000 		sts 224,__zero_reg__
 359:usb_serial.c  **** 	cdc_line_rtsdtr = 0;
  63               		.loc 1 359 0
  64 0020 1092 0000 		sts usb_configuration,__zero_reg__
 360:usb_serial.c  ****         UDIEN = (1<<EORSTE)|(1<<SOFE);
  65               		.loc 1 360 0
  66 0024 1092 0000 		sts cdc_line_rtsdtr,__zero_reg__
 361:usb_serial.c  **** 	sei();
  67               		.loc 1 361 0
  68 0028 8CE0      		ldi r24,lo8(12)
  69 002a 8093 E200 		sts 226,r24
 362:usb_serial.c  **** }
  70               		.loc 1 362 0
  71               	/* #APP */
  72               	 ;  362 "usb_serial.c" 1
  73 002e 7894      		sei
  74               	 ;  0 "" 2
  75               	/* #NOAPP */
  76 0030 0895      		ret
  77               		.cfi_endproc
  78               	.LFE1:
  80               		.section	.text.usb_configured,"ax",@progbits
  81               	.global	usb_configured
  83               	usb_configured:
  84               	.LFB2:
 368:usb_serial.c  **** 	return usb_configuration;
  85               		.loc 1 368 0
  86               		.cfi_startproc
  87               	/* prologue: function */
  88               	/* frame size = 0 */
  89               	/* stack size = 0 */
  90               	.L__stack_usage = 0
 369:usb_serial.c  **** }
  91               		.loc 1 369 0
  92 0000 8091 0000 		lds r24,usb_configuration
 370:usb_serial.c  **** 
  93               		.loc 1 370 0
  94 0004 0895      		ret
  95               		.cfi_endproc
  96               	.LFE2:
  98               		.section	.text.usb_serial_getchar,"ax",@progbits
  99               	.global	usb_serial_getchar
 101               	usb_serial_getchar:
 102               	.LFB3:
 374:usb_serial.c  **** 	uint8_t c, intr_state;
 103               		.loc 1 374 0
 104               		.cfi_startproc
 105               	/* prologue: function */
 106               	/* frame size = 0 */
 107               	/* stack size = 0 */
 108               	.L__stack_usage = 0
 380:usb_serial.c  **** 	cli();
 109               		.loc 1 380 0
 110 0000 9FB7      		in r25,__SREG__
 111               	.LVL0:
 381:usb_serial.c  **** 	if (!usb_configuration) {
 112               		.loc 1 381 0
 113               	/* #APP */
 114               	 ;  381 "usb_serial.c" 1
 115 0002 F894      		cli
 116               	 ;  0 "" 2
 382:usb_serial.c  **** 		SREG = intr_state;
 117               		.loc 1 382 0
 118               	/* #NOAPP */
 119 0004 8091 0000 		lds r24,usb_configuration
 120 0008 8823      		tst r24
 121 000a 01F0      		breq .L16
 386:usb_serial.c  **** 	retry:
 122               		.loc 1 386 0
 123 000c 83E0      		ldi r24,lo8(3)
 124 000e 8093 E900 		sts 233,r24
 392:usb_serial.c  **** 			goto retry;
 125               		.loc 1 392 0
 126 0012 2BE6      		ldi r18,lo8(107)
 127               	.L14:
 388:usb_serial.c  **** 	if (!(c & (1<<RWAL))) {
 128               		.loc 1 388 0
 129 0014 8091 E800 		lds r24,232
 130               	.LVL1:
 389:usb_serial.c  **** 		// no data in buffer
 131               		.loc 1 389 0
 132 0018 85FD      		sbrc r24,5
 133 001a 00C0      		rjmp .L15
 391:usb_serial.c  **** 			UEINTX = 0x6B;
 134               		.loc 1 391 0
 135 001c 82FF      		sbrs r24,2
 136 001e 00C0      		rjmp .L16
 392:usb_serial.c  **** 			goto retry;
 137               		.loc 1 392 0
 138 0020 2093 E800 		sts 232,r18
 393:usb_serial.c  **** 		}	
 139               		.loc 1 393 0
 140 0024 00C0      		rjmp .L14
 141               	.LVL2:
 142               	.L16:
 395:usb_serial.c  **** 		return -1;
 143               		.loc 1 395 0
 144 0026 9FBF      		out __SREG__,r25
 396:usb_serial.c  **** 	}
 145               		.loc 1 396 0
 146 0028 8FEF      		ldi r24,lo8(-1)
 147 002a 9FEF      		ldi r25,lo8(-1)
 148 002c 0895      		ret
 149               	.LVL3:
 150               	.L15:
 399:usb_serial.c  **** 	// if buffer completely used, release it
 151               		.loc 1 399 0
 152 002e 8091 F100 		lds r24,241
 153               	.LVL4:
 401:usb_serial.c  **** 	SREG = intr_state;
 154               		.loc 1 401 0
 155 0032 2091 E800 		lds r18,232
 156 0036 25FD      		sbrc r18,5
 157 0038 00C0      		rjmp .L17
 401:usb_serial.c  **** 	SREG = intr_state;
 158               		.loc 1 401 0 is_stmt 0 discriminator 1
 159 003a 2BE6      		ldi r18,lo8(107)
 160 003c 2093 E800 		sts 232,r18
 161               	.L17:
 402:usb_serial.c  **** 	return c;
 162               		.loc 1 402 0 is_stmt 1
 163 0040 9FBF      		out __SREG__,r25
 403:usb_serial.c  **** }
 164               		.loc 1 403 0
 165 0042 90E0      		ldi r25,0
 166               	.LVL5:
 404:usb_serial.c  **** 
 167               		.loc 1 404 0
 168 0044 0895      		ret
 169               		.cfi_endproc
 170               	.LFE3:
 172               		.section	.text.usb_serial_available,"ax",@progbits
 173               	.global	usb_serial_available
 175               	usb_serial_available:
 176               	.LFB4:
 408:usb_serial.c  **** 	uint8_t n=0, i, intr_state;
 177               		.loc 1 408 0
 178               		.cfi_startproc
 179               	/* prologue: function */
 180               	/* frame size = 0 */
 181               	/* stack size = 0 */
 182               	.L__stack_usage = 0
 183               	.LVL6:
 411:usb_serial.c  **** 	cli();
 184               		.loc 1 411 0
 185 0000 2FB7      		in r18,__SREG__
 186               	.LVL7:
 412:usb_serial.c  **** 	if (usb_configuration) {
 187               		.loc 1 412 0
 188               	/* #APP */
 189               	 ;  412 "usb_serial.c" 1
 190 0002 F894      		cli
 191               	 ;  0 "" 2
 413:usb_serial.c  **** 		UENUM = CDC_RX_ENDPOINT;
 192               		.loc 1 413 0
 193               	/* #NOAPP */
 194 0004 8091 0000 		lds r24,usb_configuration
 195 0008 8111      		cpse r24,__zero_reg__
 196 000a 00C0      		rjmp .L19
 197               	.LVL8:
 198               	.L21:
 409:usb_serial.c  **** 
 199               		.loc 1 409 0
 200 000c 80E0      		ldi r24,0
 201 000e 00C0      		rjmp .L20
 202               	.LVL9:
 203               	.L19:
 414:usb_serial.c  **** 		n = UEBCLX;
 204               		.loc 1 414 0
 205 0010 83E0      		ldi r24,lo8(3)
 206 0012 8093 E900 		sts 233,r24
 415:usb_serial.c  **** 		if (!n) {
 207               		.loc 1 415 0
 208 0016 8091 F200 		lds r24,242
 209               	.LVL10:
 416:usb_serial.c  **** 			i = UEINTX;
 210               		.loc 1 416 0
 211 001a 8111      		cpse r24,__zero_reg__
 212 001c 00C0      		rjmp .L20
 417:usb_serial.c  **** 			if (i & (1<<RXOUTI) && !(i & (1<<RWAL))) UEINTX = 0x6B;
 213               		.loc 1 417 0
 214 001e 9091 E800 		lds r25,232
 215               	.LVL11:
 418:usb_serial.c  **** 		}
 216               		.loc 1 418 0
 217 0022 92FF      		sbrs r25,2
 218 0024 00C0      		rjmp .L21
 418:usb_serial.c  **** 		}
 219               		.loc 1 418 0 is_stmt 0 discriminator 1
 220 0026 95FD      		sbrc r25,5
 221 0028 00C0      		rjmp .L21
 418:usb_serial.c  **** 		}
 222               		.loc 1 418 0 discriminator 2
 223 002a 9BE6      		ldi r25,lo8(107)
 224               	.LVL12:
 225 002c 9093 E800 		sts 232,r25
 226               	.LVL13:
 227               	.L20:
 421:usb_serial.c  **** 	return n;
 228               		.loc 1 421 0 is_stmt 1
 229 0030 2FBF      		out __SREG__,r18
 423:usb_serial.c  **** 
 230               		.loc 1 423 0
 231 0032 0895      		ret
 232               		.cfi_endproc
 233               	.LFE4:
 235               		.section	.text.usb_serial_flush_input,"ax",@progbits
 236               	.global	usb_serial_flush_input
 238               	usb_serial_flush_input:
 239               	.LFB5:
 427:usb_serial.c  **** 	uint8_t intr_state;
 240               		.loc 1 427 0
 241               		.cfi_startproc
 242               	/* prologue: function */
 243               	/* frame size = 0 */
 244               	/* stack size = 0 */
 245               	.L__stack_usage = 0
 430:usb_serial.c  **** 		intr_state = SREG;
 246               		.loc 1 430 0
 247 0000 8091 0000 		lds r24,usb_configuration
 248 0004 8823      		tst r24
 249 0006 01F0      		breq .L25
 431:usb_serial.c  **** 		cli();
 250               		.loc 1 431 0
 251 0008 8FB7      		in r24,__SREG__
 252               	.LVL14:
 432:usb_serial.c  **** 		UENUM = CDC_RX_ENDPOINT;
 253               		.loc 1 432 0
 254               	/* #APP */
 255               	 ;  432 "usb_serial.c" 1
 256 000a F894      		cli
 257               	 ;  0 "" 2
 433:usb_serial.c  **** 		while ((UEINTX & (1<<RWAL))) {
 258               		.loc 1 433 0
 259               	/* #NOAPP */
 260 000c 93E0      		ldi r25,lo8(3)
 261 000e 9093 E900 		sts 233,r25
 435:usb_serial.c  **** 		}
 262               		.loc 1 435 0
 263 0012 2BE6      		ldi r18,lo8(107)
 264               	.L27:
 434:usb_serial.c  **** 			UEINTX = 0x6B; 
 265               		.loc 1 434 0
 266 0014 9091 E800 		lds r25,232
 267 0018 95FF      		sbrs r25,5
 268 001a 00C0      		rjmp .L32
 435:usb_serial.c  **** 		}
 269               		.loc 1 435 0
 270 001c 2093 E800 		sts 232,r18
 271 0020 00C0      		rjmp .L27
 272               	.L32:
 437:usb_serial.c  **** 	}
 273               		.loc 1 437 0
 274 0022 8FBF      		out __SREG__,r24
 275               	.LVL15:
 276               	.L25:
 277 0024 0895      		ret
 278               		.cfi_endproc
 279               	.LFE5:
 281               		.section	.text.usb_serial_putchar,"ax",@progbits
 282               	.global	usb_serial_putchar
 284               	usb_serial_putchar:
 285               	.LFB6:
 492:usb_serial.c  **** 	uint8_t timeout, intr_state;
 286               		.loc 1 492 0
 287               		.cfi_startproc
 288               	.LVL16:
 289               	/* prologue: function */
 290               	/* frame size = 0 */
 291               	/* stack size = 0 */
 292               	.L__stack_usage = 0
 496:usb_serial.c  **** 	// interrupts are disabled so these functions can be
 293               		.loc 1 496 0
 294 0000 9091 0000 		lds r25,usb_configuration
 295 0004 9923      		tst r25
 296 0006 01F0      		breq .L49
 500:usb_serial.c  **** 	cli();
 297               		.loc 1 500 0
 298 0008 9FB7      		in r25,__SREG__
 299               	.LVL17:
 501:usb_serial.c  **** 	UENUM = CDC_TX_ENDPOINT;
 300               		.loc 1 501 0
 301               	/* #APP */
 302               	 ;  501 "usb_serial.c" 1
 303 000a F894      		cli
 304               	 ;  0 "" 2
 502:usb_serial.c  **** 	// if we gave up due to timeout before, don't wait again
 305               		.loc 1 502 0
 306               	/* #NOAPP */
 307 000c 24E0      		ldi r18,lo8(4)
 308 000e 2093 E900 		sts 233,r18
 504:usb_serial.c  **** 		if (!(UEINTX & (1<<RWAL))) {
 309               		.loc 1 504 0
 310 0012 2091 0000 		lds r18,transmit_previous_timeout
 311 0016 2223      		tst r18
 312 0018 01F0      		breq .L36
 505:usb_serial.c  **** 			SREG = intr_state;
 313               		.loc 1 505 0
 314 001a 2091 E800 		lds r18,232
 315 001e 25FD      		sbrc r18,5
 316 0020 00C0      		rjmp .L37
 506:usb_serial.c  **** 			return -1;
 317               		.loc 1 506 0
 318 0022 9FBF      		out __SREG__,r25
 319               	.LVL18:
 320               	.L49:
 507:usb_serial.c  **** 		}
 321               		.loc 1 507 0
 322 0024 8FEF      		ldi r24,lo8(-1)
 323 0026 0895      		ret
 324               	.LVL19:
 325               	.L37:
 509:usb_serial.c  **** 	}
 326               		.loc 1 509 0
 327 0028 1092 0000 		sts transmit_previous_timeout,__zero_reg__
 328               	.L36:
 512:usb_serial.c  **** 	while (1) {
 329               		.loc 1 512 0
 330 002c 2091 E400 		lds r18,228
 331 0030 275E      		subi r18,lo8(-(25))
 332               	.LVL20:
 528:usb_serial.c  **** 	}
 333               		.loc 1 528 0
 334 0032 34E0      		ldi r19,lo8(4)
 335               	.L41:
 515:usb_serial.c  **** 		SREG = intr_state;
 336               		.loc 1 515 0
 337 0034 4091 E800 		lds r20,232
 338 0038 45FD      		sbrc r20,5
 339 003a 00C0      		rjmp .L38
 516:usb_serial.c  **** 		// have we waited too long?  This happens if the user
 340               		.loc 1 516 0
 341 003c 9FBF      		out __SREG__,r25
 519:usb_serial.c  **** 			transmit_previous_timeout = 1;
 342               		.loc 1 519 0
 343 003e 9091 E400 		lds r25,228
 344               	.LVL21:
 345 0042 2913      		cpse r18,r25
 346 0044 00C0      		rjmp .L39
 520:usb_serial.c  **** 			return -1;
 347               		.loc 1 520 0
 348 0046 81E0      		ldi r24,lo8(1)
 349               	.LVL22:
 350 0048 8093 0000 		sts transmit_previous_timeout,r24
 351               	.LVL23:
 352 004c 00C0      		rjmp .L49
 353               	.LVL24:
 354               	.L39:
 524:usb_serial.c  **** 		// get ready to try checking again
 355               		.loc 1 524 0
 356 004e 9091 0000 		lds r25,usb_configuration
 357 0052 9923      		tst r25
 358 0054 01F0      		breq .L49
 526:usb_serial.c  **** 		cli();
 359               		.loc 1 526 0
 360 0056 9FB7      		in r25,__SREG__
 361               	.LVL25:
 527:usb_serial.c  **** 		UENUM = CDC_TX_ENDPOINT;
 362               		.loc 1 527 0
 363               	/* #APP */
 364               	 ;  527 "usb_serial.c" 1
 365 0058 F894      		cli
 366               	 ;  0 "" 2
 528:usb_serial.c  **** 	}
 367               		.loc 1 528 0
 368               	/* #NOAPP */
 369 005a 3093 E900 		sts 233,r19
 529:usb_serial.c  **** 	// actually write the byte into the FIFO
 370               		.loc 1 529 0
 371 005e 00C0      		rjmp .L41
 372               	.L38:
 531:usb_serial.c  **** 	// if this completed a packet, transmit it now!
 373               		.loc 1 531 0
 374 0060 8093 F100 		sts 241,r24
 533:usb_serial.c  **** 	transmit_flush_timer = TRANSMIT_FLUSH_TIMEOUT;
 375               		.loc 1 533 0
 376 0064 8091 E800 		lds r24,232
 377               	.LVL26:
 378 0068 85FD      		sbrc r24,5
 379 006a 00C0      		rjmp .L42
 533:usb_serial.c  **** 	transmit_flush_timer = TRANSMIT_FLUSH_TIMEOUT;
 380               		.loc 1 533 0 is_stmt 0 discriminator 1
 381 006c 8AE3      		ldi r24,lo8(58)
 382 006e 8093 E800 		sts 232,r24
 383               	.LVL27:
 384               	.L42:
 534:usb_serial.c  **** 	SREG = intr_state;
 385               		.loc 1 534 0 is_stmt 1
 386 0072 85E0      		ldi r24,lo8(5)
 387 0074 8093 0000 		sts transmit_flush_timer,r24
 535:usb_serial.c  **** 	return 0;
 388               		.loc 1 535 0
 389 0078 9FBF      		out __SREG__,r25
 536:usb_serial.c  **** }
 390               		.loc 1 536 0
 391 007a 80E0      		ldi r24,0
 537:usb_serial.c  **** 
 392               		.loc 1 537 0
 393 007c 0895      		ret
 394               		.cfi_endproc
 395               	.LFE6:
 397               		.section	.text.usb_serial_putchar_nowait,"ax",@progbits
 398               	.global	usb_serial_putchar_nowait
 400               	usb_serial_putchar_nowait:
 401               	.LFB7:
 543:usb_serial.c  **** 	uint8_t intr_state;
 402               		.loc 1 543 0
 403               		.cfi_startproc
 404               	.LVL28:
 405               	/* prologue: function */
 406               	/* frame size = 0 */
 407               	/* stack size = 0 */
 408               	.L__stack_usage = 0
 546:usb_serial.c  **** 	intr_state = SREG;
 409               		.loc 1 546 0
 410 0000 9091 0000 		lds r25,usb_configuration
 411 0004 9923      		tst r25
 412 0006 01F0      		breq .L54
 547:usb_serial.c  **** 	cli();
 413               		.loc 1 547 0
 414 0008 9FB7      		in r25,__SREG__
 415               	.LVL29:
 548:usb_serial.c  **** 	UENUM = CDC_TX_ENDPOINT;
 416               		.loc 1 548 0
 417               	/* #APP */
 418               	 ;  548 "usb_serial.c" 1
 419 000a F894      		cli
 420               	 ;  0 "" 2
 549:usb_serial.c  **** 	if (!(UEINTX & (1<<RWAL))) {
 421               		.loc 1 549 0
 422               	/* #NOAPP */
 423 000c 24E0      		ldi r18,lo8(4)
 424 000e 2093 E900 		sts 233,r18
 550:usb_serial.c  **** 		// buffer is full
 425               		.loc 1 550 0
 426 0012 2091 E800 		lds r18,232
 427 0016 25FD      		sbrc r18,5
 428 0018 00C0      		rjmp .L52
 552:usb_serial.c  **** 		return -1;
 429               		.loc 1 552 0
 430 001a 9FBF      		out __SREG__,r25
 431 001c 00C0      		rjmp .L54
 432               	.L52:
 556:usb_serial.c  **** 		// if this completed a packet, transmit it now!
 433               		.loc 1 556 0
 434 001e 8093 F100 		sts 241,r24
 558:usb_serial.c  **** 	transmit_flush_timer = TRANSMIT_FLUSH_TIMEOUT;
 435               		.loc 1 558 0
 436 0022 8091 E800 		lds r24,232
 437               	.LVL30:
 438 0026 85FD      		sbrc r24,5
 439 0028 00C0      		rjmp .L53
 558:usb_serial.c  **** 	transmit_flush_timer = TRANSMIT_FLUSH_TIMEOUT;
 440               		.loc 1 558 0 is_stmt 0 discriminator 1
 441 002a 8AE3      		ldi r24,lo8(58)
 442 002c 8093 E800 		sts 232,r24
 443               	.LVL31:
 444               	.L53:
 559:usb_serial.c  **** 	SREG = intr_state;
 445               		.loc 1 559 0 is_stmt 1
 446 0030 85E0      		ldi r24,lo8(5)
 447 0032 8093 0000 		sts transmit_flush_timer,r24
 560:usb_serial.c  **** 	return 0;
 448               		.loc 1 560 0
 449 0036 9FBF      		out __SREG__,r25
 561:usb_serial.c  **** }
 450               		.loc 1 561 0
 451 0038 80E0      		ldi r24,0
 452 003a 0895      		ret
 453               	.LVL32:
 454               	.L54:
 546:usb_serial.c  **** 	intr_state = SREG;
 455               		.loc 1 546 0
 456 003c 8FEF      		ldi r24,lo8(-1)
 457               	.LVL33:
 562:usb_serial.c  **** 
 458               		.loc 1 562 0
 459 003e 0895      		ret
 460               		.cfi_endproc
 461               	.LFE7:
 463               		.section	.text.usb_serial_write,"ax",@progbits
 464               	.global	usb_serial_write
 466               	usb_serial_write:
 467               	.LFB8:
 577:usb_serial.c  **** 	uint8_t timeout, intr_state, write_size;
 468               		.loc 1 577 0
 469               		.cfi_startproc
 470               	.LVL34:
 471 0000 0F93      		push r16
 472               	.LCFI0:
 473               		.cfi_def_cfa_offset 3
 474               		.cfi_offset 16, -2
 475 0002 1F93      		push r17
 476               	.LCFI1:
 477               		.cfi_def_cfa_offset 4
 478               		.cfi_offset 17, -3
 479 0004 CF93      		push r28
 480               	.LCFI2:
 481               		.cfi_def_cfa_offset 5
 482               		.cfi_offset 28, -4
 483 0006 DF93      		push r29
 484               	.LCFI3:
 485               		.cfi_def_cfa_offset 6
 486               		.cfi_offset 29, -5
 487               	/* prologue: function */
 488               	/* frame size = 0 */
 489               	/* stack size = 4 */
 490               	.L__stack_usage = 4
 491 0008 DC01      		movw r26,r24
 492 000a CB01      		movw r24,r22
 493               	.LVL35:
 581:usb_serial.c  **** 	// interrupts are disabled so these functions can be
 494               		.loc 1 581 0
 495 000c 2091 0000 		lds r18,usb_configuration
 496 0010 2223      		tst r18
 497 0012 01F0      		breq .L140
 585:usb_serial.c  **** 	cli();
 498               		.loc 1 585 0
 499 0014 2FB7      		in r18,__SREG__
 500               	.LVL36:
 586:usb_serial.c  **** 	UENUM = CDC_TX_ENDPOINT;
 501               		.loc 1 586 0
 502               	/* #APP */
 503               	 ;  586 "usb_serial.c" 1
 504 0016 F894      		cli
 505               	 ;  0 "" 2
 587:usb_serial.c  **** 	// if we gave up due to timeout before, don't wait again
 506               		.loc 1 587 0
 507               	/* #NOAPP */
 508 0018 34E0      		ldi r19,lo8(4)
 509 001a 3093 E900 		sts 233,r19
 589:usb_serial.c  **** 		if (!(UEINTX & (1<<RWAL))) {
 510               		.loc 1 589 0
 511 001e 3091 0000 		lds r19,transmit_previous_timeout
 512 0022 3323      		tst r19
 513 0024 01F0      		breq .L58
 590:usb_serial.c  **** 			SREG = intr_state;
 514               		.loc 1 590 0
 515 0026 3091 E800 		lds r19,232
 516 002a 35FD      		sbrc r19,5
 517 002c 00C0      		rjmp .L59
 591:usb_serial.c  **** 			return -1;
 518               		.loc 1 591 0
 519 002e 2FBF      		out __SREG__,r18
 520               	.LVL37:
 521               	.L140:
 592:usb_serial.c  **** 		}
 522               		.loc 1 592 0
 523 0030 8FEF      		ldi r24,lo8(-1)
 524 0032 00C0      		rjmp .L57
 525               	.LVL38:
 526               	.L59:
 594:usb_serial.c  **** 	}
 527               		.loc 1 594 0
 528 0034 1092 0000 		sts transmit_previous_timeout,__zero_reg__
 529               	.L58:
 615:usb_serial.c  **** 		}
 530               		.loc 1 615 0
 531 0038 C4E0      		ldi r28,lo8(4)
 619:usb_serial.c  **** 		if (write_size > size) write_size = size;
 532               		.loc 1 619 0
 533 003a D0E4      		ldi r29,lo8(64)
 699:usb_serial.c  **** 		transmit_flush_timer = TRANSMIT_FLUSH_TIMEOUT;
 534               		.loc 1 699 0
 535 003c 1AE3      		ldi r17,lo8(58)
 700:usb_serial.c  **** 		SREG = intr_state;
 536               		.loc 1 700 0
 537 003e 05E0      		ldi r16,lo8(5)
 538               	.LVL39:
 539               	.L60:
 597:usb_serial.c  **** 		// wait for the FIFO to be ready to accept data
 540               		.loc 1 597 0
 541 0040 0097      		sbiw r24,0
 542 0042 01F4      		brne .+2
 543 0044 00C0      		rjmp .L141
 599:usb_serial.c  **** 		while (1) {
 544               		.loc 1 599 0
 545 0046 3091 E400 		lds r19,228
 546 004a 375E      		subi r19,lo8(-(25))
 547               	.LVL40:
 548               	.L64:
 602:usb_serial.c  **** 			SREG = intr_state;
 549               		.loc 1 602 0
 550 004c 4091 E800 		lds r20,232
 551 0050 45FD      		sbrc r20,5
 552 0052 00C0      		rjmp .L61
 603:usb_serial.c  **** 			// have we waited too long?  This happens if the user
 553               		.loc 1 603 0
 554 0054 2FBF      		out __SREG__,r18
 606:usb_serial.c  **** 				transmit_previous_timeout = 1;
 555               		.loc 1 606 0
 556 0056 2091 E400 		lds r18,228
 557               	.LVL41:
 558 005a 3213      		cpse r19,r18
 559 005c 00C0      		rjmp .L62
 607:usb_serial.c  **** 				return -1;
 560               		.loc 1 607 0
 561 005e 81E0      		ldi r24,lo8(1)
 562               	.LVL42:
 563 0060 8093 0000 		sts transmit_previous_timeout,r24
 564               	.LVL43:
 565 0064 00C0      		rjmp .L140
 566               	.LVL44:
 567               	.L62:
 611:usb_serial.c  **** 			// get ready to try checking again
 568               		.loc 1 611 0
 569 0066 2091 0000 		lds r18,usb_configuration
 570 006a 2223      		tst r18
 571 006c 01F0      		breq .L140
 613:usb_serial.c  **** 			cli();
 572               		.loc 1 613 0
 573 006e 2FB7      		in r18,__SREG__
 574               	.LVL45:
 614:usb_serial.c  **** 			UENUM = CDC_TX_ENDPOINT;
 575               		.loc 1 614 0
 576               	/* #APP */
 577               	 ;  614 "usb_serial.c" 1
 578 0070 F894      		cli
 579               	 ;  0 "" 2
 615:usb_serial.c  **** 		}
 580               		.loc 1 615 0
 581               	/* #NOAPP */
 582 0072 C093 E900 		sts 233,r28
 616:usb_serial.c  **** 
 583               		.loc 1 616 0
 584 0076 00C0      		rjmp .L64
 585               	.L61:
 619:usb_serial.c  **** 		if (write_size > size) write_size = size;
 586               		.loc 1 619 0
 587 0078 3091 F200 		lds r19,242
 588               	.LVL46:
 589 007c ED2F      		mov r30,r29
 590 007e E31B      		sub r30,r19
 591               	.LVL47:
 620:usb_serial.c  **** 		size -= write_size;
 592               		.loc 1 620 0
 593 0080 4E2F      		mov r20,r30
 594 0082 50E0      		ldi r21,0
 595 0084 8417      		cp r24,r20
 596 0086 9507      		cpc r25,r21
 597 0088 00F4      		brsh .L65
 620:usb_serial.c  **** 		size -= write_size;
 598               		.loc 1 620 0 is_stmt 0 discriminator 1
 599 008a E82F      		mov r30,r24
 600               	.LVL48:
 601               	.L65:
 621:usb_serial.c  **** 
 602               		.loc 1 621 0 is_stmt 1
 603 008c 8E1B      		sub r24,r30
 604 008e 9109      		sbc r25,__zero_reg__
 605               	.LVL49:
 624:usb_serial.c  **** 			#if (CDC_TX_SIZE == 64)
 606               		.loc 1 624 0
 607 0090 4E2F      		mov r20,r30
 608 0092 50E0      		ldi r21,0
 609 0094 4134      		cpi r20,65
 610 0096 5105      		cpc r21,__zero_reg__
 611 0098 00F0      		brlo .+2
 612 009a 00C0      		rjmp .L66
 613 009c FA01      		movw r30,r20
 614               	.LVL50:
 615 009e E050      		subi r30,lo8(-(gs(.L68)))
 616 00a0 F040      		sbci r31,hi8(-(gs(.L68)))
 617 00a2 0C94 0000 		jmp __tablejump2__
 618               	.LVL51:
 619               		.section	.progmem.gcc_sw_table.usb_serial_write,"a",@progbits
 620               		.p2align	1
 621               	.L68:
 622 0000 0000      		.word gs(.L67)
 623 0002 0000      		.word gs(.L66)
 624 0004 0000      		.word gs(.L69)
 625 0006 0000      		.word gs(.L70)
 626 0008 0000      		.word gs(.L71)
 627 000a 0000      		.word gs(.L72)
 628 000c 0000      		.word gs(.L73)
 629 000e 0000      		.word gs(.L74)
 630 0010 0000      		.word gs(.L75)
 631 0012 0000      		.word gs(.L76)
 632 0014 0000      		.word gs(.L77)
 633 0016 0000      		.word gs(.L78)
 634 0018 0000      		.word gs(.L79)
 635 001a 0000      		.word gs(.L80)
 636 001c 0000      		.word gs(.L81)
 637 001e 0000      		.word gs(.L82)
 638 0020 0000      		.word gs(.L83)
 639 0022 0000      		.word gs(.L84)
 640 0024 0000      		.word gs(.L85)
 641 0026 0000      		.word gs(.L86)
 642 0028 0000      		.word gs(.L87)
 643 002a 0000      		.word gs(.L88)
 644 002c 0000      		.word gs(.L89)
 645 002e 0000      		.word gs(.L90)
 646 0030 0000      		.word gs(.L91)
 647 0032 0000      		.word gs(.L92)
 648 0034 0000      		.word gs(.L93)
 649 0036 0000      		.word gs(.L94)
 650 0038 0000      		.word gs(.L95)
 651 003a 0000      		.word gs(.L96)
 652 003c 0000      		.word gs(.L97)
 653 003e 0000      		.word gs(.L98)
 654 0040 0000      		.word gs(.L99)
 655 0042 0000      		.word gs(.L100)
 656 0044 0000      		.word gs(.L101)
 657 0046 0000      		.word gs(.L102)
 658 0048 0000      		.word gs(.L103)
 659 004a 0000      		.word gs(.L104)
 660 004c 0000      		.word gs(.L105)
 661 004e 0000      		.word gs(.L106)
 662 0050 0000      		.word gs(.L107)
 663 0052 0000      		.word gs(.L108)
 664 0054 0000      		.word gs(.L109)
 665 0056 0000      		.word gs(.L110)
 666 0058 0000      		.word gs(.L111)
 667 005a 0000      		.word gs(.L112)
 668 005c 0000      		.word gs(.L113)
 669 005e 0000      		.word gs(.L114)
 670 0060 0000      		.word gs(.L115)
 671 0062 0000      		.word gs(.L116)
 672 0064 0000      		.word gs(.L117)
 673 0066 0000      		.word gs(.L118)
 674 0068 0000      		.word gs(.L119)
 675 006a 0000      		.word gs(.L120)
 676 006c 0000      		.word gs(.L121)
 677 006e 0000      		.word gs(.L122)
 678 0070 0000      		.word gs(.L123)
 679 0072 0000      		.word gs(.L124)
 680 0074 0000      		.word gs(.L125)
 681 0076 0000      		.word gs(.L126)
 682 0078 0000      		.word gs(.L127)
 683 007a 0000      		.word gs(.L128)
 684 007c 0000      		.word gs(.L129)
 685 007e 0000      		.word gs(.L130)
 686 0080 0000      		.word gs(.L131)
 687               		.section	.text.usb_serial_write
 688               	.L131:
 626:usb_serial.c  **** 			case 63: UEDATX = *buffer++;
 689               		.loc 1 626 0
 690 00a6 3C91      		ld r19,X
 691 00a8 3093 F100 		sts 241,r19
 692 00ac 1196      		adiw r26,1
 693               	.LVL52:
 694               	.L130:
 627:usb_serial.c  **** 			case 62: UEDATX = *buffer++;
 695               		.loc 1 627 0
 696 00ae 3C91      		ld r19,X
 697 00b0 3093 F100 		sts 241,r19
 698 00b4 1196      		adiw r26,1
 699               	.LVL53:
 700               	.L129:
 628:usb_serial.c  **** 			case 61: UEDATX = *buffer++;
 701               		.loc 1 628 0
 702 00b6 3C91      		ld r19,X
 703 00b8 3093 F100 		sts 241,r19
 704 00bc 1196      		adiw r26,1
 705               	.LVL54:
 706               	.L128:
 629:usb_serial.c  **** 			case 60: UEDATX = *buffer++;
 707               		.loc 1 629 0
 708 00be 3C91      		ld r19,X
 709 00c0 3093 F100 		sts 241,r19
 710 00c4 1196      		adiw r26,1
 711               	.LVL55:
 712               	.L127:
 630:usb_serial.c  **** 			case 59: UEDATX = *buffer++;
 713               		.loc 1 630 0
 714 00c6 3C91      		ld r19,X
 715 00c8 3093 F100 		sts 241,r19
 716 00cc 1196      		adiw r26,1
 717               	.LVL56:
 718               	.L126:
 631:usb_serial.c  **** 			case 58: UEDATX = *buffer++;
 719               		.loc 1 631 0
 720 00ce 3C91      		ld r19,X
 721 00d0 3093 F100 		sts 241,r19
 722 00d4 1196      		adiw r26,1
 723               	.LVL57:
 724               	.L125:
 632:usb_serial.c  **** 			case 57: UEDATX = *buffer++;
 725               		.loc 1 632 0
 726 00d6 3C91      		ld r19,X
 727 00d8 3093 F100 		sts 241,r19
 728 00dc 1196      		adiw r26,1
 729               	.LVL58:
 730               	.L124:
 633:usb_serial.c  **** 			case 56: UEDATX = *buffer++;
 731               		.loc 1 633 0
 732 00de 3C91      		ld r19,X
 733 00e0 3093 F100 		sts 241,r19
 734 00e4 1196      		adiw r26,1
 735               	.LVL59:
 736               	.L123:
 634:usb_serial.c  **** 			case 55: UEDATX = *buffer++;
 737               		.loc 1 634 0
 738 00e6 3C91      		ld r19,X
 739 00e8 3093 F100 		sts 241,r19
 740 00ec 1196      		adiw r26,1
 741               	.LVL60:
 742               	.L122:
 635:usb_serial.c  **** 			case 54: UEDATX = *buffer++;
 743               		.loc 1 635 0
 744 00ee 3C91      		ld r19,X
 745 00f0 3093 F100 		sts 241,r19
 746 00f4 1196      		adiw r26,1
 747               	.LVL61:
 748               	.L121:
 636:usb_serial.c  **** 			case 53: UEDATX = *buffer++;
 749               		.loc 1 636 0
 750 00f6 3C91      		ld r19,X
 751 00f8 3093 F100 		sts 241,r19
 752 00fc 1196      		adiw r26,1
 753               	.LVL62:
 754               	.L120:
 637:usb_serial.c  **** 			case 52: UEDATX = *buffer++;
 755               		.loc 1 637 0
 756 00fe 3C91      		ld r19,X
 757 0100 3093 F100 		sts 241,r19
 758 0104 1196      		adiw r26,1
 759               	.LVL63:
 760               	.L119:
 638:usb_serial.c  **** 			case 51: UEDATX = *buffer++;
 761               		.loc 1 638 0
 762 0106 3C91      		ld r19,X
 763 0108 3093 F100 		sts 241,r19
 764 010c 1196      		adiw r26,1
 765               	.LVL64:
 766               	.L118:
 639:usb_serial.c  **** 			case 50: UEDATX = *buffer++;
 767               		.loc 1 639 0
 768 010e 3C91      		ld r19,X
 769 0110 3093 F100 		sts 241,r19
 770 0114 1196      		adiw r26,1
 771               	.LVL65:
 772               	.L117:
 640:usb_serial.c  **** 			case 49: UEDATX = *buffer++;
 773               		.loc 1 640 0
 774 0116 3C91      		ld r19,X
 775 0118 3093 F100 		sts 241,r19
 776 011c 1196      		adiw r26,1
 777               	.LVL66:
 778               	.L116:
 641:usb_serial.c  **** 			case 48: UEDATX = *buffer++;
 779               		.loc 1 641 0
 780 011e 3C91      		ld r19,X
 781 0120 3093 F100 		sts 241,r19
 782 0124 1196      		adiw r26,1
 783               	.LVL67:
 784               	.L115:
 642:usb_serial.c  **** 			case 47: UEDATX = *buffer++;
 785               		.loc 1 642 0
 786 0126 3C91      		ld r19,X
 787 0128 3093 F100 		sts 241,r19
 788 012c 1196      		adiw r26,1
 789               	.LVL68:
 790               	.L114:
 643:usb_serial.c  **** 			case 46: UEDATX = *buffer++;
 791               		.loc 1 643 0
 792 012e 3C91      		ld r19,X
 793 0130 3093 F100 		sts 241,r19
 794 0134 1196      		adiw r26,1
 795               	.LVL69:
 796               	.L113:
 644:usb_serial.c  **** 			case 45: UEDATX = *buffer++;
 797               		.loc 1 644 0
 798 0136 3C91      		ld r19,X
 799 0138 3093 F100 		sts 241,r19
 800 013c 1196      		adiw r26,1
 801               	.LVL70:
 802               	.L112:
 645:usb_serial.c  **** 			case 44: UEDATX = *buffer++;
 803               		.loc 1 645 0
 804 013e 3C91      		ld r19,X
 805 0140 3093 F100 		sts 241,r19
 806 0144 1196      		adiw r26,1
 807               	.LVL71:
 808               	.L111:
 646:usb_serial.c  **** 			case 43: UEDATX = *buffer++;
 809               		.loc 1 646 0
 810 0146 3C91      		ld r19,X
 811 0148 3093 F100 		sts 241,r19
 812 014c 1196      		adiw r26,1
 813               	.LVL72:
 814               	.L110:
 647:usb_serial.c  **** 			case 42: UEDATX = *buffer++;
 815               		.loc 1 647 0
 816 014e 3C91      		ld r19,X
 817 0150 3093 F100 		sts 241,r19
 818 0154 1196      		adiw r26,1
 819               	.LVL73:
 820               	.L109:
 648:usb_serial.c  **** 			case 41: UEDATX = *buffer++;
 821               		.loc 1 648 0
 822 0156 3C91      		ld r19,X
 823 0158 3093 F100 		sts 241,r19
 824 015c 1196      		adiw r26,1
 825               	.LVL74:
 826               	.L108:
 649:usb_serial.c  **** 			case 40: UEDATX = *buffer++;
 827               		.loc 1 649 0
 828 015e 3C91      		ld r19,X
 829 0160 3093 F100 		sts 241,r19
 830 0164 1196      		adiw r26,1
 831               	.LVL75:
 832               	.L107:
 650:usb_serial.c  **** 			case 39: UEDATX = *buffer++;
 833               		.loc 1 650 0
 834 0166 3C91      		ld r19,X
 835 0168 3093 F100 		sts 241,r19
 836 016c 1196      		adiw r26,1
 837               	.LVL76:
 838               	.L106:
 651:usb_serial.c  **** 			case 38: UEDATX = *buffer++;
 839               		.loc 1 651 0
 840 016e 3C91      		ld r19,X
 841 0170 3093 F100 		sts 241,r19
 842 0174 1196      		adiw r26,1
 843               	.LVL77:
 844               	.L105:
 652:usb_serial.c  **** 			case 37: UEDATX = *buffer++;
 845               		.loc 1 652 0
 846 0176 3C91      		ld r19,X
 847 0178 3093 F100 		sts 241,r19
 848 017c 1196      		adiw r26,1
 849               	.LVL78:
 850               	.L104:
 653:usb_serial.c  **** 			case 36: UEDATX = *buffer++;
 851               		.loc 1 653 0
 852 017e 3C91      		ld r19,X
 853 0180 3093 F100 		sts 241,r19
 854 0184 1196      		adiw r26,1
 855               	.LVL79:
 856               	.L103:
 654:usb_serial.c  **** 			case 35: UEDATX = *buffer++;
 857               		.loc 1 654 0
 858 0186 3C91      		ld r19,X
 859 0188 3093 F100 		sts 241,r19
 860 018c 1196      		adiw r26,1
 861               	.LVL80:
 862               	.L102:
 655:usb_serial.c  **** 			case 34: UEDATX = *buffer++;
 863               		.loc 1 655 0
 864 018e 3C91      		ld r19,X
 865 0190 3093 F100 		sts 241,r19
 866 0194 1196      		adiw r26,1
 867               	.LVL81:
 868               	.L101:
 656:usb_serial.c  **** 			case 33: UEDATX = *buffer++;
 869               		.loc 1 656 0
 870 0196 3C91      		ld r19,X
 871 0198 3093 F100 		sts 241,r19
 872 019c 1196      		adiw r26,1
 873               	.LVL82:
 874               	.L100:
 657:usb_serial.c  **** 			#endif
 875               		.loc 1 657 0
 876 019e 3C91      		ld r19,X
 877 01a0 3093 F100 		sts 241,r19
 878 01a4 1196      		adiw r26,1
 879               	.LVL83:
 880               	.L99:
 660:usb_serial.c  **** 			case 31: UEDATX = *buffer++;
 881               		.loc 1 660 0
 882 01a6 3C91      		ld r19,X
 883 01a8 3093 F100 		sts 241,r19
 884 01ac 1196      		adiw r26,1
 885               	.LVL84:
 886               	.L98:
 661:usb_serial.c  **** 			case 30: UEDATX = *buffer++;
 887               		.loc 1 661 0
 888 01ae 3C91      		ld r19,X
 889 01b0 3093 F100 		sts 241,r19
 890 01b4 1196      		adiw r26,1
 891               	.LVL85:
 892               	.L97:
 662:usb_serial.c  **** 			case 29: UEDATX = *buffer++;
 893               		.loc 1 662 0
 894 01b6 3C91      		ld r19,X
 895 01b8 3093 F100 		sts 241,r19
 896 01bc 1196      		adiw r26,1
 897               	.LVL86:
 898               	.L96:
 663:usb_serial.c  **** 			case 28: UEDATX = *buffer++;
 899               		.loc 1 663 0
 900 01be 3C91      		ld r19,X
 901 01c0 3093 F100 		sts 241,r19
 902 01c4 1196      		adiw r26,1
 903               	.LVL87:
 904               	.L95:
 664:usb_serial.c  **** 			case 27: UEDATX = *buffer++;
 905               		.loc 1 664 0
 906 01c6 3C91      		ld r19,X
 907 01c8 3093 F100 		sts 241,r19
 908 01cc 1196      		adiw r26,1
 909               	.LVL88:
 910               	.L94:
 665:usb_serial.c  **** 			case 26: UEDATX = *buffer++;
 911               		.loc 1 665 0
 912 01ce 3C91      		ld r19,X
 913 01d0 3093 F100 		sts 241,r19
 914 01d4 1196      		adiw r26,1
 915               	.LVL89:
 916               	.L93:
 666:usb_serial.c  **** 			case 25: UEDATX = *buffer++;
 917               		.loc 1 666 0
 918 01d6 3C91      		ld r19,X
 919 01d8 3093 F100 		sts 241,r19
 920 01dc 1196      		adiw r26,1
 921               	.LVL90:
 922               	.L92:
 667:usb_serial.c  **** 			case 24: UEDATX = *buffer++;
 923               		.loc 1 667 0
 924 01de 3C91      		ld r19,X
 925 01e0 3093 F100 		sts 241,r19
 926 01e4 1196      		adiw r26,1
 927               	.LVL91:
 928               	.L91:
 668:usb_serial.c  **** 			case 23: UEDATX = *buffer++;
 929               		.loc 1 668 0
 930 01e6 3C91      		ld r19,X
 931 01e8 3093 F100 		sts 241,r19
 932 01ec 1196      		adiw r26,1
 933               	.LVL92:
 934               	.L90:
 669:usb_serial.c  **** 			case 22: UEDATX = *buffer++;
 935               		.loc 1 669 0
 936 01ee 3C91      		ld r19,X
 937 01f0 3093 F100 		sts 241,r19
 938 01f4 1196      		adiw r26,1
 939               	.LVL93:
 940               	.L89:
 670:usb_serial.c  **** 			case 21: UEDATX = *buffer++;
 941               		.loc 1 670 0
 942 01f6 3C91      		ld r19,X
 943 01f8 3093 F100 		sts 241,r19
 944 01fc 1196      		adiw r26,1
 945               	.LVL94:
 946               	.L88:
 671:usb_serial.c  **** 			case 20: UEDATX = *buffer++;
 947               		.loc 1 671 0
 948 01fe 3C91      		ld r19,X
 949 0200 3093 F100 		sts 241,r19
 950 0204 1196      		adiw r26,1
 951               	.LVL95:
 952               	.L87:
 672:usb_serial.c  **** 			case 19: UEDATX = *buffer++;
 953               		.loc 1 672 0
 954 0206 3C91      		ld r19,X
 955 0208 3093 F100 		sts 241,r19
 956 020c 1196      		adiw r26,1
 957               	.LVL96:
 958               	.L86:
 673:usb_serial.c  **** 			case 18: UEDATX = *buffer++;
 959               		.loc 1 673 0
 960 020e 3C91      		ld r19,X
 961 0210 3093 F100 		sts 241,r19
 962 0214 1196      		adiw r26,1
 963               	.LVL97:
 964               	.L85:
 674:usb_serial.c  **** 			case 17: UEDATX = *buffer++;
 965               		.loc 1 674 0
 966 0216 3C91      		ld r19,X
 967 0218 3093 F100 		sts 241,r19
 968 021c 1196      		adiw r26,1
 969               	.LVL98:
 970               	.L84:
 675:usb_serial.c  **** 			#endif
 971               		.loc 1 675 0
 972 021e 3C91      		ld r19,X
 973 0220 3093 F100 		sts 241,r19
 974 0224 1196      		adiw r26,1
 975               	.LVL99:
 976               	.L83:
 678:usb_serial.c  **** 			case 15: UEDATX = *buffer++;
 977               		.loc 1 678 0
 978 0226 3C91      		ld r19,X
 979 0228 3093 F100 		sts 241,r19
 980 022c 1196      		adiw r26,1
 981               	.LVL100:
 982               	.L82:
 679:usb_serial.c  **** 			case 14: UEDATX = *buffer++;
 983               		.loc 1 679 0
 984 022e 3C91      		ld r19,X
 985 0230 3093 F100 		sts 241,r19
 986 0234 1196      		adiw r26,1
 987               	.LVL101:
 988               	.L81:
 680:usb_serial.c  **** 			case 13: UEDATX = *buffer++;
 989               		.loc 1 680 0
 990 0236 3C91      		ld r19,X
 991 0238 3093 F100 		sts 241,r19
 992 023c 1196      		adiw r26,1
 993               	.LVL102:
 994               	.L80:
 681:usb_serial.c  **** 			case 12: UEDATX = *buffer++;
 995               		.loc 1 681 0
 996 023e 3C91      		ld r19,X
 997 0240 3093 F100 		sts 241,r19
 998 0244 1196      		adiw r26,1
 999               	.LVL103:
 1000               	.L79:
 682:usb_serial.c  **** 			case 11: UEDATX = *buffer++;
 1001               		.loc 1 682 0
 1002 0246 3C91      		ld r19,X
 1003 0248 3093 F100 		sts 241,r19
 1004 024c 1196      		adiw r26,1
 1005               	.LVL104:
 1006               	.L78:
 683:usb_serial.c  **** 			case 10: UEDATX = *buffer++;
 1007               		.loc 1 683 0
 1008 024e 3C91      		ld r19,X
 1009 0250 3093 F100 		sts 241,r19
 1010 0254 1196      		adiw r26,1
 1011               	.LVL105:
 1012               	.L77:
 684:usb_serial.c  **** 			case  9: UEDATX = *buffer++;
 1013               		.loc 1 684 0
 1014 0256 3C91      		ld r19,X
 1015 0258 3093 F100 		sts 241,r19
 1016 025c 1196      		adiw r26,1
 1017               	.LVL106:
 1018               	.L76:
 685:usb_serial.c  **** 			#endif
 1019               		.loc 1 685 0
 1020 025e 3C91      		ld r19,X
 1021 0260 3093 F100 		sts 241,r19
 1022 0264 1196      		adiw r26,1
 1023               	.LVL107:
 1024               	.L75:
 687:usb_serial.c  **** 			case  7: UEDATX = *buffer++;
 1025               		.loc 1 687 0
 1026 0266 3C91      		ld r19,X
 1027 0268 3093 F100 		sts 241,r19
 1028 026c 1196      		adiw r26,1
 1029               	.LVL108:
 1030               	.L74:
 688:usb_serial.c  **** 			case  6: UEDATX = *buffer++;
 1031               		.loc 1 688 0
 1032 026e 3C91      		ld r19,X
 1033 0270 3093 F100 		sts 241,r19
 1034 0274 1196      		adiw r26,1
 1035               	.LVL109:
 1036               	.L73:
 689:usb_serial.c  **** 			case  5: UEDATX = *buffer++;
 1037               		.loc 1 689 0
 1038 0276 3C91      		ld r19,X
 1039 0278 3093 F100 		sts 241,r19
 1040 027c 1196      		adiw r26,1
 1041               	.LVL110:
 1042               	.L72:
 690:usb_serial.c  **** 			case  4: UEDATX = *buffer++;
 1043               		.loc 1 690 0
 1044 027e 3C91      		ld r19,X
 1045 0280 3093 F100 		sts 241,r19
 1046 0284 1196      		adiw r26,1
 1047               	.LVL111:
 1048               	.L71:
 691:usb_serial.c  **** 			case  3: UEDATX = *buffer++;
 1049               		.loc 1 691 0
 1050 0286 3C91      		ld r19,X
 1051 0288 3093 F100 		sts 241,r19
 1052 028c 1196      		adiw r26,1
 1053               	.LVL112:
 1054               	.L70:
 692:usb_serial.c  **** 			case  2: UEDATX = *buffer++;
 1055               		.loc 1 692 0
 1056 028e 3C91      		ld r19,X
 1057 0290 3093 F100 		sts 241,r19
 1058 0294 1196      		adiw r26,1
 1059               	.LVL113:
 1060               	.L69:
 693:usb_serial.c  **** 			default:
 1061               		.loc 1 693 0
 1062 0296 3C91      		ld r19,X
 1063 0298 3093 F100 		sts 241,r19
 1064 029c 1196      		adiw r26,1
 1065               	.LVL114:
 1066               	.L66:
 695:usb_serial.c  **** 			case  0: break;
 1067               		.loc 1 695 0
 1068 029e 3C91      		ld r19,X
 1069 02a0 3093 F100 		sts 241,r19
 1070 02a4 1196      		adiw r26,1
 1071               	.LVL115:
 1072               	.L67:
 699:usb_serial.c  **** 		transmit_flush_timer = TRANSMIT_FLUSH_TIMEOUT;
 1073               		.loc 1 699 0
 1074 02a6 3091 E800 		lds r19,232
 1075 02aa 35FF      		sbrs r19,5
 699:usb_serial.c  **** 		transmit_flush_timer = TRANSMIT_FLUSH_TIMEOUT;
 1076               		.loc 1 699 0 is_stmt 0 discriminator 1
 1077 02ac 1093 E800 		sts 232,r17
 1078               	.L132:
 700:usb_serial.c  **** 		SREG = intr_state;
 1079               		.loc 1 700 0 is_stmt 1
 1080 02b0 0093 0000 		sts transmit_flush_timer,r16
 701:usb_serial.c  **** 	}
 1081               		.loc 1 701 0
 1082 02b4 2FBF      		out __SREG__,r18
 1083 02b6 00C0      		rjmp .L60
 1084               	.L141:
 703:usb_serial.c  **** }
 1085               		.loc 1 703 0
 1086 02b8 80E0      		ldi r24,0
 1087               	.LVL116:
 1088               	.L57:
 1089               	/* epilogue start */
 704:usb_serial.c  **** 
 1090               		.loc 1 704 0
 1091 02ba DF91      		pop r29
 1092 02bc CF91      		pop r28
 1093 02be 1F91      		pop r17
 1094 02c0 0F91      		pop r16
 1095 02c2 0895      		ret
 1096               		.cfi_endproc
 1097               	.LFE8:
 1099               		.section	.text.usb_serial_flush_output,"ax",@progbits
 1100               	.global	usb_serial_flush_output
 1102               	usb_serial_flush_output:
 1103               	.LFB9:
 712:usb_serial.c  **** 	uint8_t intr_state;
 1104               		.loc 1 712 0
 1105               		.cfi_startproc
 1106               	/* prologue: function */
 1107               	/* frame size = 0 */
 1108               	/* stack size = 0 */
 1109               	.L__stack_usage = 0
 715:usb_serial.c  **** 	cli();
 1110               		.loc 1 715 0
 1111 0000 8FB7      		in r24,__SREG__
 1112               	.LVL117:
 716:usb_serial.c  **** 	if (transmit_flush_timer) {
 1113               		.loc 1 716 0
 1114               	/* #APP */
 1115               	 ;  716 "usb_serial.c" 1
 1116 0002 F894      		cli
 1117               	 ;  0 "" 2
 717:usb_serial.c  **** 		UENUM = CDC_TX_ENDPOINT;
 1118               		.loc 1 717 0
 1119               	/* #NOAPP */
 1120 0004 9091 0000 		lds r25,transmit_flush_timer
 1121 0008 9923      		tst r25
 1122 000a 01F0      		breq .L143
 718:usb_serial.c  **** 		UEINTX = 0x3A;
 1123               		.loc 1 718 0
 1124 000c 94E0      		ldi r25,lo8(4)
 1125 000e 9093 E900 		sts 233,r25
 719:usb_serial.c  **** 		transmit_flush_timer = 0;
 1126               		.loc 1 719 0
 1127 0012 9AE3      		ldi r25,lo8(58)
 1128 0014 9093 E800 		sts 232,r25
 720:usb_serial.c  **** 	}
 1129               		.loc 1 720 0
 1130 0018 1092 0000 		sts transmit_flush_timer,__zero_reg__
 1131               	.L143:
 722:usb_serial.c  **** }
 1132               		.loc 1 722 0
 1133 001c 8FBF      		out __SREG__,r24
 1134 001e 0895      		ret
 1135               		.cfi_endproc
 1136               	.LFE9:
 1138               		.section	.text.usb_serial_get_baud,"ax",@progbits
 1139               	.global	usb_serial_get_baud
 1141               	usb_serial_get_baud:
 1142               	.LFB10:
 731:usb_serial.c  **** 	return *(uint32_t *)cdc_line_coding;
 1143               		.loc 1 731 0
 1144               		.cfi_startproc
 1145               	/* prologue: function */
 1146               	/* frame size = 0 */
 1147               	/* stack size = 0 */
 1148               	.L__stack_usage = 0
 732:usb_serial.c  **** }
 1149               		.loc 1 732 0
 1150 0000 6091 0000 		lds r22,cdc_line_coding
 1151 0004 7091 0000 		lds r23,cdc_line_coding+1
 1152 0008 8091 0000 		lds r24,cdc_line_coding+2
 1153 000c 9091 0000 		lds r25,cdc_line_coding+3
 733:usb_serial.c  **** uint8_t usb_serial_get_stopbits(void)
 1154               		.loc 1 733 0
 1155 0010 0895      		ret
 1156               		.cfi_endproc
 1157               	.LFE10:
 1159               		.section	.text.usb_serial_get_stopbits,"ax",@progbits
 1160               	.global	usb_serial_get_stopbits
 1162               	usb_serial_get_stopbits:
 1163               	.LFB11:
 735:usb_serial.c  **** 	return cdc_line_coding[4];
 1164               		.loc 1 735 0
 1165               		.cfi_startproc
 1166               	/* prologue: function */
 1167               	/* frame size = 0 */
 1168               	/* stack size = 0 */
 1169               	.L__stack_usage = 0
 737:usb_serial.c  **** uint8_t usb_serial_get_paritytype(void)
 1170               		.loc 1 737 0
 1171 0000 8091 0000 		lds r24,cdc_line_coding+4
 1172 0004 0895      		ret
 1173               		.cfi_endproc
 1174               	.LFE11:
 1176               		.section	.text.usb_serial_get_paritytype,"ax",@progbits
 1177               	.global	usb_serial_get_paritytype
 1179               	usb_serial_get_paritytype:
 1180               	.LFB12:
 739:usb_serial.c  **** 	return cdc_line_coding[5];
 1181               		.loc 1 739 0
 1182               		.cfi_startproc
 1183               	/* prologue: function */
 1184               	/* frame size = 0 */
 1185               	/* stack size = 0 */
 1186               	.L__stack_usage = 0
 741:usb_serial.c  **** uint8_t usb_serial_get_numbits(void)
 1187               		.loc 1 741 0
 1188 0000 8091 0000 		lds r24,cdc_line_coding+5
 1189 0004 0895      		ret
 1190               		.cfi_endproc
 1191               	.LFE12:
 1193               		.section	.text.usb_serial_get_numbits,"ax",@progbits
 1194               	.global	usb_serial_get_numbits
 1196               	usb_serial_get_numbits:
 1197               	.LFB13:
 743:usb_serial.c  **** 	return cdc_line_coding[6];
 1198               		.loc 1 743 0
 1199               		.cfi_startproc
 1200               	/* prologue: function */
 1201               	/* frame size = 0 */
 1202               	/* stack size = 0 */
 1203               	.L__stack_usage = 0
 745:usb_serial.c  **** uint8_t usb_serial_get_control(void)
 1204               		.loc 1 745 0
 1205 0000 8091 0000 		lds r24,cdc_line_coding+6
 1206 0004 0895      		ret
 1207               		.cfi_endproc
 1208               	.LFE13:
 1210               		.section	.text.usb_serial_get_control,"ax",@progbits
 1211               	.global	usb_serial_get_control
 1213               	usb_serial_get_control:
 1214               	.LFB14:
 747:usb_serial.c  **** 	return cdc_line_rtsdtr;
 1215               		.loc 1 747 0
 1216               		.cfi_startproc
 1217               	/* prologue: function */
 1218               	/* frame size = 0 */
 1219               	/* stack size = 0 */
 1220               	.L__stack_usage = 0
 749:usb_serial.c  **** // write the control signals, DCD, DSR, RI, etc
 1221               		.loc 1 749 0
 1222 0000 8091 0000 		lds r24,cdc_line_rtsdtr
 1223 0004 0895      		ret
 1224               		.cfi_endproc
 1225               	.LFE14:
 1227               		.section	.text.usb_serial_set_control,"ax",@progbits
 1228               	.global	usb_serial_set_control
 1230               	usb_serial_set_control:
 1231               	.LFB15:
 757:usb_serial.c  **** 	uint8_t intr_state;
 1232               		.loc 1 757 0
 1233               		.cfi_startproc
 1234               	.LVL118:
 1235               	/* prologue: function */
 1236               	/* frame size = 0 */
 1237               	/* stack size = 0 */
 1238               	.L__stack_usage = 0
 760:usb_serial.c  **** 	cli();
 1239               		.loc 1 760 0
 1240 0000 9FB7      		in r25,__SREG__
 1241               	.LVL119:
 761:usb_serial.c  **** 	if (!usb_configuration) {
 1242               		.loc 1 761 0
 1243               	/* #APP */
 1244               	 ;  761 "usb_serial.c" 1
 1245 0002 F894      		cli
 1246               	 ;  0 "" 2
 762:usb_serial.c  **** 		// we're not enumerated/configured
 1247               		.loc 1 762 0
 1248               	/* #NOAPP */
 1249 0004 2091 0000 		lds r18,usb_configuration
 1250 0008 2223      		tst r18
 1251 000a 01F0      		breq .L156
 768:usb_serial.c  **** 	if (!(UEINTX & (1<<RWAL))) {
 1252               		.loc 1 768 0
 1253 000c 22E0      		ldi r18,lo8(2)
 1254 000e 2093 E900 		sts 233,r18
 769:usb_serial.c  **** 		// unable to write
 1255               		.loc 1 769 0
 1256 0012 2091 E800 		lds r18,232
 1257 0016 25FD      		sbrc r18,5
 1258 0018 00C0      		rjmp .L155
 1259               	.L156:
 773:usb_serial.c  **** 		return -1;
 1260               		.loc 1 773 0
 1261 001a 9FBF      		out __SREG__,r25
 774:usb_serial.c  **** 	}
 1262               		.loc 1 774 0
 1263 001c 8FEF      		ldi r24,lo8(-1)
 1264               	.LVL120:
 1265 001e 0895      		ret
 1266               	.LVL121:
 1267               	.L155:
 776:usb_serial.c  **** 	UEDATX = 0x20;
 1268               		.loc 1 776 0
 1269 0020 21EA      		ldi r18,lo8(-95)
 1270 0022 2093 F100 		sts 241,r18
 777:usb_serial.c  **** 	UEDATX = 0;
 1271               		.loc 1 777 0
 1272 0026 20E2      		ldi r18,lo8(32)
 1273 0028 2093 F100 		sts 241,r18
 778:usb_serial.c  **** 	UEDATX = 0;
 1274               		.loc 1 778 0
 1275 002c 1092 F100 		sts 241,__zero_reg__
 779:usb_serial.c  **** 	UEDATX = 0; // 0 seems to work nicely.  what if this is 1??
 1276               		.loc 1 779 0
 1277 0030 1092 F100 		sts 241,__zero_reg__
 780:usb_serial.c  **** 	UEDATX = 0;
 1278               		.loc 1 780 0
 1279 0034 1092 F100 		sts 241,__zero_reg__
 781:usb_serial.c  **** 	UEDATX = 1;
 1280               		.loc 1 781 0
 1281 0038 1092 F100 		sts 241,__zero_reg__
 782:usb_serial.c  **** 	UEDATX = 0;
 1282               		.loc 1 782 0
 1283 003c 21E0      		ldi r18,lo8(1)
 1284 003e 2093 F100 		sts 241,r18
 783:usb_serial.c  **** 	UEDATX = signals;
 1285               		.loc 1 783 0
 1286 0042 1092 F100 		sts 241,__zero_reg__
 784:usb_serial.c  **** 	UEINTX = 0x3A;
 1287               		.loc 1 784 0
 1288 0046 8093 F100 		sts 241,r24
 785:usb_serial.c  **** 	SREG = intr_state;
 1289               		.loc 1 785 0
 1290 004a 8AE3      		ldi r24,lo8(58)
 1291               	.LVL122:
 1292 004c 8093 E800 		sts 232,r24
 1293               	.LVL123:
 786:usb_serial.c  **** 	return 0;
 1294               		.loc 1 786 0
 1295 0050 9FBF      		out __SREG__,r25
 787:usb_serial.c  **** }
 1296               		.loc 1 787 0
 1297 0052 80E0      		ldi r24,0
 788:usb_serial.c  **** 
 1298               		.loc 1 788 0
 1299 0054 0895      		ret
 1300               		.cfi_endproc
 1301               	.LFE15:
 1303               		.section	.text.__vector_10,"ax",@progbits
 1304               	.global	__vector_10
 1306               	__vector_10:
 1307               	.LFB16:
 803:usb_serial.c  **** 	uint8_t intbits, t;
 1308               		.loc 1 803 0
 1309               		.cfi_startproc
 1310 0000 1F92      		push r1
 1311               	.LCFI4:
 1312               		.cfi_def_cfa_offset 3
 1313               		.cfi_offset 1, -2
 1314 0002 0F92      		push r0
 1315               	.LCFI5:
 1316               		.cfi_def_cfa_offset 4
 1317               		.cfi_offset 0, -3
 1318 0004 0FB6      		in r0,__SREG__
 1319 0006 0F92      		push r0
 1320 0008 1124      		clr __zero_reg__
 1321 000a 8F93      		push r24
 1322               	.LCFI6:
 1323               		.cfi_def_cfa_offset 5
 1324               		.cfi_offset 24, -4
 1325 000c 9F93      		push r25
 1326               	.LCFI7:
 1327               		.cfi_def_cfa_offset 6
 1328               		.cfi_offset 25, -5
 1329               	/* prologue: Signal */
 1330               	/* frame size = 0 */
 1331               	/* stack size = 5 */
 1332               	.L__stack_usage = 5
 806:usb_serial.c  ****         UDINT = 0;
 1333               		.loc 1 806 0
 1334 000e 8091 E100 		lds r24,225
 1335               	.LVL124:
 807:usb_serial.c  ****         if (intbits & (1<<EORSTI)) {
 1336               		.loc 1 807 0
 1337 0012 1092 E100 		sts 225,__zero_reg__
 808:usb_serial.c  **** 		UENUM = 0;
 1338               		.loc 1 808 0
 1339 0016 83FF      		sbrs r24,3
 1340 0018 00C0      		rjmp .L158
 809:usb_serial.c  **** 		UECONX = 1;
 1341               		.loc 1 809 0
 1342 001a 1092 E900 		sts 233,__zero_reg__
 810:usb_serial.c  **** 		UECFG0X = EP_TYPE_CONTROL;
 1343               		.loc 1 810 0
 1344 001e 91E0      		ldi r25,lo8(1)
 1345 0020 9093 EB00 		sts 235,r25
 811:usb_serial.c  **** 		UECFG1X = EP_SIZE(ENDPOINT0_SIZE) | EP_SINGLE_BUFFER;
 1346               		.loc 1 811 0
 1347 0024 1092 EC00 		sts 236,__zero_reg__
 812:usb_serial.c  **** 		UEIENX = (1<<RXSTPE);
 1348               		.loc 1 812 0
 1349 0028 92E1      		ldi r25,lo8(18)
 1350 002a 9093 ED00 		sts 237,r25
 813:usb_serial.c  **** 		usb_configuration = 0;
 1351               		.loc 1 813 0
 1352 002e 98E0      		ldi r25,lo8(8)
 1353 0030 9093 F000 		sts 240,r25
 814:usb_serial.c  **** 		cdc_line_rtsdtr = 0;
 1354               		.loc 1 814 0
 1355 0034 1092 0000 		sts usb_configuration,__zero_reg__
 815:usb_serial.c  ****         }
 1356               		.loc 1 815 0
 1357 0038 1092 0000 		sts cdc_line_rtsdtr,__zero_reg__
 1358               	.L158:
 817:usb_serial.c  **** 		if (usb_configuration) {
 1359               		.loc 1 817 0
 1360 003c 82FF      		sbrs r24,2
 1361 003e 00C0      		rjmp .L157
 818:usb_serial.c  **** 			t = transmit_flush_timer;
 1362               		.loc 1 818 0
 1363 0040 8091 0000 		lds r24,usb_configuration
 1364               	.LVL125:
 1365 0044 8823      		tst r24
 1366 0046 01F0      		breq .L157
 819:usb_serial.c  **** 			if (t) {
 1367               		.loc 1 819 0
 1368 0048 8091 0000 		lds r24,transmit_flush_timer
 1369               	.LVL126:
 820:usb_serial.c  **** 				transmit_flush_timer = --t;
 1370               		.loc 1 820 0
 1371 004c 8823      		tst r24
 1372 004e 01F0      		breq .L157
 821:usb_serial.c  **** 				if (!t) {
 1373               		.loc 1 821 0
 1374 0050 8150      		subi r24,lo8(-(-1))
 1375               	.LVL127:
 1376 0052 8093 0000 		sts transmit_flush_timer,r24
 822:usb_serial.c  **** 					UENUM = CDC_TX_ENDPOINT;
 1377               		.loc 1 822 0
 1378 0056 8111      		cpse r24,__zero_reg__
 1379 0058 00C0      		rjmp .L157
 823:usb_serial.c  **** 					UEINTX = 0x3A;
 1380               		.loc 1 823 0
 1381 005a 84E0      		ldi r24,lo8(4)
 1382               	.LVL128:
 1383 005c 8093 E900 		sts 233,r24
 1384               	.LVL129:
 824:usb_serial.c  **** 				}
 1385               		.loc 1 824 0
 1386 0060 8AE3      		ldi r24,lo8(58)
 1387 0062 8093 E800 		sts 232,r24
 1388               	.L157:
 1389               	/* epilogue start */
 829:usb_serial.c  **** 
 1390               		.loc 1 829 0
 1391 0066 9F91      		pop r25
 1392 0068 8F91      		pop r24
 1393 006a 0F90      		pop r0
 1394 006c 0FBE      		out __SREG__,r0
 1395 006e 0F90      		pop r0
 1396 0070 1F90      		pop r1
 1397 0072 1895      		reti
 1398               		.cfi_endproc
 1399               	.LFE16:
 1401               		.section	.text.__vector_11,"ax",@progbits
 1402               	.global	__vector_11
 1404               	__vector_11:
 1405               	.LFB21:
 837:usb_serial.c  **** static inline void usb_send_in(void)
 838:usb_serial.c  **** {
 839:usb_serial.c  **** 	UEINTX = ~(1<<TXINI);
 840:usb_serial.c  **** }
 841:usb_serial.c  **** static inline void usb_wait_receive_out(void)
 842:usb_serial.c  **** {
 843:usb_serial.c  **** 	while (!(UEINTX & (1<<RXOUTI))) ;
 844:usb_serial.c  **** }
 845:usb_serial.c  **** static inline void usb_ack_out(void)
 846:usb_serial.c  **** {
 847:usb_serial.c  **** 	UEINTX = ~(1<<RXOUTI);
 848:usb_serial.c  **** }
 849:usb_serial.c  **** 
 850:usb_serial.c  **** 
 851:usb_serial.c  **** 
 852:usb_serial.c  **** // USB Endpoint Interrupt - endpoint 0 is handled here.  The
 853:usb_serial.c  **** // other endpoints are manipulated by the user-callable
 854:usb_serial.c  **** // functions, and the start-of-frame interrupt.
 855:usb_serial.c  **** //
 856:usb_serial.c  **** ISR(USB_COM_vect)
 857:usb_serial.c  **** {
 1406               		.loc 1 857 0
 1407               		.cfi_startproc
 1408 0000 1F92      		push r1
 1409               	.LCFI8:
 1410               		.cfi_def_cfa_offset 3
 1411               		.cfi_offset 1, -2
 1412 0002 0F92      		push r0
 1413               	.LCFI9:
 1414               		.cfi_def_cfa_offset 4
 1415               		.cfi_offset 0, -3
 1416 0004 0FB6      		in r0,__SREG__
 1417 0006 0F92      		push r0
 1418 0008 1124      		clr __zero_reg__
 1419 000a 0BB6      		in r0,__RAMPZ__
 1420 000c 0F92      		push r0
 1421 000e FF92      		push r15
 1422               	.LCFI10:
 1423               		.cfi_def_cfa_offset 5
 1424               		.cfi_offset 15, -4
 1425 0010 0F93      		push r16
 1426               	.LCFI11:
 1427               		.cfi_def_cfa_offset 6
 1428               		.cfi_offset 16, -5
 1429 0012 1F93      		push r17
 1430               	.LCFI12:
 1431               		.cfi_def_cfa_offset 7
 1432               		.cfi_offset 17, -6
 1433 0014 2F93      		push r18
 1434               	.LCFI13:
 1435               		.cfi_def_cfa_offset 8
 1436               		.cfi_offset 18, -7
 1437 0016 3F93      		push r19
 1438               	.LCFI14:
 1439               		.cfi_def_cfa_offset 9
 1440               		.cfi_offset 19, -8
 1441 0018 4F93      		push r20
 1442               	.LCFI15:
 1443               		.cfi_def_cfa_offset 10
 1444               		.cfi_offset 20, -9
 1445 001a 5F93      		push r21
 1446               	.LCFI16:
 1447               		.cfi_def_cfa_offset 11
 1448               		.cfi_offset 21, -10
 1449 001c 6F93      		push r22
 1450               	.LCFI17:
 1451               		.cfi_def_cfa_offset 12
 1452               		.cfi_offset 22, -11
 1453 001e 7F93      		push r23
 1454               	.LCFI18:
 1455               		.cfi_def_cfa_offset 13
 1456               		.cfi_offset 23, -12
 1457 0020 8F93      		push r24
 1458               	.LCFI19:
 1459               		.cfi_def_cfa_offset 14
 1460               		.cfi_offset 24, -13
 1461 0022 9F93      		push r25
 1462               	.LCFI20:
 1463               		.cfi_def_cfa_offset 15
 1464               		.cfi_offset 25, -14
 1465 0024 AF93      		push r26
 1466               	.LCFI21:
 1467               		.cfi_def_cfa_offset 16
 1468               		.cfi_offset 26, -15
 1469 0026 BF93      		push r27
 1470               	.LCFI22:
 1471               		.cfi_def_cfa_offset 17
 1472               		.cfi_offset 27, -16
 1473 0028 CF93      		push r28
 1474               	.LCFI23:
 1475               		.cfi_def_cfa_offset 18
 1476               		.cfi_offset 28, -17
 1477 002a DF93      		push r29
 1478               	.LCFI24:
 1479               		.cfi_def_cfa_offset 19
 1480               		.cfi_offset 29, -18
 1481 002c EF93      		push r30
 1482               	.LCFI25:
 1483               		.cfi_def_cfa_offset 20
 1484               		.cfi_offset 30, -19
 1485 002e FF93      		push r31
 1486               	.LCFI26:
 1487               		.cfi_def_cfa_offset 21
 1488               		.cfi_offset 31, -20
 1489               	/* prologue: Signal */
 1490               	/* frame size = 0 */
 1491               	/* stack size = 21 */
 1492               	.L__stack_usage = 21
 858:usb_serial.c  ****         uint8_t intbits;
 859:usb_serial.c  **** 	const uint8_t *list;
 860:usb_serial.c  ****         const uint8_t *cfg;
 861:usb_serial.c  **** 	uint8_t i, n, len, en;
 862:usb_serial.c  **** 	uint8_t *p;
 863:usb_serial.c  **** 	uint8_t bmRequestType;
 864:usb_serial.c  **** 	uint8_t bRequest;
 865:usb_serial.c  **** 	uint16_t wValue;
 866:usb_serial.c  **** 	uint16_t wIndex;
 867:usb_serial.c  **** 	uint16_t wLength;
 868:usb_serial.c  **** 	uint16_t desc_val;
 869:usb_serial.c  **** 	const uint8_t *desc_addr;
 870:usb_serial.c  **** 	uint8_t	desc_length;
 871:usb_serial.c  **** 
 872:usb_serial.c  ****         UENUM = 0;
 1493               		.loc 1 872 0
 1494 0030 1092 E900 		sts 233,__zero_reg__
 873:usb_serial.c  ****         intbits = UEINTX;
 1495               		.loc 1 873 0
 1496 0034 8091 E800 		lds r24,232
 1497               	.LVL130:
 874:usb_serial.c  ****         if (intbits & (1<<RXSTPI)) {
 1498               		.loc 1 874 0
 1499 0038 83FF      		sbrs r24,3
 1500 003a 00C0      		rjmp .L172
 875:usb_serial.c  ****                 bmRequestType = UEDATX;
 1501               		.loc 1 875 0
 1502 003c F090 F100 		lds r15,241
 1503               	.LVL131:
 876:usb_serial.c  ****                 bRequest = UEDATX;
 1504               		.loc 1 876 0
 1505 0040 8091 F100 		lds r24,241
 1506               	.LVL132:
 877:usb_serial.c  ****                 wValue = UEDATX;
 1507               		.loc 1 877 0
 1508 0044 0091 F100 		lds r16,241
 1509               	.LVL133:
 878:usb_serial.c  ****                 wValue |= (UEDATX << 8);
 1510               		.loc 1 878 0
 1511 0048 9091 F100 		lds r25,241
 1512 004c 10E0      		ldi r17,0
 1513 004e 192B      		or r17,r25
 1514               	.LVL134:
 879:usb_serial.c  ****                 wIndex = UEDATX;
 1515               		.loc 1 879 0
 1516 0050 C091 F100 		lds r28,241
 1517               	.LVL135:
 880:usb_serial.c  ****                 wIndex |= (UEDATX << 8);
 1518               		.loc 1 880 0
 1519 0054 9091 F100 		lds r25,241
 1520 0058 D0E0      		ldi r29,0
 1521 005a D92B      		or r29,r25
 1522               	.LVL136:
 881:usb_serial.c  ****                 wLength = UEDATX;
 1523               		.loc 1 881 0
 1524 005c 2091 F100 		lds r18,241
 1525               	.LVL137:
 882:usb_serial.c  ****                 wLength |= (UEDATX << 8);
 1526               		.loc 1 882 0
 1527 0060 6091 F100 		lds r22,241
 1528               	.LVL138:
 883:usb_serial.c  ****                 UEINTX = ~((1<<RXSTPI) | (1<<RXOUTI) | (1<<TXINI));
 1529               		.loc 1 883 0
 1530 0064 92EF      		ldi r25,lo8(-14)
 1531 0066 9093 E800 		sts 232,r25
 884:usb_serial.c  ****                 if (bRequest == GET_DESCRIPTOR) {
 1532               		.loc 1 884 0
 1533 006a 8630      		cpi r24,lo8(6)
 1534 006c 01F0      		breq .+2
 1535 006e 00C0      		rjmp .L220
 1536 0070 80E0      		ldi r24,lo8(descriptor_list)
 1537 0072 90E0      		ldi r25,hi8(descriptor_list)
 1538               	.LVL139:
 1539 0074 40E0      		ldi r20,lo8(descriptor_list+42)
 1540 0076 50E0      		ldi r21,hi8(descriptor_list+42)
 1541               	.L181:
 1542               	.LVL140:
 1543               	.LBB60:
 885:usb_serial.c  **** 			list = (const uint8_t *)descriptor_list;
 886:usb_serial.c  **** 			for (i=0; ; i++) {
 887:usb_serial.c  **** 				if (i >= NUM_DESC_LIST) {
 888:usb_serial.c  **** 					UECONX = (1<<STALLRQ)|(1<<EPEN);  //stall
 889:usb_serial.c  **** 					return;
 890:usb_serial.c  **** 				}
 891:usb_serial.c  **** 				desc_val = pgm_read_word(list);
 1544               		.loc 1 891 0
 1545 0078 FC01      		movw r30,r24
 1546               	/* #APP */
 1547               	 ;  891 "usb_serial.c" 1
 1548 007a A591      		lpm r26, Z+
 1549 007c B491      		lpm r27, Z
 1550               		
 1551               	 ;  0 "" 2
 1552               	.LVL141:
 1553               	/* #NOAPP */
 1554               	.LBE60:
 892:usb_serial.c  **** 				if (desc_val != wValue) {
 1555               		.loc 1 892 0
 1556 007e 0A17      		cp r16,r26
 1557 0080 1B07      		cpc r17,r27
 1558 0082 01F4      		brne .L176
 1559               	.LVL142:
 1560               	.LBB61:
 893:usb_serial.c  **** 					list += sizeof(struct descriptor_list_struct);
 894:usb_serial.c  **** 					continue;
 895:usb_serial.c  **** 				}
 896:usb_serial.c  **** 				list += 2;
 897:usb_serial.c  **** 				desc_val = pgm_read_word(list);
 1561               		.loc 1 897 0
 1562 0084 FC01      		movw r30,r24
 1563 0086 3296      		adiw r30,2
 1564               	.LVL143:
 1565               	/* #APP */
 1566               	 ;  897 "usb_serial.c" 1
 1567 0088 A591      		lpm r26, Z+
 1568 008a B491      		lpm r27, Z
 1569               		
 1570               	 ;  0 "" 2
 1571               	.LVL144:
 1572               	/* #NOAPP */
 1573               	.LBE61:
 898:usb_serial.c  **** 				if (desc_val != wIndex) {
 1574               		.loc 1 898 0
 1575 008c CA17      		cp r28,r26
 1576 008e DB07      		cpc r29,r27
 1577 0090 01F4      		brne .L176
 1578               	.LVL145:
 899:usb_serial.c  **** 					list += sizeof(struct descriptor_list_struct)-2;
 900:usb_serial.c  **** 					continue;
 901:usb_serial.c  **** 				}
 902:usb_serial.c  **** 				list += 2;
 1579               		.loc 1 902 0
 1580 0092 FC01      		movw r30,r24
 1581 0094 3496      		adiw r30,4
 1582               	.LVL146:
 1583               	.LBB62:
 903:usb_serial.c  **** 				desc_addr = (const uint8_t *)pgm_read_word(list);
 1584               		.loc 1 903 0
 1585               	/* #APP */
 1586               	 ;  903 "usb_serial.c" 1
 1587 0096 4591      		lpm r20, Z+
 1588 0098 5491      		lpm r21, Z
 1589               		
 1590               	 ;  0 "" 2
 1591               	.LVL147:
 1592               	/* #NOAPP */
 1593               	.LBE62:
 904:usb_serial.c  **** 				list += 2;
 1594               		.loc 1 904 0
 1595 009a FC01      		movw r30,r24
 1596 009c 3696      		adiw r30,6
 1597               	.LVL148:
 1598               	.LBB63:
 905:usb_serial.c  **** 				desc_length = pgm_read_byte(list);
 1599               		.loc 1 905 0
 1600               	/* #APP */
 1601               	 ;  905 "usb_serial.c" 1
 1602 009e 8491      		lpm r24, Z
 1603               		
 1604               	 ;  0 "" 2
 1605               	.LVL149:
 1606               	/* #NOAPP */
 1607               	.LBE63:
 906:usb_serial.c  **** 				break;
 907:usb_serial.c  **** 			}
 908:usb_serial.c  **** 			len = (wLength < 256) ? wLength : 255;
 1608               		.loc 1 908 0
 1609 00a0 30E0      		ldi r19,0
 1610 00a2 362B      		or r19,r22
 1611 00a4 2F3F      		cpi r18,-1
 1612 00a6 3105      		cpc r19,__zero_reg__
 1613 00a8 01F0      		breq .L177
 1614 00aa 00F0      		brlo .L177
 1615 00ac 2FEF      		ldi r18,lo8(-1)
 1616 00ae 30E0      		ldi r19,0
 1617               	.LVL150:
 1618               	.L177:
 1619 00b0 2817      		cp r18,r24
 1620 00b2 00F4      		brsh .L178
 1621 00b4 822F      		mov r24,r18
 1622               	.LVL151:
 1623               	.L178:
 1624               	.LBB64:
 1625               	.LBB65:
 839:usb_serial.c  **** }
 1626               		.loc 1 839 0
 1627 00b6 3EEF      		ldi r19,lo8(-2)
 1628 00b8 00C0      		rjmp .L182
 1629               	.LVL152:
 1630               	.L176:
 1631 00ba 0796      		adiw r24,7
 1632               	.LBE65:
 1633               	.LBE64:
 887:usb_serial.c  **** 					UECONX = (1<<STALLRQ)|(1<<EPEN);  //stall
 1634               		.loc 1 887 0
 1635 00bc 4817      		cp r20,r24
 1636 00be 5907      		cpc r21,r25
 1637 00c0 01F4      		brne .L181
 1638 00c2 00C0      		rjmp .L172
 1639               	.LVL153:
 1640               	.L224:
 1641 00c4 490F      		add r20,r25
 1642 00c6 511D      		adc r21,__zero_reg__
 909:usb_serial.c  **** 			if (len > desc_length) len = desc_length;
 910:usb_serial.c  **** 			do {
 911:usb_serial.c  **** 				// wait for host ready for IN packet
 912:usb_serial.c  **** 				do {
 913:usb_serial.c  **** 					i = UEINTX;
 914:usb_serial.c  **** 				} while (!(i & ((1<<TXINI)|(1<<RXOUTI))));
 915:usb_serial.c  **** 				if (i & (1<<RXOUTI)) return;	// abort
 916:usb_serial.c  **** 				// send IN packet
 917:usb_serial.c  **** 				n = len < ENDPOINT0_SIZE ? len : ENDPOINT0_SIZE;
 918:usb_serial.c  **** 				for (i = n; i; i--) {
 919:usb_serial.c  **** 					UEDATX = pgm_read_byte(desc_addr++);
 920:usb_serial.c  **** 				}
 921:usb_serial.c  **** 				len -= n;
 1643               		.loc 1 921 0
 1644 00c8 891B      		sub r24,r25
 1645               	.LVL154:
 1646               	.LBB67:
 1647               	.LBB66:
 839:usb_serial.c  **** }
 1648               		.loc 1 839 0
 1649 00ca 3093 E800 		sts 232,r19
 1650               	.LBE66:
 1651               	.LBE67:
 922:usb_serial.c  **** 				usb_send_in();
 923:usb_serial.c  **** 			} while (len || n == ENDPOINT0_SIZE);
 1652               		.loc 1 923 0
 1653 00ce 8823      		tst r24
 1654 00d0 01F0      		breq .L223
 1655               	.LVL155:
 1656               	.L182:
 913:usb_serial.c  **** 				} while (!(i & ((1<<TXINI)|(1<<RXOUTI))));
 1657               		.loc 1 913 0 discriminator 1
 1658 00d2 9091 E800 		lds r25,232
 1659               	.LVL156:
 914:usb_serial.c  **** 				if (i & (1<<RXOUTI)) return;	// abort
 1660               		.loc 1 914 0 discriminator 1
 1661 00d6 292F      		mov r18,r25
 1662 00d8 2570      		andi r18,lo8(5)
 1663 00da 01F0      		breq .L182
 915:usb_serial.c  **** 				// send IN packet
 1664               		.loc 1 915 0
 1665 00dc 92FD      		sbrc r25,2
 1666 00de 00C0      		rjmp .L171
 917:usb_serial.c  **** 				for (i = n; i; i--) {
 1667               		.loc 1 917 0
 1668 00e0 982F      		mov r25,r24
 1669               	.LVL157:
 1670 00e2 8131      		cpi r24,lo8(17)
 1671 00e4 00F0      		brlo .L184
 1672 00e6 90E1      		ldi r25,lo8(16)
 1673               	.L184:
 1674               	.LVL158:
 918:usb_serial.c  **** 					UEDATX = pgm_read_byte(desc_addr++);
 1675               		.loc 1 918 0
 1676 00e8 FA01      		movw r30,r20
 1677 00ea 292F      		mov r18,r25
 1678               	.LVL159:
 1679               	.L185:
 918:usb_serial.c  **** 					UEDATX = pgm_read_byte(desc_addr++);
 1680               		.loc 1 918 0 is_stmt 0 discriminator 1
 1681 00ec 2223      		tst r18
 1682 00ee 01F0      		breq .L224
 1683               	.LVL160:
 1684               	.LBB68:
 919:usb_serial.c  **** 				}
 1685               		.loc 1 919 0 is_stmt 1 discriminator 3
 1686               	/* #APP */
 1687               	 ;  919 "usb_serial.c" 1
 1688 00f0 6491      		lpm r22, Z
 1689               		
 1690               	 ;  0 "" 2
 1691               	.LVL161:
 1692               	/* #NOAPP */
 1693               	.LBE68:
 1694 00f2 6093 F100 		sts 241,r22
 918:usb_serial.c  **** 					UEDATX = pgm_read_byte(desc_addr++);
 1695               		.loc 1 918 0 discriminator 3
 1696 00f6 2150      		subi r18,lo8(-(-1))
 1697               	.LVL162:
 1698 00f8 3196      		adiw r30,1
 1699               	.LVL163:
 1700 00fa 00C0      		rjmp .L185
 1701               	.LVL164:
 1702               	.L223:
 1703               		.loc 1 923 0 discriminator 1
 1704 00fc 9031      		cpi r25,lo8(16)
 1705 00fe 01F0      		breq .L182
 1706 0100 00C0      		rjmp .L171
 1707               	.LVL165:
 1708               	.L220:
 924:usb_serial.c  **** 			return;
 925:usb_serial.c  ****                 }
 926:usb_serial.c  **** 		if (bRequest == SET_ADDRESS) {
 1709               		.loc 1 926 0
 1710 0102 8530      		cpi r24,lo8(5)
 1711 0104 01F4      		brne .L189
 1712               	.LBB69:
 1713               	.LBB70:
 839:usb_serial.c  **** }
 1714               		.loc 1 839 0
 1715 0106 8EEF      		ldi r24,lo8(-2)
 1716               	.LVL166:
 1717 0108 8093 E800 		sts 232,r24
 1718               	.LBE70:
 1719               	.LBE69:
 927:usb_serial.c  **** 			usb_send_in();
 928:usb_serial.c  **** 			usb_wait_in_ready();
 1720               		.loc 1 928 0
 1721 010c 0E94 0000 		call usb_wait_in_ready
 1722               	.LVL167:
 929:usb_serial.c  **** 			UDADDR = wValue | (1<<ADDEN);
 1723               		.loc 1 929 0
 1724 0110 0068      		ori r16,lo8(-128)
 1725               	.LVL168:
 1726 0112 0093 E300 		sts 227,r16
 930:usb_serial.c  **** 			return;
 1727               		.loc 1 930 0
 1728 0116 00C0      		rjmp .L171
 1729               	.LVL169:
 1730               	.L189:
 931:usb_serial.c  **** 		}
 932:usb_serial.c  **** 		if (bRequest == SET_CONFIGURATION && bmRequestType == 0) {
 1731               		.loc 1 932 0
 1732 0118 8930      		cpi r24,lo8(9)
 1733 011a 01F4      		brne .L190
 1734               		.loc 1 932 0 is_stmt 0 discriminator 1
 1735 011c F110      		cpse r15,__zero_reg__
 1736 011e 00C0      		rjmp .L172
 933:usb_serial.c  **** 			usb_configuration = wValue;
 1737               		.loc 1 933 0 is_stmt 1
 1738 0120 0093 0000 		sts usb_configuration,r16
 934:usb_serial.c  **** 			cdc_line_rtsdtr = 0;
 1739               		.loc 1 934 0
 1740 0124 1092 0000 		sts cdc_line_rtsdtr,__zero_reg__
 935:usb_serial.c  **** 			transmit_flush_timer = 0;
 1741               		.loc 1 935 0
 1742 0128 1092 0000 		sts transmit_flush_timer,__zero_reg__
 1743               	.LBB71:
 1744               	.LBB72:
 839:usb_serial.c  **** }
 1745               		.loc 1 839 0
 1746 012c 8EEF      		ldi r24,lo8(-2)
 1747               	.LVL170:
 1748 012e 8093 E800 		sts 232,r24
 1749               	.LVL171:
 1750               	.LBE72:
 1751               	.LBE71:
 936:usb_serial.c  **** 			usb_send_in();
 937:usb_serial.c  **** 			cfg = endpoint_config_table;
 938:usb_serial.c  **** 			for (i=1; i<5; i++) {
 1752               		.loc 1 938 0
 1753 0132 41E0      		ldi r20,lo8(1)
 937:usb_serial.c  **** 			for (i=1; i<5; i++) {
 1754               		.loc 1 937 0
 1755 0134 80E0      		ldi r24,lo8(endpoint_config_table)
 1756 0136 90E0      		ldi r25,hi8(endpoint_config_table)
 1757               	.LVL172:
 1758               	.L192:
 939:usb_serial.c  **** 				UENUM = i;
 1759               		.loc 1 939 0
 1760 0138 4093 E900 		sts 233,r20
 1761               	.LBB73:
 940:usb_serial.c  **** 				en = pgm_read_byte(cfg++);
 1762               		.loc 1 940 0
 1763 013c 9C01      		movw r18,r24
 1764 013e 2F5F      		subi r18,-1
 1765 0140 3F4F      		sbci r19,-1
 1766               	.LVL173:
 1767 0142 FC01      		movw r30,r24
 1768               	/* #APP */
 1769               	 ;  940 "usb_serial.c" 1
 1770 0144 5491      		lpm r21, Z
 1771               		
 1772               	 ;  0 "" 2
 1773               	.LVL174:
 1774               	/* #NOAPP */
 1775               	.LBE73:
 941:usb_serial.c  **** 				UECONX = en;
 1776               		.loc 1 941 0
 1777 0146 5093 EB00 		sts 235,r21
 942:usb_serial.c  **** 				if (en) {
 1778               		.loc 1 942 0
 1779 014a 5523      		tst r21
 1780 014c 01F0      		breq .L191
 1781               	.LVL175:
 1782               	.LBB74:
 943:usb_serial.c  **** 					UECFG0X = pgm_read_byte(cfg++);
 1783               		.loc 1 943 0
 1784 014e F901      		movw r30,r18
 1785               	/* #APP */
 1786               	 ;  943 "usb_serial.c" 1
 1787 0150 2491      		lpm r18, Z
 1788               		
 1789               	 ;  0 "" 2
 1790               	.LVL176:
 1791               	/* #NOAPP */
 1792               	.LBE74:
 1793 0152 2093 EC00 		sts 236,r18
 1794               	.LBB75:
 944:usb_serial.c  **** 					UECFG1X = pgm_read_byte(cfg++);
 1795               		.loc 1 944 0
 1796 0156 9C01      		movw r18,r24
 1797               	.LVL177:
 1798 0158 2D5F      		subi r18,-3
 1799 015a 3F4F      		sbci r19,-1
 1800               	.LVL178:
 1801               	.LBE75:
 1802               	.LBB76:
 943:usb_serial.c  **** 					UECFG0X = pgm_read_byte(cfg++);
 1803               		.loc 1 943 0
 1804 015c 3196      		adiw r30,1
 1805               	.LVL179:
 1806               	.LBE76:
 1807               	.LBB77:
 1808               		.loc 1 944 0
 1809               	/* #APP */
 1810               	 ;  944 "usb_serial.c" 1
 1811 015e E491      		lpm r30, Z
 1812               		
 1813               	 ;  0 "" 2
 1814               	.LVL180:
 1815               	/* #NOAPP */
 1816               	.LBE77:
 1817 0160 E093 ED00 		sts 237,r30
 1818               	.LVL181:
 1819               	.L191:
 938:usb_serial.c  **** 				UENUM = i;
 1820               		.loc 1 938 0 discriminator 2
 1821 0164 4F5F      		subi r20,lo8(-(1))
 1822               	.LVL182:
 1823 0166 4530      		cpi r20,lo8(5)
 1824 0168 01F0      		breq .L225
 1825 016a C901      		movw r24,r18
 1826               	.LVL183:
 1827 016c 00C0      		rjmp .L192
 1828               	.LVL184:
 1829               	.L225:
 945:usb_serial.c  **** 				}
 946:usb_serial.c  **** 			}
 947:usb_serial.c  ****         		UERST = 0x1E;
 1830               		.loc 1 947 0
 1831 016e 8EE1      		ldi r24,lo8(30)
 1832               	.LVL185:
 1833 0170 00C0      		rjmp .L221
 1834               	.LVL186:
 1835               	.L190:
 948:usb_serial.c  ****         		UERST = 0;
 949:usb_serial.c  **** 			return;
 950:usb_serial.c  **** 		}
 951:usb_serial.c  **** 		if (bRequest == GET_CONFIGURATION && bmRequestType == 0x80) {
 1836               		.loc 1 951 0
 1837 0172 8830      		cpi r24,lo8(8)
 1838 0174 01F4      		brne .L193
 1839               		.loc 1 951 0 is_stmt 0 discriminator 1
 1840 0176 F0E8      		ldi r31,lo8(-128)
 1841 0178 FF12      		cpse r15,r31
 1842 017a 00C0      		rjmp .L172
 952:usb_serial.c  **** 			usb_wait_in_ready();
 1843               		.loc 1 952 0 is_stmt 1
 1844 017c 0E94 0000 		call usb_wait_in_ready
 1845               	.LVL187:
 953:usb_serial.c  **** 			UEDATX = usb_configuration;
 1846               		.loc 1 953 0
 1847 0180 8091 0000 		lds r24,usb_configuration
 1848 0184 8093 F100 		sts 241,r24
 1849 0188 00C0      		rjmp .L222
 1850               	.LVL188:
 1851               	.L193:
 954:usb_serial.c  **** 			usb_send_in();
 955:usb_serial.c  **** 			return;
 956:usb_serial.c  **** 		}
 957:usb_serial.c  **** 		if (bRequest == CDC_GET_LINE_CODING && bmRequestType == 0xA1) {
 1852               		.loc 1 957 0
 1853 018a 8132      		cpi r24,lo8(33)
 1854 018c 01F4      		brne .L194
 1855               		.loc 1 957 0 is_stmt 0 discriminator 1
 1856 018e 81EA      		ldi r24,lo8(-95)
 1857               	.LVL189:
 1858 0190 F812      		cpse r15,r24
 1859 0192 00C0      		rjmp .L172
 958:usb_serial.c  **** 			usb_wait_in_ready();
 1860               		.loc 1 958 0 is_stmt 1
 1861 0194 0E94 0000 		call usb_wait_in_ready
 1862               	.LVL190:
 1863 0198 E0E0      		ldi r30,lo8(cdc_line_coding)
 1864 019a F0E0      		ldi r31,hi8(cdc_line_coding)
 1865 019c 80E0      		ldi r24,lo8(cdc_line_coding+7)
 1866 019e 90E0      		ldi r25,hi8(cdc_line_coding+7)
 1867               	.LVL191:
 1868               	.L195:
 959:usb_serial.c  **** 			p = cdc_line_coding;
 960:usb_serial.c  **** 			for (i=0; i<7; i++) {
 961:usb_serial.c  **** 				UEDATX = *p++;
 1869               		.loc 1 961 0 discriminator 3
 1870 01a0 2191      		ld r18,Z+
 1871               	.LVL192:
 1872 01a2 2093 F100 		sts 241,r18
 1873               	.LVL193:
 960:usb_serial.c  **** 				UEDATX = *p++;
 1874               		.loc 1 960 0 discriminator 3
 1875 01a6 8E17      		cp r24,r30
 1876 01a8 9F07      		cpc r25,r31
 1877 01aa 01F4      		brne .L195
 1878 01ac 00C0      		rjmp .L222
 1879               	.LVL194:
 1880               	.L194:
 962:usb_serial.c  **** 			}
 963:usb_serial.c  **** 			usb_send_in();
 964:usb_serial.c  **** 			return;
 965:usb_serial.c  **** 		}
 966:usb_serial.c  **** 		if (bRequest == CDC_SET_LINE_CODING && bmRequestType == 0x21) {
 1881               		.loc 1 966 0
 1882 01ae 8032      		cpi r24,lo8(32)
 1883 01b0 01F4      		brne .L196
 1884               		.loc 1 966 0 is_stmt 0 discriminator 1
 1885 01b2 91E2      		ldi r25,lo8(33)
 1886 01b4 F912      		cpse r15,r25
 1887 01b6 00C0      		rjmp .L172
 1888               	.LVL195:
 1889               	.L197:
 1890               	.LBB78:
 1891               	.LBB79:
 843:usb_serial.c  **** }
 1892               		.loc 1 843 0 is_stmt 1
 1893 01b8 8091 E800 		lds r24,232
 1894 01bc 82FF      		sbrs r24,2
 1895 01be 00C0      		rjmp .L197
 1896 01c0 E0E0      		ldi r30,lo8(cdc_line_coding)
 1897 01c2 F0E0      		ldi r31,hi8(cdc_line_coding)
 1898 01c4 80E0      		ldi r24,lo8(cdc_line_coding+7)
 1899 01c6 90E0      		ldi r25,hi8(cdc_line_coding+7)
 1900               	.LVL196:
 1901               	.L198:
 1902               	.LBE79:
 1903               	.LBE78:
 967:usb_serial.c  **** 			usb_wait_receive_out();
 968:usb_serial.c  **** 			p = cdc_line_coding;
 969:usb_serial.c  **** 			for (i=0; i<7; i++) {
 970:usb_serial.c  **** 				*p++ = UEDATX;
 1904               		.loc 1 970 0 discriminator 3
 1905 01c8 2091 F100 		lds r18,241
 1906 01cc 2193      		st Z+,r18
 1907               	.LVL197:
 969:usb_serial.c  **** 				*p++ = UEDATX;
 1908               		.loc 1 969 0 discriminator 3
 1909 01ce 8E17      		cp r24,r30
 1910 01d0 9F07      		cpc r25,r31
 1911 01d2 01F4      		brne .L198
 1912               	.LBB80:
 1913               	.LBB81:
 847:usb_serial.c  **** }
 1914               		.loc 1 847 0
 1915 01d4 8BEF      		ldi r24,lo8(-5)
 1916 01d6 8093 E800 		sts 232,r24
 1917 01da 00C0      		rjmp .L222
 1918               	.LVL198:
 1919               	.L196:
 1920               	.LBE81:
 1921               	.LBE80:
 971:usb_serial.c  **** 			}
 972:usb_serial.c  **** 			usb_ack_out();
 973:usb_serial.c  **** 			usb_send_in();
 974:usb_serial.c  **** 			return;
 975:usb_serial.c  **** 		}
 976:usb_serial.c  **** 		if (bRequest == CDC_SET_CONTROL_LINE_STATE && bmRequestType == 0x21) {
 1922               		.loc 1 976 0
 1923 01dc 8232      		cpi r24,lo8(34)
 1924 01de 01F4      		brne .L199
 1925               		.loc 1 976 0 is_stmt 0 discriminator 1
 1926 01e0 E1E2      		ldi r30,lo8(33)
 1927 01e2 FE12      		cpse r15,r30
 1928 01e4 00C0      		rjmp .L172
 977:usb_serial.c  **** 			cdc_line_rtsdtr = wValue;
 1929               		.loc 1 977 0 is_stmt 1
 1930 01e6 0093 0000 		sts cdc_line_rtsdtr,r16
 978:usb_serial.c  **** 			usb_wait_in_ready();
 1931               		.loc 1 978 0
 1932 01ea 0E94 0000 		call usb_wait_in_ready
 1933               	.LVL199:
 1934 01ee 00C0      		rjmp .L222
 1935               	.LVL200:
 1936               	.L199:
 979:usb_serial.c  **** 			usb_send_in();
 980:usb_serial.c  **** 			return;
 981:usb_serial.c  **** 		}
 982:usb_serial.c  **** 		if (bRequest == GET_STATUS) {
 1937               		.loc 1 982 0
 1938 01f0 8111      		cpse r24,__zero_reg__
 1939 01f2 00C0      		rjmp .L200
 983:usb_serial.c  **** 			usb_wait_in_ready();
 1940               		.loc 1 983 0
 1941 01f4 0E94 0000 		call usb_wait_in_ready
 1942               	.LVL201:
 984:usb_serial.c  **** 			i = 0;
 985:usb_serial.c  **** 			#ifdef SUPPORT_ENDPOINT_HALT
 986:usb_serial.c  **** 			if (bmRequestType == 0x82) {
 1943               		.loc 1 986 0
 1944 01f8 F2E8      		ldi r31,lo8(-126)
 1945 01fa FF12      		cpse r15,r31
 1946 01fc 00C0      		rjmp .L204
 987:usb_serial.c  **** 				UENUM = wIndex;
 1947               		.loc 1 987 0
 1948 01fe C093 E900 		sts 233,r28
 988:usb_serial.c  **** 				if (UECONX & (1<<STALLRQ)) i = 1;
 1949               		.loc 1 988 0
 1950 0202 8091 EB00 		lds r24,235
 984:usb_serial.c  **** 			i = 0;
 1951               		.loc 1 984 0
 1952 0206 85FB      		bst r24,5
 1953 0208 8827      		clr r24
 1954 020a 80F9      		bld r24,0
 1955               	.LVL202:
 989:usb_serial.c  **** 				UENUM = 0;
 1956               		.loc 1 989 0
 1957 020c 1092 E900 		sts 233,__zero_reg__
 1958 0210 00C0      		rjmp .L201
 1959               	.LVL203:
 1960               	.L204:
 984:usb_serial.c  **** 			#ifdef SUPPORT_ENDPOINT_HALT
 1961               		.loc 1 984 0
 1962 0212 80E0      		ldi r24,0
 1963               	.LVL204:
 1964               	.L201:
 990:usb_serial.c  **** 			}
 991:usb_serial.c  **** 			#endif
 992:usb_serial.c  **** 			UEDATX = i;
 1965               		.loc 1 992 0
 1966 0214 8093 F100 		sts 241,r24
 993:usb_serial.c  **** 			UEDATX = 0;
 1967               		.loc 1 993 0
 1968 0218 1092 F100 		sts 241,__zero_reg__
 1969               	.LVL205:
 1970               	.L222:
 1971               	.LBB82:
 1972               	.LBB83:
 839:usb_serial.c  **** }
 1973               		.loc 1 839 0
 1974 021c 8EEF      		ldi r24,lo8(-2)
 1975 021e 8093 E800 		sts 232,r24
 1976 0222 00C0      		rjmp .L171
 1977               	.LVL206:
 1978               	.L200:
 1979               	.LBE83:
 1980               	.LBE82:
 994:usb_serial.c  **** 			usb_send_in();
 995:usb_serial.c  **** 			return;
 996:usb_serial.c  **** 		}
 997:usb_serial.c  **** 		#ifdef SUPPORT_ENDPOINT_HALT
 998:usb_serial.c  **** 		if ((bRequest == CLEAR_FEATURE || bRequest == SET_FEATURE)
 1981               		.loc 1 998 0
 1982 0224 982F      		mov r25,r24
 1983 0226 9D7F      		andi r25,lo8(-3)
 1984 0228 9130      		cpi r25,lo8(1)
 1985 022a 01F4      		brne .L172
 999:usb_serial.c  **** 		  && bmRequestType == 0x02 && wValue == 0) {
 1986               		.loc 1 999 0
 1987 022c 92E0      		ldi r25,lo8(2)
 1988 022e F912      		cpse r15,r25
 1989 0230 00C0      		rjmp .L172
 1990               		.loc 1 999 0 is_stmt 0 discriminator 1
 1991 0232 012B      		or r16,r17
 1992 0234 01F4      		brne .L172
1000:usb_serial.c  **** 			i = wIndex & 0x7F;
 1993               		.loc 1 1000 0 is_stmt 1
 1994 0236 CF77      		andi r28,lo8(127)
 1995               	.LVL207:
1001:usb_serial.c  **** 			if (i >= 1 && i <= MAX_ENDPOINT) {
 1996               		.loc 1 1001 0
 1997 0238 9FEF      		ldi r25,lo8(-1)
 1998 023a 9C0F      		add r25,r28
 1999 023c 9430      		cpi r25,lo8(4)
 2000 023e 00F4      		brsh .L172
 2001               	.LBB84:
 2002               	.LBB85:
 839:usb_serial.c  **** }
 2003               		.loc 1 839 0
 2004 0240 9EEF      		ldi r25,lo8(-2)
 2005 0242 9093 E800 		sts 232,r25
 2006               	.LBE85:
 2007               	.LBE84:
1002:usb_serial.c  **** 				usb_send_in();
1003:usb_serial.c  **** 				UENUM = i;
 2008               		.loc 1 1003 0
 2009 0246 C093 E900 		sts 233,r28
1004:usb_serial.c  **** 				if (bRequest == SET_FEATURE) {
 2010               		.loc 1 1004 0
 2011 024a 8330      		cpi r24,lo8(3)
 2012 024c 01F0      		breq .L172
1005:usb_serial.c  **** 					UECONX = (1<<STALLRQ)|(1<<EPEN);
1006:usb_serial.c  **** 				} else {
1007:usb_serial.c  **** 					UECONX = (1<<STALLRQC)|(1<<RSTDT)|(1<<EPEN);
 2013               		.loc 1 1007 0
 2014 024e 89E1      		ldi r24,lo8(25)
 2015               	.LVL208:
 2016 0250 8093 EB00 		sts 235,r24
1008:usb_serial.c  **** 					UERST = (1 << i);
 2017               		.loc 1 1008 0
 2018 0254 81E0      		ldi r24,lo8(1)
 2019 0256 90E0      		ldi r25,0
 2020 0258 00C0      		rjmp 2f
 2021               		1:
 2022 025a 880F      		lsl r24
 2023               		2:
 2024 025c CA95      		dec r28
 2025 025e 02F4      		brpl 1b
 2026               	.LVL209:
 2027               	.L221:
 2028 0260 8093 EA00 		sts 234,r24
1009:usb_serial.c  **** 					UERST = 0;
 2029               		.loc 1 1009 0
 2030 0264 1092 EA00 		sts 234,__zero_reg__
 2031 0268 00C0      		rjmp .L171
 2032               	.LVL210:
 2033               	.L172:
1010:usb_serial.c  **** 				}
1011:usb_serial.c  **** 				return;
1012:usb_serial.c  **** 			}
1013:usb_serial.c  **** 		}
1014:usb_serial.c  **** 		#endif
1015:usb_serial.c  ****         }
1016:usb_serial.c  **** 	UECONX = (1<<STALLRQ) | (1<<EPEN);	// stall
 2034               		.loc 1 1016 0
 2035 026a 81E2      		ldi r24,lo8(33)
 2036 026c 8093 EB00 		sts 235,r24
 2037               	.L171:
 2038               	/* epilogue start */
1017:usb_serial.c  **** }
 2039               		.loc 1 1017 0
 2040 0270 FF91      		pop r31
 2041 0272 EF91      		pop r30
 2042 0274 DF91      		pop r29
 2043 0276 CF91      		pop r28
 2044 0278 BF91      		pop r27
 2045 027a AF91      		pop r26
 2046 027c 9F91      		pop r25
 2047 027e 8F91      		pop r24
 2048 0280 7F91      		pop r23
 2049 0282 6F91      		pop r22
 2050 0284 5F91      		pop r21
 2051 0286 4F91      		pop r20
 2052 0288 3F91      		pop r19
 2053 028a 2F91      		pop r18
 2054 028c 1F91      		pop r17
 2055 028e 0F91      		pop r16
 2056 0290 FF90      		pop r15
 2057 0292 0F90      		pop r0
 2058 0294 0BBE      		out __RAMPZ__,r0
 2059 0296 0F90      		pop r0
 2060 0298 0FBE      		out __SREG__,r0
 2061 029a 0F90      		pop r0
 2062 029c 1F90      		pop r1
 2063 029e 1895      		reti
 2064               		.cfi_endproc
 2065               	.LFE21:
 2067               		.local	cdc_line_rtsdtr
 2068               		.comm	cdc_line_rtsdtr,1,1
 2069               		.data
 2072               	cdc_line_coding:
 2073 0000 00        		.byte	0
 2074 0001 E1        		.byte	-31
 2075 0002 00        		.byte	0
 2076 0003 00        		.byte	0
 2077 0004 00        		.byte	0
 2078 0005 00        		.byte	0
 2079 0006 08        		.byte	8
 2080               		.local	transmit_previous_timeout
 2081               		.comm	transmit_previous_timeout,1,1
 2082               		.local	transmit_flush_timer
 2083               		.comm	transmit_flush_timer,1,1
 2084               		.local	usb_configuration
 2085               		.comm	usb_configuration,1,1
 2086               		.section	.progmem.data,"a",@progbits
 2089               	descriptor_list:
 2090 0000 0001      		.word	256
 2091 0002 0000      		.word	0
 2092 0004 0000      		.word	device_descriptor
 2093 0006 12        		.byte	18
 2094 0007 0002      		.word	512
 2095 0009 0000      		.word	0
 2096 000b 0000      		.word	config1_descriptor
 2097 000d 43        		.byte	67
 2098 000e 0003      		.word	768
 2099 0010 0000      		.word	0
 2100 0012 0000      		.word	string0
 2101 0014 04        		.byte	4
 2102 0015 0103      		.word	769
 2103 0017 0904      		.word	1033
 2104 0019 0000      		.word	string1
 2105 001b 14        		.byte	20
 2106 001c 0203      		.word	770
 2107 001e 0904      		.word	1033
 2108 0020 0000      		.word	string2
 2109 0022 16        		.byte	22
 2110 0023 0303      		.word	771
 2111 0025 0904      		.word	1033
 2112 0027 0000      		.word	string3
 2113 0029 0C        		.byte	12
 2116               	string3:
 2117 002a 0C        		.byte	12
 2118 002b 03        		.byte	3
 2119 002c 3100      		.string	"1"
 2120 002e 3200      		.string	"2"
 2121 0030 3300      		.string	"3"
 2122 0032 3400      		.string	"4"
 2123 0034 3500      		.string	"5"
 2124 0036 00        		.string	""
 2125 0037 00        		.string	""
 2128               	string2:
 2129 0038 16        		.byte	22
 2130 0039 03        		.byte	3
 2131 003a 5500      		.string	"U"
 2132 003c 5300      		.string	"S"
 2133 003e 4200      		.string	"B"
 2134 0040 2000      		.string	" "
 2135 0042 5300      		.string	"S"
 2136 0044 6500      		.string	"e"
 2137 0046 7200      		.string	"r"
 2138 0048 6900      		.string	"i"
 2139 004a 6100      		.string	"a"
 2140 004c 6C00      		.string	"l"
 2141 004e 00        		.string	""
 2142 004f 00        		.string	""
 2145               	string1:
 2146 0050 14        		.byte	20
 2147 0051 03        		.byte	3
 2148 0052 5900      		.string	"Y"
 2149 0054 6F00      		.string	"o"
 2150 0056 7500      		.string	"u"
 2151 0058 7200      		.string	"r"
 2152 005a 2000      		.string	" "
 2153 005c 4E00      		.string	"N"
 2154 005e 6100      		.string	"a"
 2155 0060 6D00      		.string	"m"
 2156 0062 6500      		.string	"e"
 2157 0064 00        		.string	""
 2158 0065 00        		.string	""
 2161               	string0:
 2162 0066 04        		.byte	4
 2163 0067 03        		.byte	3
 2164 0068 0904      		.word	1033
 2167               	config1_descriptor:
 2168 006a 09        		.byte	9
 2169 006b 02        		.byte	2
 2170 006c 43        		.byte	67
 2171 006d 00        		.byte	0
 2172 006e 02        		.byte	2
 2173 006f 01        		.byte	1
 2174 0070 00        		.byte	0
 2175 0071 C0        		.byte	-64
 2176 0072 32        		.byte	50
 2177 0073 09        		.byte	9
 2178 0074 04        		.byte	4
 2179 0075 00        		.byte	0
 2180 0076 00        		.byte	0
 2181 0077 01        		.byte	1
 2182 0078 02        		.byte	2
 2183 0079 02        		.byte	2
 2184 007a 01        		.byte	1
 2185 007b 00        		.byte	0
 2186 007c 05        		.byte	5
 2187 007d 24        		.byte	36
 2188 007e 00        		.byte	0
 2189 007f 10        		.byte	16
 2190 0080 01        		.byte	1
 2191 0081 05        		.byte	5
 2192 0082 24        		.byte	36
 2193 0083 01        		.byte	1
 2194 0084 01        		.byte	1
 2195 0085 01        		.byte	1
 2196 0086 04        		.byte	4
 2197 0087 24        		.byte	36
 2198 0088 02        		.byte	2
 2199 0089 06        		.byte	6
 2200 008a 05        		.byte	5
 2201 008b 24        		.byte	36
 2202 008c 06        		.byte	6
 2203 008d 00        		.byte	0
 2204 008e 01        		.byte	1
 2205 008f 07        		.byte	7
 2206 0090 05        		.byte	5
 2207 0091 82        		.byte	-126
 2208 0092 03        		.byte	3
 2209 0093 10        		.byte	16
 2210 0094 00        		.byte	0
 2211 0095 40        		.byte	64
 2212 0096 09        		.byte	9
 2213 0097 04        		.byte	4
 2214 0098 01        		.byte	1
 2215 0099 00        		.byte	0
 2216 009a 02        		.byte	2
 2217 009b 0A        		.byte	10
 2218 009c 00        		.byte	0
 2219 009d 00        		.byte	0
 2220 009e 00        		.byte	0
 2221 009f 07        		.byte	7
 2222 00a0 05        		.byte	5
 2223 00a1 03        		.byte	3
 2224 00a2 02        		.byte	2
 2225 00a3 40        		.byte	64
 2226 00a4 00        		.byte	0
 2227 00a5 00        		.byte	0
 2228 00a6 07        		.byte	7
 2229 00a7 05        		.byte	5
 2230 00a8 84        		.byte	-124
 2231 00a9 02        		.byte	2
 2232 00aa 40        		.byte	64
 2233 00ab 00        		.byte	0
 2234 00ac 00        		.byte	0
 2237               	device_descriptor:
 2238 00ad 12        		.byte	18
 2239 00ae 01        		.byte	1
 2240 00af 0002      		.word	512
 2241 00b1 02        		.byte	2
 2242 00b2 00        		.byte	0
 2243 00b3 00        		.byte	0
 2244 00b4 10        		.byte	16
 2245 00b5 C016      		.word	5824
 2246 00b7 7A04      		.word	1146
 2247 00b9 0001      		.word	256
 2248 00bb 01        		.byte	1
 2249 00bc 02        		.byte	2
 2250 00bd 03        		.byte	3
 2251 00be 01        		.byte	1
 2254               	endpoint_config_table:
 2255 00bf 00        		.byte	0
 2256 00c0 01        		.byte	1
 2257 00c1 C1        		.byte	-63
 2258 00c2 12        		.byte	18
 2259 00c3 01        		.byte	1
 2260 00c4 80        		.byte	-128
 2261 00c5 36        		.byte	54
 2262 00c6 01        		.byte	1
 2263 00c7 81        		.byte	-127
 2264 00c8 36        		.byte	54
 2265               		.text
 2266               	.Letext0:
 2267               		.file 2 "/usr/lib/avr/include/stdint.h"
 2268               		.file 3 "./usb.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 usb_serial.c
     /tmp/ccmrp926.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccmrp926.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccmrp926.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccmrp926.s:5      *ABS*:000000000000003b __RAMPZ__
     /tmp/ccmrp926.s:6      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccmrp926.s:7      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccmrp926.s:13     .text.usb_wait_in_ready:0000000000000000 usb_wait_in_ready
     /tmp/ccmrp926.s:36     .text.usb_init:0000000000000000 usb_init
     /tmp/ccmrp926.s:2083   .bss:0000000000000003 usb_configuration
                             .bss:0000000000000000 cdc_line_rtsdtr
     /tmp/ccmrp926.s:83     .text.usb_configured:0000000000000000 usb_configured
     /tmp/ccmrp926.s:101    .text.usb_serial_getchar:0000000000000000 usb_serial_getchar
     /tmp/ccmrp926.s:175    .text.usb_serial_available:0000000000000000 usb_serial_available
     /tmp/ccmrp926.s:238    .text.usb_serial_flush_input:0000000000000000 usb_serial_flush_input
     /tmp/ccmrp926.s:284    .text.usb_serial_putchar:0000000000000000 usb_serial_putchar
     /tmp/ccmrp926.s:2068   .bss:0000000000000001 transmit_previous_timeout
     /tmp/ccmrp926.s:2081   .bss:0000000000000002 transmit_flush_timer
     /tmp/ccmrp926.s:400    .text.usb_serial_putchar_nowait:0000000000000000 usb_serial_putchar_nowait
     /tmp/ccmrp926.s:466    .text.usb_serial_write:0000000000000000 usb_serial_write
     /tmp/ccmrp926.s:1102   .text.usb_serial_flush_output:0000000000000000 usb_serial_flush_output
     /tmp/ccmrp926.s:1141   .text.usb_serial_get_baud:0000000000000000 usb_serial_get_baud
     /tmp/ccmrp926.s:2072   .data:0000000000000000 cdc_line_coding
     /tmp/ccmrp926.s:1162   .text.usb_serial_get_stopbits:0000000000000000 usb_serial_get_stopbits
     /tmp/ccmrp926.s:1179   .text.usb_serial_get_paritytype:0000000000000000 usb_serial_get_paritytype
     /tmp/ccmrp926.s:1196   .text.usb_serial_get_numbits:0000000000000000 usb_serial_get_numbits
     /tmp/ccmrp926.s:1213   .text.usb_serial_get_control:0000000000000000 usb_serial_get_control
     /tmp/ccmrp926.s:1230   .text.usb_serial_set_control:0000000000000000 usb_serial_set_control
     /tmp/ccmrp926.s:1306   .text.__vector_10:0000000000000000 __vector_10
     /tmp/ccmrp926.s:1404   .text.__vector_11:0000000000000000 __vector_11
     /tmp/ccmrp926.s:2089   .progmem.data:0000000000000000 descriptor_list
     /tmp/ccmrp926.s:2254   .progmem.data:00000000000000bf endpoint_config_table
     /tmp/ccmrp926.s:2237   .progmem.data:00000000000000ad device_descriptor
     /tmp/ccmrp926.s:2167   .progmem.data:000000000000006a config1_descriptor
     /tmp/ccmrp926.s:2161   .progmem.data:0000000000000066 string0
     /tmp/ccmrp926.s:2145   .progmem.data:0000000000000050 string1
     /tmp/ccmrp926.s:2128   .progmem.data:0000000000000038 string2
     /tmp/ccmrp926.s:2116   .progmem.data:000000000000002a string3

UNDEFINED SYMBOLS
__tablejump2__
__do_copy_data
__do_clear_bss
