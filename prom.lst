   1               		.file	"prom.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.text
   9               	.Ltext0:
  10               		.cfi_sections	.debug_frame
  11               		.section	.text.hexdigit,"ax",@progbits
  13               	hexdigit:
  14               	.LFB7:
  15               		.file 1 "prom.c"
   1:prom.c        **** /**
   2:prom.c        ****  * \file PROM dancer
   3:prom.c        ****  *
   4:prom.c        ****  * Read up to 40 pin DIP PROMs using a Teensy++ 2.0
   5:prom.c        ****  */
   6:prom.c        **** 
   7:prom.c        **** #include <avr/io.h>
   8:prom.c        **** #include <avr/pgmspace.h>
   9:prom.c        **** #include <avr/interrupt.h>
  10:prom.c        **** #include <stdint.h>
  11:prom.c        **** #include <string.h>
  12:prom.c        **** #include <util/delay.h>
  13:prom.c        **** #include "usb_serial.h"
  14:prom.c        **** #include "xmodem.h"
  15:prom.c        **** #include "bits.h"
  16:prom.c        **** #include "chips.h"
  17:prom.c        **** 
  18:prom.c        **** void send_str(const char *s);
  19:prom.c        **** void send_mem_str(const char *s);
  20:prom.c        **** uint8_t recv_str(char *buf, uint8_t size);
  21:prom.c        **** void parse_and_execute_command(const char *buf, uint8_t num);
  22:prom.c        **** 
  23:prom.c        **** static uint8_t
  24:prom.c        **** hexdigit(
  25:prom.c        **** 	uint8_t x
  26:prom.c        **** )
  27:prom.c        **** {
  16               		.loc 1 27 0
  17               		.cfi_startproc
  18               	.LVL0:
  19               	/* prologue: function */
  20               	/* frame size = 0 */
  21               	/* stack size = 0 */
  22               	.L__stack_usage = 0
  28:prom.c        **** 	x &= 0xF;
  23               		.loc 1 28 0
  24 0000 8F70      		andi r24,lo8(15)
  25               	.LVL1:
  29:prom.c        **** 	if (x < 0xA)
  26               		.loc 1 29 0
  27 0002 8A30      		cpi r24,lo8(10)
  28 0004 00F4      		brsh .L2
  30:prom.c        **** 		return x + '0' - 0x0;
  29               		.loc 1 30 0
  30 0006 805D      		subi r24,lo8(-(48))
  31               	.LVL2:
  32 0008 0895      		ret
  33               	.LVL3:
  34               	.L2:
  31:prom.c        **** 	else
  32:prom.c        **** 		return x + 'A' - 0xA;
  35               		.loc 1 32 0
  36 000a 895C      		subi r24,lo8(-(55))
  37               	.LVL4:
  33:prom.c        **** }
  38               		.loc 1 33 0
  39 000c 0895      		ret
  40               		.cfi_endproc
  41               	.LFE7:
  43               		.section	.text.prom_pin,"ax",@progbits
  45               	prom_pin:
  46               	.LFB9:
  34:prom.c        **** 
  35:prom.c        **** 
  36:prom.c        **** static uint8_t
  37:prom.c        **** printable(
  38:prom.c        **** 	uint8_t x
  39:prom.c        **** )
  40:prom.c        **** {
  41:prom.c        **** 	if ('A' <= x && x <= 'Z')
  42:prom.c        **** 		return 1;
  43:prom.c        **** 	if ('a' <= x && x <= 'z')
  44:prom.c        **** 		return 1;
  45:prom.c        **** 	if ('0' <= x && x <= '9')
  46:prom.c        **** 		return 1;
  47:prom.c        **** 	if (x == ' ')
  48:prom.c        **** 		return 1;
  49:prom.c        **** 
  50:prom.c        **** 	return 0;
  51:prom.c        **** }
  52:prom.c        **** 	
  53:prom.c        **** 
  54:prom.c        **** /** Total number of mapped pins.
  55:prom.c        ****  * This is unlikely to change without a significant hardware redesign.
  56:prom.c        ****  */
  57:prom.c        **** #define ZIF_PINS 40
  58:prom.c        **** 
  59:prom.c        **** /** Mapping of AVR IO ports to the ZIF socket pins */
  60:prom.c        **** static const uint8_t ports[ZIF_PINS+1] = {
  61:prom.c        **** 	[ 1]	= 0xB6,
  62:prom.c        **** 	[ 2]	= 0xB5,
  63:prom.c        **** 	[ 3]	= 0xB4,
  64:prom.c        **** 	[ 4]	= 0xB3,
  65:prom.c        **** 	[ 5]	= 0xB2,
  66:prom.c        **** 	[ 6]	= 0xB1,
  67:prom.c        **** 	[ 7]	= 0xB0,
  68:prom.c        **** 	[ 8]	= 0xE7,
  69:prom.c        **** 	[ 9]	= 0xE6,
  70:prom.c        **** 	[10]	= 0xA2,
  71:prom.c        **** 	[11]	= 0xA1,
  72:prom.c        **** 	[12]	= 0xF0,
  73:prom.c        **** 	[13]	= 0xF1,
  74:prom.c        **** 	[14]	= 0xF2,
  75:prom.c        **** 	[15]	= 0xF3,
  76:prom.c        **** 	[16]	= 0xF4,
  77:prom.c        **** 	[17]	= 0xF5,
  78:prom.c        **** 	[18]	= 0xF6,
  79:prom.c        **** 	[19]	= 0xF7,
  80:prom.c        **** 	[20]	= 0xA3,
  81:prom.c        **** 
  82:prom.c        **** 	[21]	= 0xA7,
  83:prom.c        **** 	[22]	= 0xC7,
  84:prom.c        **** 	[23]	= 0xC6,
  85:prom.c        **** 	[24]	= 0xC5,
  86:prom.c        **** 	[25]	= 0xC4,
  87:prom.c        **** 	[26]	= 0xC3,
  88:prom.c        **** 	[27]	= 0xC2,
  89:prom.c        **** 	[28]	= 0xC1,
  90:prom.c        **** 	[29]	= 0xC0,
  91:prom.c        **** 	[30]	= 0xE1,
  92:prom.c        **** 	[31]	= 0xE0,
  93:prom.c        **** 	[32]	= 0xD7,
  94:prom.c        **** 	[33]	= 0xD6,
  95:prom.c        **** 	[34]	= 0xD5,
  96:prom.c        **** 	[35]	= 0xD4,
  97:prom.c        **** 	[36]	= 0xD3,
  98:prom.c        **** 	[37]	= 0xD2,
  99:prom.c        **** 	[38]	= 0xD1,
 100:prom.c        **** 	[39]	= 0xD0,
 101:prom.c        **** 	[40]	= 0xB7,
 102:prom.c        **** };
 103:prom.c        **** 
 104:prom.c        **** /** Select one of the chips */
 105:prom.c        **** static const prom_t * prom = &proms[0];
 106:prom.c        **** 
 107:prom.c        **** 
 108:prom.c        **** /** Translate PROM pin numbers into ZIF pin numbers */
 109:prom.c        **** static inline uint8_t
 110:prom.c        **** prom_pin(
 111:prom.c        **** 	const uint8_t pin
 112:prom.c        **** )
 113:prom.c        **** {
  47               		.loc 1 113 0
  48               		.cfi_startproc
  49               	.LVL5:
  50               	/* prologue: function */
  51               	/* frame size = 0 */
  52               	/* stack size = 0 */
  53               	.L__stack_usage = 0
 114:prom.c        **** 	if (pin <= prom->pins / 2)
  54               		.loc 1 114 0
  55 0000 E091 0000 		lds r30,prom
  56 0004 F091 0000 		lds r31,prom+1
  57 0008 9189      		ldd r25,Z+17
  58 000a 492F      		mov r20,r25
  59 000c 4695      		lsr r20
  60 000e 282F      		mov r18,r24
  61 0010 30E0      		ldi r19,0
 115:prom.c        **** 		return ports[pin];
  62               		.loc 1 115 0
  63 0012 F901      		movw r30,r18
 114:prom.c        **** 	if (pin <= prom->pins / 2)
  64               		.loc 1 114 0
  65 0014 4817      		cp r20,r24
  66 0016 00F4      		brsh .L8
 116:prom.c        **** 	else
 117:prom.c        **** 		return ports[pin + ZIF_PINS - prom->pins];
  67               		.loc 1 117 0
  68 0018 B896      		adiw r30,40
  69 001a E91B      		sub r30,r25
  70 001c F109      		sbc r31,__zero_reg__
  71               	.L8:
  72 001e E050      		subi r30,lo8(-(ports))
  73 0020 F040      		sbci r31,hi8(-(ports))
  74 0022 8081      		ld r24,Z
  75               	.LVL6:
 118:prom.c        **** }
  76               		.loc 1 118 0
  77 0024 0895      		ret
  78               		.cfi_endproc
  79               	.LFE9:
  81               		.section	.text.prom_tristate,"ax",@progbits
  83               	prom_tristate:
  84               	.LFB15:
 119:prom.c        **** 
 120:prom.c        **** 
 121:prom.c        **** /** Generate a 0.5 MHz clock on the XTAL pin to drive the chip
 122:prom.c        ****  * if it does not have a built in oscillator enabled.
 123:prom.c        ****  */
 124:prom.c        **** static void
 125:prom.c        **** isp_clock(
 126:prom.c        **** 	uint8_t cycles
 127:prom.c        **** )
 128:prom.c        **** {
 129:prom.c        **** 	const uint8_t xtal = prom_pin(prom->addr_pins[ISP_XTAL]);
 130:prom.c        **** 	for (uint8_t i = 0 ; i < cycles ; i++)
 131:prom.c        **** 	{
 132:prom.c        **** 		out(xtal, 1);
 133:prom.c        **** 		_delay_us(1);
 134:prom.c        **** 		out(xtal, 0);
 135:prom.c        **** 		_delay_us(1);
 136:prom.c        **** 	}
 137:prom.c        **** }
 138:prom.c        **** 
 139:prom.c        **** 
 140:prom.c        **** /** Send a byte to an AVR ISP enabled chip and read a result.
 141:prom.c        ****  * Since the AVR ISP is bidirectional, every byte out is also a byte in.
 142:prom.c        ****  */
 143:prom.c        **** static uint8_t
 144:prom.c        **** isp_write(
 145:prom.c        **** 	uint8_t byte
 146:prom.c        **** )
 147:prom.c        **** {
 148:prom.c        **** 	const uint8_t mosi = prom_pin(prom->addr_pins[ISP_MOSI]);
 149:prom.c        **** 	const uint8_t sck = prom_pin(prom->addr_pins[ISP_SCK]);
 150:prom.c        **** 	const uint8_t miso = prom_pin(prom->data_pins[ISP_MISO]);
 151:prom.c        **** 	uint8_t rc = 0;
 152:prom.c        **** 
 153:prom.c        **** 	for (uint8_t i = 0 ; i < 8 ; i++, byte <<= 1)
 154:prom.c        **** 	{
 155:prom.c        **** 		out(mosi, (byte & 0x80) ? 1 : 0);
 156:prom.c        **** 		isp_clock(4);
 157:prom.c        **** 
 158:prom.c        **** 		out(sck, 1);
 159:prom.c        **** 		isp_clock(4);
 160:prom.c        **** 
 161:prom.c        **** 		rc = (rc << 1) | (in(miso) ? 1 : 0);
 162:prom.c        **** 		out(sck, 0);
 163:prom.c        **** 	}
 164:prom.c        **** 
 165:prom.c        **** 	return rc;
 166:prom.c        **** }
 167:prom.c        **** 
 168:prom.c        **** 
 169:prom.c        **** /** Enter programming mode for an ISP chip.
 170:prom.c        ****  * \return 1 on success, 0 on failure.
 171:prom.c        ****  */
 172:prom.c        **** static int
 173:prom.c        **** isp_setup(void)
 174:prom.c        **** {
 175:prom.c        **** 	// Pulse the RESET pin, while holding SCK low.
 176:prom.c        **** 	const uint8_t sck = prom_pin(prom->addr_pins[ISP_SCK]);
 177:prom.c        **** 	const uint8_t reset = prom_pin(prom->addr_pins[ISP_RESET]);
 178:prom.c        **** 	const uint8_t miso = prom_pin(prom->data_pins[ISP_MISO]);
 179:prom.c        **** 	out(sck, 0);
 180:prom.c        **** 	out(reset, 1);
 181:prom.c        **** 	isp_clock(4);
 182:prom.c        **** 	out(reset, 0);
 183:prom.c        **** 	isp_clock(255);
 184:prom.c        **** 
 185:prom.c        **** 	// Now delay at least 20 ms
 186:prom.c        **** 	_delay_ms(20);
 187:prom.c        **** 
 188:prom.c        **** 	uint8_t rc1, rc2, rc3, rc4;
 189:prom.c        **** 
 190:prom.c        **** 	// Enter programming mode; enable pull up on the MISO pin
 191:prom.c        **** 	out(miso, 1);
 192:prom.c        **** 
 193:prom.c        **** 	rc1 = isp_write(0xAC);
 194:prom.c        **** 	rc2 = isp_write(0x53);
 195:prom.c        **** 	rc3 = isp_write(0x12);
 196:prom.c        **** 	rc4 = isp_write(0x34);
 197:prom.c        **** 
 198:prom.c        **** 	// Disable pull up
 199:prom.c        **** 	out(miso, 0);
 200:prom.c        **** 
 201:prom.c        **** 	if (rc3 == 0x53)
 202:prom.c        **** 		return 1;
 203:prom.c        **** 
 204:prom.c        **** 	// Now show what we read
 205:prom.c        **** 	uint8_t buf[10];
 206:prom.c        **** 	buf[0] = hexdigit(rc1 >> 4);
 207:prom.c        **** 	buf[1] = hexdigit(rc1 >> 0);
 208:prom.c        **** 	buf[2] = hexdigit(rc2 >> 4);
 209:prom.c        **** 	buf[3] = hexdigit(rc2 >> 0);
 210:prom.c        **** 	buf[4] = hexdigit(rc3 >> 4);
 211:prom.c        **** 	buf[5] = hexdigit(rc3 >> 0);
 212:prom.c        **** 	buf[6] = hexdigit(rc4 >> 4);
 213:prom.c        **** 	buf[7] = hexdigit(rc4 >> 0);
 214:prom.c        **** 
 215:prom.c        **** 	buf[8] = '\r';
 216:prom.c        **** 	buf[9] = '\n';
 217:prom.c        **** 
 218:prom.c        **** 	usb_serial_write(buf, sizeof(buf));
 219:prom.c        **** 	return 0;
 220:prom.c        **** }
 221:prom.c        **** 
 222:prom.c        **** 
 223:prom.c        **** /** Read a byte using the AVRISP, instead of the normal PROM format.
 224:prom.c        ****  */
 225:prom.c        **** static uint8_t
 226:prom.c        **** isp_read(
 227:prom.c        **** 	uint32_t addr
 228:prom.c        **** )
 229:prom.c        **** {
 230:prom.c        **** 	uint8_t h = (addr >> 12) & 0x01;
 231:prom.c        **** 	uint8_t a = (addr >>  8) & 0x0F;
 232:prom.c        **** 	uint8_t b = (addr >>  0) & 0xFF;
 233:prom.c        **** 	isp_write(0x20 | (h ? 0x8 : 0));
 234:prom.c        **** 	isp_write(a);
 235:prom.c        **** 	isp_write(b);
 236:prom.c        **** 	return isp_write(0);
 237:prom.c        **** }
 238:prom.c        **** 
 239:prom.c        **** 
 240:prom.c        **** 
 241:prom.c        **** /** Configure all of the IO pins for the new PROM type */
 242:prom.c        **** static void
 243:prom.c        **** prom_setup(void)
 244:prom.c        **** {
 245:prom.c        **** 	// Configure all of the address pins as outputs,
 246:prom.c        **** 	// pulled low for now
 247:prom.c        **** 	for (uint8_t i = 0 ; i < array_count(prom->addr_pins) ; i++)
 248:prom.c        **** 	{
 249:prom.c        **** 		uint8_t pin = prom_pin(prom->addr_pins[i]);
 250:prom.c        **** 		if (pin == 0)
 251:prom.c        **** 			continue;
 252:prom.c        **** 		out(pin, 0);
 253:prom.c        **** 		ddr(pin, 1);
 254:prom.c        **** 	}
 255:prom.c        **** 
 256:prom.c        **** 	// Configure all of the data pins as inputs,
 257:prom.c        **** 	// Enable pullups if specified.
 258:prom.c        **** 	for (uint8_t i = 0 ; i < array_count(prom->data_pins) ; i++)
 259:prom.c        **** 	{
 260:prom.c        **** 		uint8_t pin = prom_pin(prom->data_pins[i]);
 261:prom.c        **** 		if (pin == 0)
 262:prom.c        **** 			continue;
 263:prom.c        **** 		if ((prom->options & OPTIONS_PULLUPS) != 0) {
 264:prom.c        **** 			out(pin, 1);
 265:prom.c        **** 		} else {
 266:prom.c        **** 			out(pin, 0);
 267:prom.c        **** 		}
 268:prom.c        **** 		ddr(pin, 0);
 269:prom.c        **** 	}
 270:prom.c        **** 
 271:prom.c        **** 	// Configure all of the hi and low pins as outputs.
 272:prom.c        **** 	// Do the low pins first to bring them to ground potential,
 273:prom.c        **** 	// then the high pins.
 274:prom.c        **** 	for (uint8_t i = 0 ; i < array_count(prom->lo_pins) ; i++)
 275:prom.c        **** 	{
 276:prom.c        **** 		uint8_t pin = prom_pin(prom->lo_pins[i]);
 277:prom.c        **** 		if (pin == 0)
 278:prom.c        **** 			continue;
 279:prom.c        **** 		out(pin, 0);
 280:prom.c        **** 		ddr(pin, 1);
 281:prom.c        **** 	}
 282:prom.c        **** 
 283:prom.c        **** 	for (uint8_t i = 0 ; i < array_count(prom->hi_pins) ; i++)
 284:prom.c        **** 	{
 285:prom.c        **** 		uint8_t pin = prom_pin(prom->hi_pins[i]);
 286:prom.c        **** 		if (pin == 0)
 287:prom.c        **** 			continue;
 288:prom.c        **** 		out(pin, 1);
 289:prom.c        **** 		ddr(pin, 1);
 290:prom.c        **** 	}
 291:prom.c        **** 
 292:prom.c        **** 
 293:prom.c        **** 	// Let things stabilize for a little while
 294:prom.c        **** 	_delay_ms(250);
 295:prom.c        **** 
 296:prom.c        **** 	// If this is an AVR ISP chip, try to go into programming mode
 297:prom.c        **** 	if (prom->data_width == 0)
 298:prom.c        **** 		isp_setup();
 299:prom.c        **** }
 300:prom.c        **** 
 301:prom.c        **** 
 302:prom.c        **** /** Switch all of the ZIF pins back to tri-state to make it safe.
 303:prom.c        ****  * Doesn't matter what PROM is inserted.
 304:prom.c        ****  */
 305:prom.c        **** static void
 306:prom.c        **** prom_tristate(void)
 307:prom.c        **** {
  85               		.loc 1 307 0
  86               		.cfi_startproc
  87 0000 1F93      		push r17
  88               	.LCFI0:
  89               		.cfi_def_cfa_offset 3
  90               		.cfi_offset 17, -2
  91 0002 CF93      		push r28
  92               	.LCFI1:
  93               		.cfi_def_cfa_offset 4
  94               		.cfi_offset 28, -3
  95 0004 DF93      		push r29
  96               	.LCFI2:
  97               		.cfi_def_cfa_offset 5
  98               		.cfi_offset 29, -4
  99               	/* prologue: function */
 100               	/* frame size = 0 */
 101               	/* stack size = 3 */
 102               	.L__stack_usage = 3
 103               	.LVL7:
 104 0006 C0E0      		ldi r28,lo8(ports+1)
 105 0008 D0E0      		ldi r29,hi8(ports+1)
 106               	.LVL8:
 107               	.L10:
 108               	.LBB29:
 308:prom.c        **** 	for (uint8_t i = 1 ; i <= ZIF_PINS ; i++)
 309:prom.c        **** 	{
 310:prom.c        **** 		ddr(ports[i], 0);
 109               		.loc 1 310 0 discriminator 3
 110 000a 1991      		ld r17,Y+
 111               	.LVL9:
 112 000c 60E0      		ldi r22,0
 113 000e 812F      		mov r24,r17
 114 0010 0E94 0000 		call ddr
 115               	.LVL10:
 311:prom.c        **** 		out(ports[i], 0);
 116               		.loc 1 311 0 discriminator 3
 117 0014 60E0      		ldi r22,0
 118 0016 812F      		mov r24,r17
 119 0018 0E94 0000 		call out
 120               	.LVL11:
 308:prom.c        **** 	for (uint8_t i = 1 ; i <= ZIF_PINS ; i++)
 121               		.loc 1 308 0 discriminator 3
 122 001c 80E0      		ldi r24,hi8(ports+41)
 123 001e C030      		cpi r28,lo8(ports+41)
 124 0020 D807      		cpc r29,r24
 125 0022 01F4      		brne .L10
 126               	/* epilogue start */
 127               	.LBE29:
 312:prom.c        **** 	}
 313:prom.c        **** }
 128               		.loc 1 313 0
 129 0024 DF91      		pop r29
 130 0026 CF91      		pop r28
 131               	.LVL12:
 132 0028 1F91      		pop r17
 133 002a 0895      		ret
 134               		.cfi_endproc
 135               	.LFE15:
 137               		.section	.text.isp_clock,"ax",@progbits
 139               	isp_clock:
 140               	.LFB10:
 128:prom.c        **** 	const uint8_t xtal = prom_pin(prom->addr_pins[ISP_XTAL]);
 141               		.loc 1 128 0
 142               		.cfi_startproc
 143               	.LVL13:
 144 0000 1F93      		push r17
 145               	.LCFI3:
 146               		.cfi_def_cfa_offset 3
 147               		.cfi_offset 17, -2
 148 0002 CF93      		push r28
 149               	.LCFI4:
 150               		.cfi_def_cfa_offset 4
 151               		.cfi_offset 28, -3
 152 0004 DF93      		push r29
 153               	.LCFI5:
 154               		.cfi_def_cfa_offset 5
 155               		.cfi_offset 29, -4
 156               	/* prologue: function */
 157               	/* frame size = 0 */
 158               	/* stack size = 3 */
 159               	.L__stack_usage = 3
 160 0006 182F      		mov r17,r24
 129:prom.c        **** 	for (uint8_t i = 0 ; i < cycles ; i++)
 161               		.loc 1 129 0
 162 0008 E091 0000 		lds r30,prom
 163 000c F091 0000 		lds r31,prom+1
 164 0010 8789      		ldd r24,Z+23
 165               	.LVL14:
 166 0012 0E94 0000 		call prom_pin
 167               	.LVL15:
 168 0016 D82F      		mov r29,r24
 169               	.LVL16:
 170               	.LBB30:
 130:prom.c        **** 	{
 171               		.loc 1 130 0
 172 0018 C0E0      		ldi r28,0
 173               	.LVL17:
 174               	.L13:
 130:prom.c        **** 	{
 175               		.loc 1 130 0 is_stmt 0 discriminator 1
 176 001a C117      		cp r28,r17
 177 001c 01F0      		breq .L15
 132:prom.c        **** 		_delay_us(1);
 178               		.loc 1 132 0 is_stmt 1 discriminator 3
 179 001e 61E0      		ldi r22,lo8(1)
 180 0020 8D2F      		mov r24,r29
 181 0022 0E94 0000 		call out
 182               	.LVL18:
 183               	.LBB31:
 184               	.LBB32:
 185               		.file 2 "/usr/lib/avr/include/util/delay.h"
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/lib/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/lib/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/lib/avr/include/util/delay.h **** #  endif
  42:/usr/lib/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/lib/avr/include/util/delay.h **** 
  44:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  47:/usr/lib/avr/include/util/delay.h **** 
  48:/usr/lib/avr/include/util/delay.h **** /** \file */
  49:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/lib/avr/include/util/delay.h ****     \code
  51:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/lib/avr/include/util/delay.h ****     \endcode
  55:/usr/lib/avr/include/util/delay.h **** 
  56:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/lib/avr/include/util/delay.h ****     used.
  60:/usr/lib/avr/include/util/delay.h **** 
  61:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/lib/avr/include/util/delay.h **** 
  70:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/lib/avr/include/util/delay.h **** 
  79:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** */
  84:/usr/lib/avr/include/util/delay.h **** 
  85:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/lib/avr/include/util/delay.h **** #endif
  89:/usr/lib/avr/include/util/delay.h **** 
  90:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/lib/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/lib/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/lib/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/lib/avr/include/util/delay.h **** 
  97:/usr/lib/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/lib/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/lib/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/lib/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/lib/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/lib/avr/include/util/delay.h **** 
 103:/usr/lib/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/lib/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/lib/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/lib/avr/include/util/delay.h ****     integer value.
 107:/usr/lib/avr/include/util/delay.h ****  */
 108:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/lib/avr/include/util/delay.h **** #endif
 110:/usr/lib/avr/include/util/delay.h **** 
 111:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/lib/avr/include/util/delay.h **** #endif
 114:/usr/lib/avr/include/util/delay.h **** 
 115:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/lib/avr/include/util/delay.h **** #endif
 120:/usr/lib/avr/include/util/delay.h **** 
 121:/usr/lib/avr/include/util/delay.h **** /**
 122:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/lib/avr/include/util/delay.h **** 
 124:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/lib/avr/include/util/delay.h **** 
 126:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/lib/avr/include/util/delay.h **** 
 131:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/lib/avr/include/util/delay.h **** 
 137:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/lib/avr/include/util/delay.h **** 
 142:/usr/lib/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/lib/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/lib/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/lib/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/lib/avr/include/util/delay.h **** 
 147:/usr/lib/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/lib/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/lib/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/lib/avr/include/util/delay.h ****    respectively.
 151:/usr/lib/avr/include/util/delay.h **** 
 152:/usr/lib/avr/include/util/delay.h ****    \note
 153:/usr/lib/avr/include/util/delay.h **** 
 154:/usr/lib/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/lib/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/lib/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/lib/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/lib/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/lib/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/lib/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/lib/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/lib/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/lib/avr/include/util/delay.h **** 
 164:/usr/lib/avr/include/util/delay.h ****  */
 165:/usr/lib/avr/include/util/delay.h **** void
 166:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 167:/usr/lib/avr/include/util/delay.h **** {
 168:/usr/lib/avr/include/util/delay.h **** 	double __tmp ;
 169:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/usr/lib/avr/include/util/delay.h **** 
 176:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/lib/avr/include/util/delay.h **** 
 179:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/lib/avr/include/util/delay.h **** 
 182:/usr/lib/avr/include/util/delay.h **** 	#else
 183:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 184:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/usr/lib/avr/include/util/delay.h **** 	#endif
 186:/usr/lib/avr/include/util/delay.h **** 
 187:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 188:/usr/lib/avr/include/util/delay.h **** 
 189:/usr/lib/avr/include/util/delay.h **** #else
 190:/usr/lib/avr/include/util/delay.h **** 	uint16_t __ticks;
 191:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 192:/usr/lib/avr/include/util/delay.h **** 	if (__tmp < 1.0)
 193:/usr/lib/avr/include/util/delay.h **** 		__ticks = 1;
 194:/usr/lib/avr/include/util/delay.h **** 	else if (__tmp > 65535)
 195:/usr/lib/avr/include/util/delay.h **** 	{
 196:/usr/lib/avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 197:/usr/lib/avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 198:/usr/lib/avr/include/util/delay.h **** 		while(__ticks)
 199:/usr/lib/avr/include/util/delay.h **** 		{
 200:/usr/lib/avr/include/util/delay.h **** 			// wait 1/10 ms
 201:/usr/lib/avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 202:/usr/lib/avr/include/util/delay.h **** 			__ticks --;
 203:/usr/lib/avr/include/util/delay.h **** 		}
 204:/usr/lib/avr/include/util/delay.h **** 		return;
 205:/usr/lib/avr/include/util/delay.h **** 	}
 206:/usr/lib/avr/include/util/delay.h **** 	else
 207:/usr/lib/avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 208:/usr/lib/avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 209:/usr/lib/avr/include/util/delay.h **** #endif
 210:/usr/lib/avr/include/util/delay.h **** }
 211:/usr/lib/avr/include/util/delay.h **** 
 212:/usr/lib/avr/include/util/delay.h **** /**
 213:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 214:/usr/lib/avr/include/util/delay.h **** 
 215:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 216:/usr/lib/avr/include/util/delay.h **** 
 217:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 218:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 219:/usr/lib/avr/include/util/delay.h **** 
 220:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 221:/usr/lib/avr/include/util/delay.h **** 
 222:/usr/lib/avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 223:/usr/lib/avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 224:/usr/lib/avr/include/util/delay.h ****    will not be informed about this case.
 225:/usr/lib/avr/include/util/delay.h **** 
 226:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 227:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 228:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 229:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0us.
 230:/usr/lib/avr/include/util/delay.h **** 
 231:/usr/lib/avr/include/util/delay.h ****    Conversion of \c __us into clock cycles may not always result in
 232:/usr/lib/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 233:/usr/lib/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __us
 234:/usr/lib/avr/include/util/delay.h ****    microseconds of delay.
 235:/usr/lib/avr/include/util/delay.h **** 
 236:/usr/lib/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 237:/usr/lib/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 238:/usr/lib/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 239:/usr/lib/avr/include/util/delay.h ****    respectively.
 240:/usr/lib/avr/include/util/delay.h **** 
 241:/usr/lib/avr/include/util/delay.h ****    \note
 242:/usr/lib/avr/include/util/delay.h **** 
 243:/usr/lib/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 244:/usr/lib/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 245:/usr/lib/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 246:/usr/lib/avr/include/util/delay.h ****    with previous versions, the macro \c __DELAY_BACKWARD_COMPATIBLE__
 247:/usr/lib/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 248:/usr/lib/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 249:/usr/lib/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 250:/usr/lib/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 251:/usr/lib/avr/include/util/delay.h ****    not available to the compiler then.
 252:/usr/lib/avr/include/util/delay.h **** 
 253:/usr/lib/avr/include/util/delay.h ****  */
 254:/usr/lib/avr/include/util/delay.h **** void
 255:/usr/lib/avr/include/util/delay.h **** _delay_us(double __us)
 256:/usr/lib/avr/include/util/delay.h **** {
 257:/usr/lib/avr/include/util/delay.h **** 	double __tmp ;
 258:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 259:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 260:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 261:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 262:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 263:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 264:/usr/lib/avr/include/util/delay.h **** 
 265:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 266:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 267:/usr/lib/avr/include/util/delay.h **** 
 268:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 269:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 270:/usr/lib/avr/include/util/delay.h **** 
 271:/usr/lib/avr/include/util/delay.h **** 	#else
 272:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 273:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 274:/usr/lib/avr/include/util/delay.h **** 	#endif
 275:/usr/lib/avr/include/util/delay.h **** 
 276:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 186               		.loc 2 276 0 discriminator 3
 187 0026 85E0      		ldi r24,lo8(5)
 188 0028 8A95      	1:	dec r24
 189 002a 01F4      		brne 1b
 190 002c 0000      		nop
 191               	.LVL19:
 192               	.LBE32:
 193               	.LBE31:
 134:prom.c        **** 		_delay_us(1);
 194               		.loc 1 134 0 discriminator 3
 195 002e 60E0      		ldi r22,0
 196 0030 8D2F      		mov r24,r29
 197 0032 0E94 0000 		call out
 198               	.LVL20:
 199               	.LBB33:
 200               	.LBB34:
 201               		.loc 2 276 0 discriminator 3
 202 0036 85E0      		ldi r24,lo8(5)
 203 0038 8A95      	1:	dec r24
 204 003a 01F4      		brne 1b
 205 003c 0000      		nop
 206               	.LVL21:
 207               	.LBE34:
 208               	.LBE33:
 130:prom.c        **** 	{
 209               		.loc 1 130 0 discriminator 3
 210 003e CF5F      		subi r28,lo8(-(1))
 211               	.LVL22:
 212 0040 00C0      		rjmp .L13
 213               	.L15:
 214               	/* epilogue start */
 215               	.LBE30:
 137:prom.c        **** 
 216               		.loc 1 137 0
 217 0042 DF91      		pop r29
 218               	.LVL23:
 219 0044 CF91      		pop r28
 220               	.LVL24:
 221 0046 1F91      		pop r17
 222               	.LVL25:
 223 0048 0895      		ret
 224               		.cfi_endproc
 225               	.LFE10:
 227               		.section	.text.isp_write,"ax",@progbits
 229               	isp_write:
 230               	.LFB11:
 147:prom.c        **** 	const uint8_t mosi = prom_pin(prom->addr_pins[ISP_MOSI]);
 231               		.loc 1 147 0
 232               		.cfi_startproc
 233               	.LVL26:
 234 0000 DF92      		push r13
 235               	.LCFI6:
 236               		.cfi_def_cfa_offset 3
 237               		.cfi_offset 13, -2
 238 0002 EF92      		push r14
 239               	.LCFI7:
 240               		.cfi_def_cfa_offset 4
 241               		.cfi_offset 14, -3
 242 0004 FF92      		push r15
 243               	.LCFI8:
 244               		.cfi_def_cfa_offset 5
 245               		.cfi_offset 15, -4
 246 0006 0F93      		push r16
 247               	.LCFI9:
 248               		.cfi_def_cfa_offset 6
 249               		.cfi_offset 16, -5
 250 0008 1F93      		push r17
 251               	.LCFI10:
 252               		.cfi_def_cfa_offset 7
 253               		.cfi_offset 17, -6
 254 000a CF93      		push r28
 255               	.LCFI11:
 256               		.cfi_def_cfa_offset 8
 257               		.cfi_offset 28, -7
 258 000c DF93      		push r29
 259               	.LCFI12:
 260               		.cfi_def_cfa_offset 9
 261               		.cfi_offset 29, -8
 262               	/* prologue: function */
 263               	/* frame size = 0 */
 264               	/* stack size = 7 */
 265               	.L__stack_usage = 7
 266 000e 182F      		mov r17,r24
 148:prom.c        **** 	const uint8_t sck = prom_pin(prom->addr_pins[ISP_SCK]);
 267               		.loc 1 148 0
 268 0010 C091 0000 		lds r28,prom
 269 0014 D091 0000 		lds r29,prom+1
 270 0018 8C89      		ldd r24,Y+20
 271               	.LVL27:
 272 001a 0E94 0000 		call prom_pin
 273               	.LVL28:
 274 001e E82E      		mov r14,r24
 275               	.LVL29:
 149:prom.c        **** 	const uint8_t miso = prom_pin(prom->data_pins[ISP_MISO]);
 276               		.loc 1 149 0
 277 0020 8D89      		ldd r24,Y+21
 278 0022 0E94 0000 		call prom_pin
 279               	.LVL30:
 280 0026 082F      		mov r16,r24
 281               	.LVL31:
 150:prom.c        **** 	uint8_t rc = 0;
 282               		.loc 1 150 0
 283 0028 8CA5      		ldd r24,Y+44
 284 002a 0E94 0000 		call prom_pin
 285               	.LVL32:
 286 002e D82E      		mov r13,r24
 287               	.LVL33:
 288 0030 D8E0      		ldi r29,lo8(8)
 151:prom.c        **** 
 289               		.loc 1 151 0
 290 0032 F12C      		mov r15,__zero_reg__
 291               	.LVL34:
 292               	.L18:
 293               	.LBB35:
 155:prom.c        **** 		isp_clock(4);
 294               		.loc 1 155 0 discriminator 3
 295 0034 612F      		mov r22,r17
 296 0036 661F      		rol r22
 297 0038 6627      		clr r22
 298 003a 661F      		rol r22
 299 003c 8E2D      		mov r24,r14
 300 003e 0E94 0000 		call out
 301               	.LVL35:
 156:prom.c        **** 
 302               		.loc 1 156 0 discriminator 3
 303 0042 84E0      		ldi r24,lo8(4)
 304 0044 0E94 0000 		call isp_clock
 305               	.LVL36:
 158:prom.c        **** 		isp_clock(4);
 306               		.loc 1 158 0 discriminator 3
 307 0048 61E0      		ldi r22,lo8(1)
 308 004a 802F      		mov r24,r16
 309 004c 0E94 0000 		call out
 310               	.LVL37:
 159:prom.c        **** 
 311               		.loc 1 159 0 discriminator 3
 312 0050 84E0      		ldi r24,lo8(4)
 313 0052 0E94 0000 		call isp_clock
 314               	.LVL38:
 161:prom.c        **** 		out(sck, 0);
 315               		.loc 1 161 0 discriminator 3
 316 0056 8D2D      		mov r24,r13
 317 0058 0E94 0000 		call in
 318               	.LVL39:
 319 005c 2F2D      		mov r18,r15
 320 005e 30E0      		ldi r19,0
 321 0060 220F      		lsl r18
 322 0062 331F      		rol r19
 323 0064 C1E0      		ldi r28,lo8(1)
 324 0066 8111      		cpse r24,__zero_reg__
 325 0068 00C0      		rjmp .L17
 326 006a C0E0      		ldi r28,0
 327               	.L17:
 328 006c C22B      		or r28,r18
 329 006e FC2E      		mov r15,r28
 330               	.LVL40:
 162:prom.c        **** 	}
 331               		.loc 1 162 0 discriminator 3
 332 0070 60E0      		ldi r22,0
 333 0072 802F      		mov r24,r16
 334 0074 0E94 0000 		call out
 335               	.LVL41:
 153:prom.c        **** 	{
 336               		.loc 1 153 0 discriminator 3
 337 0078 110F      		lsl r17
 338               	.LVL42:
 339 007a D150      		subi r29,lo8(-(-1))
 340               	.LVL43:
 341 007c 01F4      		brne .L18
 342               	.LBE35:
 166:prom.c        **** 
 343               		.loc 1 166 0
 344 007e 8C2F      		mov r24,r28
 345               	/* epilogue start */
 346 0080 DF91      		pop r29
 347               	.LVL44:
 348 0082 CF91      		pop r28
 349 0084 1F91      		pop r17
 350               	.LVL45:
 351 0086 0F91      		pop r16
 352               	.LVL46:
 353 0088 FF90      		pop r15
 354               	.LVL47:
 355 008a EF90      		pop r14
 356               	.LVL48:
 357 008c DF90      		pop r13
 358               	.LVL49:
 359 008e 0895      		ret
 360               		.cfi_endproc
 361               	.LFE11:
 363               		.section	.text.prom_setup,"ax",@progbits
 365               	prom_setup:
 366               	.LFB14:
 244:prom.c        **** 	// Configure all of the address pins as outputs,
 367               		.loc 1 244 0
 368               		.cfi_startproc
 369 0000 CF92      		push r12
 370               	.LCFI13:
 371               		.cfi_def_cfa_offset 3
 372               		.cfi_offset 12, -2
 373 0002 DF92      		push r13
 374               	.LCFI14:
 375               		.cfi_def_cfa_offset 4
 376               		.cfi_offset 13, -3
 377 0004 EF92      		push r14
 378               	.LCFI15:
 379               		.cfi_def_cfa_offset 5
 380               		.cfi_offset 14, -4
 381 0006 FF92      		push r15
 382               	.LCFI16:
 383               		.cfi_def_cfa_offset 6
 384               		.cfi_offset 15, -5
 385 0008 0F93      		push r16
 386               	.LCFI17:
 387               		.cfi_def_cfa_offset 7
 388               		.cfi_offset 16, -6
 389 000a 1F93      		push r17
 390               	.LCFI18:
 391               		.cfi_def_cfa_offset 8
 392               		.cfi_offset 17, -7
 393 000c CF93      		push r28
 394               	.LCFI19:
 395               		.cfi_def_cfa_offset 9
 396               		.cfi_offset 28, -8
 397 000e DF93      		push r29
 398               	.LCFI20:
 399               		.cfi_def_cfa_offset 10
 400               		.cfi_offset 29, -9
 401 0010 CDB7      		in r28,__SP_L__
 402 0012 DEB7      		in r29,__SP_H__
 403               	.LCFI21:
 404               		.cfi_def_cfa_register 28
 405 0014 2A97      		sbiw r28,10
 406               	.LCFI22:
 407               		.cfi_def_cfa_offset 20
 408 0016 0FB6      		in __tmp_reg__,__SREG__
 409 0018 F894      		cli
 410 001a DEBF      		out __SP_H__,r29
 411 001c 0FBE      		out __SREG__,__tmp_reg__
 412 001e CDBF      		out __SP_L__,r28
 413               	/* prologue: function */
 414               	/* frame size = 10 */
 415               	/* stack size = 18 */
 416               	.L__stack_usage = 18
 417               	.LVL50:
 244:prom.c        **** 	// Configure all of the address pins as outputs,
 418               		.loc 1 244 0
 419 0020 00E0      		ldi r16,0
 420 0022 10E0      		ldi r17,0
 421               	.LVL51:
 422               	.L22:
 423               	.LBB50:
 424               	.LBB51:
 249:prom.c        **** 		if (pin == 0)
 425               		.loc 1 249 0
 426 0024 E091 0000 		lds r30,prom
 427 0028 F091 0000 		lds r31,prom+1
 428 002c E00F      		add r30,r16
 429 002e F11F      		adc r31,r17
 430 0030 8489      		ldd r24,Z+20
 431 0032 0E94 0000 		call prom_pin
 432               	.LVL52:
 433 0036 F82E      		mov r15,r24
 434               	.LVL53:
 250:prom.c        **** 			continue;
 435               		.loc 1 250 0
 436 0038 8823      		tst r24
 437 003a 01F0      		breq .L21
 252:prom.c        **** 		ddr(pin, 1);
 438               		.loc 1 252 0
 439 003c 60E0      		ldi r22,0
 440 003e 0E94 0000 		call out
 441               	.LVL54:
 253:prom.c        **** 	}
 442               		.loc 1 253 0
 443 0042 61E0      		ldi r22,lo8(1)
 444 0044 8F2D      		mov r24,r15
 445 0046 0E94 0000 		call ddr
 446               	.LVL55:
 447               	.L21:
 448 004a 0F5F      		subi r16,-1
 449 004c 1F4F      		sbci r17,-1
 450               	.LVL56:
 451               	.LBE51:
 247:prom.c        **** 	{
 452               		.loc 1 247 0 discriminator 2
 453 004e 0831      		cpi r16,24
 454 0050 1105      		cpc r17,__zero_reg__
 455 0052 01F4      		brne .L22
 456 0054 00E0      		ldi r16,0
 457 0056 10E0      		ldi r17,0
 458               	.LVL57:
 459               	.L26:
 460               	.LBE50:
 461               	.LBB52:
 462               	.LBB53:
 260:prom.c        **** 		if (pin == 0)
 463               		.loc 1 260 0
 464 0058 C090 0000 		lds r12,prom
 465 005c D090 0000 		lds r13,prom+1
 466 0060 F601      		movw r30,r12
 467 0062 E00F      		add r30,r16
 468 0064 F11F      		adc r31,r17
 469 0066 84A5      		ldd r24,Z+44
 470 0068 0E94 0000 		call prom_pin
 471               	.LVL58:
 472 006c F82E      		mov r15,r24
 473               	.LVL59:
 261:prom.c        **** 			continue;
 474               		.loc 1 261 0
 475 006e 8823      		tst r24
 476 0070 01F0      		breq .L23
 263:prom.c        **** 			out(pin, 1);
 477               		.loc 1 263 0
 478 0072 F601      		movw r30,r12
 479 0074 8089      		ldd r24,Z+16
 480 0076 80FF      		sbrs r24,0
 481 0078 00C0      		rjmp .L24
 264:prom.c        **** 		} else {
 482               		.loc 1 264 0
 483 007a 61E0      		ldi r22,lo8(1)
 484 007c 00C0      		rjmp .L52
 485               	.L24:
 266:prom.c        **** 		}
 486               		.loc 1 266 0
 487 007e 60E0      		ldi r22,0
 488               	.L52:
 489 0080 8F2D      		mov r24,r15
 490 0082 0E94 0000 		call out
 491               	.LVL60:
 268:prom.c        **** 	}
 492               		.loc 1 268 0
 493 0086 60E0      		ldi r22,0
 494 0088 8F2D      		mov r24,r15
 495 008a 0E94 0000 		call ddr
 496               	.LVL61:
 497               	.L23:
 498 008e 0F5F      		subi r16,-1
 499 0090 1F4F      		sbci r17,-1
 500               	.LVL62:
 501               	.LBE53:
 258:prom.c        **** 	{
 502               		.loc 1 258 0 discriminator 2
 503 0092 0831      		cpi r16,24
 504 0094 1105      		cpc r17,__zero_reg__
 505 0096 01F4      		brne .L26
 506 0098 00E0      		ldi r16,0
 507 009a 10E0      		ldi r17,0
 508               	.LVL63:
 509               	.L28:
 510               	.LBE52:
 511               	.LBB54:
 512               	.LBB55:
 276:prom.c        **** 		if (pin == 0)
 513               		.loc 1 276 0
 514 009c E091 0000 		lds r30,prom
 515 00a0 F091 0000 		lds r31,prom+1
 516 00a4 E00F      		add r30,r16
 517 00a6 F11F      		adc r31,r17
 518 00a8 E45B      		subi r30,-76
 519 00aa FF4F      		sbci r31,-1
 520 00ac 8081      		ld r24,Z
 521 00ae 0E94 0000 		call prom_pin
 522               	.LVL64:
 523 00b2 F82E      		mov r15,r24
 524               	.LVL65:
 277:prom.c        **** 			continue;
 525               		.loc 1 277 0
 526 00b4 8823      		tst r24
 527 00b6 01F0      		breq .L27
 279:prom.c        **** 		ddr(pin, 1);
 528               		.loc 1 279 0
 529 00b8 60E0      		ldi r22,0
 530 00ba 0E94 0000 		call out
 531               	.LVL66:
 280:prom.c        **** 	}
 532               		.loc 1 280 0
 533 00be 61E0      		ldi r22,lo8(1)
 534 00c0 8F2D      		mov r24,r15
 535 00c2 0E94 0000 		call ddr
 536               	.LVL67:
 537               	.L27:
 538 00c6 0F5F      		subi r16,-1
 539 00c8 1F4F      		sbci r17,-1
 540               	.LVL68:
 541               	.LBE55:
 274:prom.c        **** 	{
 542               		.loc 1 274 0 discriminator 2
 543 00ca 0830      		cpi r16,8
 544 00cc 1105      		cpc r17,__zero_reg__
 545 00ce 01F4      		brne .L28
 546 00d0 00E0      		ldi r16,0
 547 00d2 10E0      		ldi r17,0
 548               	.LVL69:
 549               	.L30:
 550               	.LBE54:
 551               	.LBB56:
 552               	.LBB57:
 285:prom.c        **** 		if (pin == 0)
 553               		.loc 1 285 0
 554 00d4 E091 0000 		lds r30,prom
 555 00d8 F091 0000 		lds r31,prom+1
 556 00dc E00F      		add r30,r16
 557 00de F11F      		adc r31,r17
 558 00e0 EC5B      		subi r30,-68
 559 00e2 FF4F      		sbci r31,-1
 560 00e4 8081      		ld r24,Z
 561 00e6 0E94 0000 		call prom_pin
 562               	.LVL70:
 563 00ea F82E      		mov r15,r24
 564               	.LVL71:
 286:prom.c        **** 			continue;
 565               		.loc 1 286 0
 566 00ec 8823      		tst r24
 567 00ee 01F0      		breq .L29
 288:prom.c        **** 		ddr(pin, 1);
 568               		.loc 1 288 0
 569 00f0 61E0      		ldi r22,lo8(1)
 570 00f2 0E94 0000 		call out
 571               	.LVL72:
 289:prom.c        **** 	}
 572               		.loc 1 289 0
 573 00f6 61E0      		ldi r22,lo8(1)
 574 00f8 8F2D      		mov r24,r15
 575 00fa 0E94 0000 		call ddr
 576               	.LVL73:
 577               	.L29:
 578 00fe 0F5F      		subi r16,-1
 579 0100 1F4F      		sbci r17,-1
 580               	.LVL74:
 581               	.LBE57:
 283:prom.c        **** 	{
 582               		.loc 1 283 0 discriminator 2
 583 0102 0830      		cpi r16,8
 584 0104 1105      		cpc r17,__zero_reg__
 585 0106 01F4      		brne .L30
 586               	.LVL75:
 587               	.LBE56:
 588               	.LBB58:
 589               	.LBB59:
 187:/usr/lib/avr/include/util/delay.h **** 
 590               		.loc 2 187 0
 591 0108 FFEF      		ldi r31,lo8(799999)
 592 010a 24E3      		ldi r18,hi8(799999)
 593 010c 8CE0      		ldi r24,hlo8(799999)
 594 010e F150      	1:	subi r31,1
 595 0110 2040      		sbci r18,0
 596 0112 8040      		sbci r24,0
 597 0114 01F4      		brne 1b
 598 0116 00C0      		rjmp .
 599 0118 0000      		nop
 600               	.LVL76:
 601               	.LBE59:
 602               	.LBE58:
 297:prom.c        **** 		isp_setup();
 603               		.loc 1 297 0
 604 011a 0091 0000 		lds r16,prom
 605 011e 1091 0000 		lds r17,prom+1
 606               	.LVL77:
 607 0122 F801      		movw r30,r16
 608 0124 8389      		ldd r24,Z+19
 609 0126 8111      		cpse r24,__zero_reg__
 610 0128 00C0      		rjmp .L20
 611               	.LBB60:
 612               	.LBB61:
 176:prom.c        **** 	const uint8_t reset = prom_pin(prom->addr_pins[ISP_RESET]);
 613               		.loc 1 176 0
 614 012a 8589      		ldd r24,Z+21
 615 012c 0E94 0000 		call prom_pin
 616               	.LVL78:
 617 0130 E82E      		mov r14,r24
 618               	.LVL79:
 177:prom.c        **** 	const uint8_t miso = prom_pin(prom->data_pins[ISP_MISO]);
 619               		.loc 1 177 0
 620 0132 F801      		movw r30,r16
 621 0134 8689      		ldd r24,Z+22
 622 0136 0E94 0000 		call prom_pin
 623               	.LVL80:
 624 013a F82E      		mov r15,r24
 625               	.LVL81:
 178:prom.c        **** 	out(sck, 0);
 626               		.loc 1 178 0
 627 013c F801      		movw r30,r16
 628 013e 84A5      		ldd r24,Z+44
 629 0140 0E94 0000 		call prom_pin
 630               	.LVL82:
 631 0144 D82E      		mov r13,r24
 632               	.LVL83:
 179:prom.c        **** 	out(reset, 1);
 633               		.loc 1 179 0
 634 0146 60E0      		ldi r22,0
 635 0148 8E2D      		mov r24,r14
 636 014a 0E94 0000 		call out
 637               	.LVL84:
 180:prom.c        **** 	isp_clock(4);
 638               		.loc 1 180 0
 639 014e 61E0      		ldi r22,lo8(1)
 640 0150 8F2D      		mov r24,r15
 641 0152 0E94 0000 		call out
 642               	.LVL85:
 181:prom.c        **** 	out(reset, 0);
 643               		.loc 1 181 0
 644 0156 84E0      		ldi r24,lo8(4)
 645 0158 0E94 0000 		call isp_clock
 646               	.LVL86:
 182:prom.c        **** 	isp_clock(255);
 647               		.loc 1 182 0
 648 015c 60E0      		ldi r22,0
 649 015e 8F2D      		mov r24,r15
 650 0160 0E94 0000 		call out
 651               	.LVL87:
 183:prom.c        **** 
 652               		.loc 1 183 0
 653 0164 8FEF      		ldi r24,lo8(-1)
 654 0166 0E94 0000 		call isp_clock
 655               	.LVL88:
 656               	.LBB62:
 657               	.LBB63:
 187:/usr/lib/avr/include/util/delay.h **** 
 658               		.loc 2 187 0
 659 016a FFEF      		ldi r31,lo8(63999)
 660 016c 29EF      		ldi r18,hi8(63999)
 661 016e 80E0      		ldi r24,hlo8(63999)
 662 0170 F150      	1:	subi r31,1
 663 0172 2040      		sbci r18,0
 664 0174 8040      		sbci r24,0
 665 0176 01F4      		brne 1b
 666 0178 00C0      		rjmp .
 667 017a 0000      		nop
 668               	.LVL89:
 669               	.LBE63:
 670               	.LBE62:
 191:prom.c        **** 
 671               		.loc 1 191 0
 672 017c 61E0      		ldi r22,lo8(1)
 673 017e 8D2D      		mov r24,r13
 674 0180 0E94 0000 		call out
 675               	.LVL90:
 193:prom.c        **** 	rc2 = isp_write(0x53);
 676               		.loc 1 193 0
 677 0184 8CEA      		ldi r24,lo8(-84)
 678 0186 0E94 0000 		call isp_write
 679               	.LVL91:
 680 018a E82E      		mov r14,r24
 681               	.LVL92:
 194:prom.c        **** 	rc3 = isp_write(0x12);
 682               		.loc 1 194 0
 683 018c 83E5      		ldi r24,lo8(83)
 684 018e 0E94 0000 		call isp_write
 685               	.LVL93:
 686 0192 F82E      		mov r15,r24
 687               	.LVL94:
 195:prom.c        **** 	rc4 = isp_write(0x34);
 688               		.loc 1 195 0
 689 0194 82E1      		ldi r24,lo8(18)
 690 0196 0E94 0000 		call isp_write
 691               	.LVL95:
 692 019a 182F      		mov r17,r24
 693               	.LVL96:
 196:prom.c        **** 
 694               		.loc 1 196 0
 695 019c 84E3      		ldi r24,lo8(52)
 696 019e 0E94 0000 		call isp_write
 697               	.LVL97:
 698 01a2 082F      		mov r16,r24
 699               	.LVL98:
 199:prom.c        **** 
 700               		.loc 1 199 0
 701 01a4 60E0      		ldi r22,0
 702 01a6 8D2D      		mov r24,r13
 703 01a8 0E94 0000 		call out
 704               	.LVL99:
 201:prom.c        **** 		return 1;
 705               		.loc 1 201 0
 706 01ac 1335      		cpi r17,lo8(83)
 707 01ae 01F0      		breq .L20
 206:prom.c        **** 	buf[1] = hexdigit(rc1 >> 0);
 708               		.loc 1 206 0
 709 01b0 8E2D      		mov r24,r14
 710 01b2 8295      		swap r24
 711 01b4 8F70      		andi r24,lo8(15)
 712 01b6 0E94 0000 		call hexdigit
 713               	.LVL100:
 714 01ba 8983      		std Y+1,r24
 207:prom.c        **** 	buf[2] = hexdigit(rc2 >> 4);
 715               		.loc 1 207 0
 716 01bc 8E2D      		mov r24,r14
 717 01be 0E94 0000 		call hexdigit
 718               	.LVL101:
 719 01c2 8A83      		std Y+2,r24
 208:prom.c        **** 	buf[3] = hexdigit(rc2 >> 0);
 720               		.loc 1 208 0
 721 01c4 8F2D      		mov r24,r15
 722 01c6 8295      		swap r24
 723 01c8 8F70      		andi r24,lo8(15)
 724 01ca 0E94 0000 		call hexdigit
 725               	.LVL102:
 726 01ce 8B83      		std Y+3,r24
 209:prom.c        **** 	buf[4] = hexdigit(rc3 >> 4);
 727               		.loc 1 209 0
 728 01d0 8F2D      		mov r24,r15
 729 01d2 0E94 0000 		call hexdigit
 730               	.LVL103:
 731 01d6 8C83      		std Y+4,r24
 210:prom.c        **** 	buf[5] = hexdigit(rc3 >> 0);
 732               		.loc 1 210 0
 733 01d8 812F      		mov r24,r17
 734 01da 8295      		swap r24
 735 01dc 8F70      		andi r24,lo8(15)
 736 01de 0E94 0000 		call hexdigit
 737               	.LVL104:
 738 01e2 8D83      		std Y+5,r24
 211:prom.c        **** 	buf[6] = hexdigit(rc4 >> 4);
 739               		.loc 1 211 0
 740 01e4 812F      		mov r24,r17
 741 01e6 0E94 0000 		call hexdigit
 742               	.LVL105:
 743 01ea 8E83      		std Y+6,r24
 212:prom.c        **** 	buf[7] = hexdigit(rc4 >> 0);
 744               		.loc 1 212 0
 745 01ec 802F      		mov r24,r16
 746 01ee 8295      		swap r24
 747 01f0 8F70      		andi r24,lo8(15)
 748 01f2 0E94 0000 		call hexdigit
 749               	.LVL106:
 750 01f6 8F83      		std Y+7,r24
 213:prom.c        **** 
 751               		.loc 1 213 0
 752 01f8 802F      		mov r24,r16
 753 01fa 0E94 0000 		call hexdigit
 754               	.LVL107:
 755 01fe 8887      		std Y+8,r24
 215:prom.c        **** 	buf[9] = '\n';
 756               		.loc 1 215 0
 757 0200 8DE0      		ldi r24,lo8(13)
 758 0202 8987      		std Y+9,r24
 216:prom.c        **** 
 759               		.loc 1 216 0
 760 0204 8AE0      		ldi r24,lo8(10)
 761 0206 8A87      		std Y+10,r24
 218:prom.c        **** 	return 0;
 762               		.loc 1 218 0
 763 0208 6AE0      		ldi r22,lo8(10)
 764 020a 70E0      		ldi r23,0
 765 020c CE01      		movw r24,r28
 766 020e 0196      		adiw r24,1
 767 0210 0E94 0000 		call usb_serial_write
 768               	.LVL108:
 769               	.L20:
 770               	/* epilogue start */
 771               	.LBE61:
 772               	.LBE60:
 299:prom.c        **** 
 773               		.loc 1 299 0
 774 0214 2A96      		adiw r28,10
 775 0216 0FB6      		in __tmp_reg__,__SREG__
 776 0218 F894      		cli
 777 021a DEBF      		out __SP_H__,r29
 778 021c 0FBE      		out __SREG__,__tmp_reg__
 779 021e CDBF      		out __SP_L__,r28
 780 0220 DF91      		pop r29
 781 0222 CF91      		pop r28
 782 0224 1F91      		pop r17
 783 0226 0F91      		pop r16
 784 0228 FF90      		pop r15
 785 022a EF90      		pop r14
 786 022c DF90      		pop r13
 787 022e CF90      		pop r12
 788 0230 0895      		ret
 789               		.cfi_endproc
 790               	.LFE14:
 792               		.section	.text._prom_read,"ax",@progbits
 794               	_prom_read:
 795               	.LFB17:
 314:prom.c        **** 
 315:prom.c        **** 
 316:prom.c        **** /** Select a 32-bit address for the current PROM */
 317:prom.c        **** static void
 318:prom.c        **** prom_set_address(
 319:prom.c        **** 	uint32_t addr
 320:prom.c        **** )
 321:prom.c        **** {
 322:prom.c        **** 	for (uint8_t i = 0 ; i < prom->addr_width ; i++)
 323:prom.c        **** 	{
 324:prom.c        **** 		out(prom_pin(prom->addr_pins[i]), addr & 1);
 325:prom.c        **** 		addr >>= 1;
 326:prom.c        **** 	}
 327:prom.c        **** }
 328:prom.c        **** 
 329:prom.c        **** 
 330:prom.c        **** static uint8_t
 331:prom.c        **** _prom_read(void)
 332:prom.c        **** {
 796               		.loc 1 332 0
 797               		.cfi_startproc
 798 0000 CF93      		push r28
 799               	.LCFI23:
 800               		.cfi_def_cfa_offset 3
 801               		.cfi_offset 28, -2
 802 0002 DF93      		push r29
 803               	.LCFI24:
 804               		.cfi_def_cfa_offset 4
 805               		.cfi_offset 29, -3
 806               	/* prologue: function */
 807               	/* frame size = 0 */
 808               	/* stack size = 2 */
 809               	.L__stack_usage = 2
 810               	.LVL109:
 811               	.LBB64:
 333:prom.c        **** 	uint8_t b = 0;
 334:prom.c        **** 	for (uint8_t i = 0 ; i < prom->data_width  ; i++)
 812               		.loc 1 334 0
 813 0004 D0E0      		ldi r29,0
 814               	.LBE64:
 333:prom.c        **** 	uint8_t b = 0;
 815               		.loc 1 333 0
 816 0006 C0E0      		ldi r28,0
 817               	.LVL110:
 818               	.L54:
 819               	.LBB66:
 820               		.loc 1 334 0 discriminator 2
 821 0008 E091 0000 		lds r30,prom
 822 000c F091 0000 		lds r31,prom+1
 823 0010 8389      		ldd r24,Z+19
 824 0012 D817      		cp r29,r24
 825 0014 00F4      		brsh .L58
 826               	.LBB65:
 335:prom.c        **** 	{
 336:prom.c        **** 		uint8_t bit = in(prom_pin(prom->data_pins[i])) ? 0x80 : 0;
 827               		.loc 1 336 0
 828 0016 ED0F      		add r30,r29
 829 0018 F11D      		adc r31,__zero_reg__
 830 001a 84A5      		ldd r24,Z+44
 831 001c 0E94 0000 		call prom_pin
 832               	.LVL111:
 833 0020 0E94 0000 		call in
 834               	.LVL112:
 835 0024 8111      		cpse r24,__zero_reg__
 836 0026 80E8      		ldi r24,lo8(-128)
 837               	.L55:
 838               	.LVL113:
 337:prom.c        **** 		b = (b >> 1) | bit;
 839               		.loc 1 337 0 discriminator 4
 840 0028 C695      		lsr r28
 841               	.LVL114:
 842 002a C82B      		or r28,r24
 843               	.LVL115:
 844               	.LBE65:
 334:prom.c        **** 	{
 845               		.loc 1 334 0 discriminator 4
 846 002c DF5F      		subi r29,lo8(-(1))
 847               	.LVL116:
 848 002e 00C0      		rjmp .L54
 849               	.LVL117:
 850               	.L58:
 851               	.LBE66:
 338:prom.c        **** 	}
 339:prom.c        **** 
 340:prom.c        **** 	return b;
 341:prom.c        **** }
 852               		.loc 1 341 0
 853 0030 8C2F      		mov r24,r28
 854               	/* epilogue start */
 855 0032 DF91      		pop r29
 856               	.LVL118:
 857 0034 CF91      		pop r28
 858               	.LVL119:
 859 0036 0895      		ret
 860               		.cfi_endproc
 861               	.LFE17:
 863               		.section	.text.prom_list_send,"ax",@progbits
 865               	prom_list_send:
 866               	.LFB24:
 342:prom.c        **** 
 343:prom.c        **** 
 344:prom.c        **** /** Read a byte from the PROM at the specified address..
 345:prom.c        ****  * \todo Update this to handle wider than 8-bit PROM chips.
 346:prom.c        ****  */
 347:prom.c        **** static uint8_t
 348:prom.c        **** prom_read(
 349:prom.c        **** 	uint32_t addr
 350:prom.c        **** )
 351:prom.c        **** {
 352:prom.c        **** 	if (prom->data_width == 0)
 353:prom.c        **** 		return isp_read(addr);
 354:prom.c        **** 
 355:prom.c        **** 	uint8_t latch = (prom->options & OPTIONS_LATCH) != 0;
 356:prom.c        **** 	uint8_t latch_pin = prom_pin(prom->lo_pins[LATCH_PIN]);
 357:prom.c        **** 	if (latch) {
 358:prom.c        **** 		out(latch_pin,1);
 359:prom.c        **** 	}
 360:prom.c        **** 	prom_set_address(addr);
 361:prom.c        **** 	if (latch) {
 362:prom.c        **** 		out(latch_pin,0);
 363:prom.c        **** 	}
 364:prom.c        **** 	for(uint8_t i = 0 ; i < 255; i++)
 365:prom.c        **** 	{
 366:prom.c        **** 		asm("nop");
 367:prom.c        **** 		asm("nop");
 368:prom.c        **** 		asm("nop");
 369:prom.c        **** 		asm("nop");
 370:prom.c        **** 	}
 371:prom.c        **** 
 372:prom.c        **** 	uint8_t old_r = _prom_read();
 373:prom.c        **** 
 374:prom.c        **** 	// Try reading a few times to be sure,
 375:prom.c        **** 	// or until the values converge
 376:prom.c        **** 	for (uint8_t i = 0 ; i < 8 ; i++)
 377:prom.c        **** 	{
 378:prom.c        **** 		uint8_t r = _prom_read();
 379:prom.c        **** 		if (r == old_r)
 380:prom.c        **** 			break;
 381:prom.c        **** 		old_r = r;
 382:prom.c        **** 	}
 383:prom.c        **** 
 384:prom.c        **** 	return old_r;
 385:prom.c        **** }
 386:prom.c        **** 
 387:prom.c        **** 
 388:prom.c        **** static uint8_t
 389:prom.c        **** usb_serial_getchar_echo(void)
 390:prom.c        **** {
 391:prom.c        **** 	while (1)
 392:prom.c        **** 	{
 393:prom.c        **** 		while (usb_serial_available() == 0)
 394:prom.c        **** 			continue;
 395:prom.c        **** 
 396:prom.c        **** 		uint16_t c = usb_serial_getchar();
 397:prom.c        **** 		if (c == -1)
 398:prom.c        **** 			continue;
 399:prom.c        **** 		usb_serial_putchar(c);
 400:prom.c        **** 		return c;
 401:prom.c        **** 	}
 402:prom.c        **** }
 403:prom.c        **** 
 404:prom.c        **** static uint8_t
 405:prom.c        **** hexdigit_parse(
 406:prom.c        **** 	uint8_t c
 407:prom.c        **** )
 408:prom.c        **** {
 409:prom.c        **** 	if ('0' <= c && c <= '9')
 410:prom.c        **** 		return c - '0';
 411:prom.c        **** 	if ('A' <= c && c <= 'F')
 412:prom.c        **** 		return c - 'A' + 0xA;
 413:prom.c        **** 	if ('a' <= c && c <= 'f')
 414:prom.c        **** 		return c - 'a' + 0xA;
 415:prom.c        **** 	return 0xFF;
 416:prom.c        **** }
 417:prom.c        **** 
 418:prom.c        **** static void
 419:prom.c        **** hex32(
 420:prom.c        **** 	uint8_t * buf,
 421:prom.c        **** 	uint32_t addr
 422:prom.c        **** )
 423:prom.c        **** {
 424:prom.c        **** 	buf[7] = hexdigit(addr & 0xF); addr >>= 4;
 425:prom.c        **** 	buf[6] = hexdigit(addr & 0xF); addr >>= 4;
 426:prom.c        **** 	buf[5] = hexdigit(addr & 0xF); addr >>= 4;
 427:prom.c        **** 	buf[4] = hexdigit(addr & 0xF); addr >>= 4;
 428:prom.c        **** 	buf[3] = hexdigit(addr & 0xF); addr >>= 4;
 429:prom.c        **** 	buf[2] = hexdigit(addr & 0xF); addr >>= 4;
 430:prom.c        **** 	buf[1] = hexdigit(addr & 0xF); addr >>= 4;
 431:prom.c        **** 	buf[0] = hexdigit(addr & 0xF); addr >>= 4;
 432:prom.c        **** }
 433:prom.c        **** 
 434:prom.c        **** 
 435:prom.c        **** static void
 436:prom.c        **** hexdump(
 437:prom.c        **** 	uint32_t addr
 438:prom.c        **** )
 439:prom.c        **** {
 440:prom.c        **** 	uint8_t buf[80];
 441:prom.c        **** 	hex32(buf, addr);
 442:prom.c        **** 
 443:prom.c        **** 	for (int i = 0 ; i < 16 ; i++)
 444:prom.c        **** 	{
 445:prom.c        **** 		uint8_t w = prom_read(addr++);
 446:prom.c        **** 		uint8_t x = 8 + i * 3;
 447:prom.c        **** 		buf[x+0] = ' ';
 448:prom.c        **** 		buf[x+1] = hexdigit(w >> 4);
 449:prom.c        **** 		buf[x+2] = hexdigit(w >> 0);
 450:prom.c        **** 
 451:prom.c        **** 		buf[8 + 16*3 + i + 2] = printable(w) ? w : '.';
 452:prom.c        **** 	}
 453:prom.c        **** 
 454:prom.c        **** 	buf[8 + 16 * 3 + 0] = ' ';
 455:prom.c        **** 	buf[8 + 16 * 3 + 1] = ' ';
 456:prom.c        **** 	buf[8 + 16 * 3 + 18] = '\r';
 457:prom.c        **** 	buf[8 + 16 * 3 + 19] = '\n';
 458:prom.c        **** 
 459:prom.c        **** 	usb_serial_write(buf, 8 + 16 * 3 + 20);
 460:prom.c        **** }
 461:prom.c        **** 
 462:prom.c        **** 
 463:prom.c        **** /** Read an address from the serial port, then read that from the PROM */
 464:prom.c        **** static void
 465:prom.c        **** read_addr(char* buffer)
 466:prom.c        **** {
 467:prom.c        **** 	uint32_t addr = 0;
 468:prom.c        **** 	uint8_t buf_idx = 0;
 469:prom.c        **** 	while (1)
 470:prom.c        **** 	{
 471:prom.c        **** 	  uint8_t c = buffer[buf_idx++];
 472:prom.c        **** 	  if (c == '\0')
 473:prom.c        **** 	    break;
 474:prom.c        **** 	  uint8_t n = hexdigit_parse(c);
 475:prom.c        **** 	  if (n == 0xFF)
 476:prom.c        **** 	    goto error;
 477:prom.c        **** 	  
 478:prom.c        **** 	  addr = (addr << 4) | n;
 479:prom.c        **** 	}
 480:prom.c        **** 
 481:prom.c        **** 	send_str(PSTR("\r\n"));
 482:prom.c        **** 
 483:prom.c        **** 	prom_setup();
 484:prom.c        **** 
 485:prom.c        **** 	for (uint8_t line = 0 ; line < 4 ; line++)
 486:prom.c        **** 	{
 487:prom.c        **** 		hexdump(addr);
 488:prom.c        **** 		addr += 16;
 489:prom.c        **** 	}
 490:prom.c        **** 	return;
 491:prom.c        **** 
 492:prom.c        **** error:
 493:prom.c        **** 	send_str(PSTR("?\r\n"));
 494:prom.c        **** }
 495:prom.c        **** 
 496:prom.c        **** 
 497:prom.c        **** /** Send a single prom name to the serial port */
 498:prom.c        **** static void
 499:prom.c        **** prom_list_send(
 500:prom.c        **** 	int mode,
 501:prom.c        **** 	const prom_t * const prom,
 502:prom.c        **** 	int selected
 503:prom.c        **** )
 504:prom.c        **** {
 867               		.loc 1 504 0
 868               		.cfi_startproc
 869               	.LVL120:
 870 0000 CF92      		push r12
 871               	.LCFI25:
 872               		.cfi_def_cfa_offset 3
 873               		.cfi_offset 12, -2
 874 0002 DF92      		push r13
 875               	.LCFI26:
 876               		.cfi_def_cfa_offset 4
 877               		.cfi_offset 13, -3
 878 0004 EF92      		push r14
 879               	.LCFI27:
 880               		.cfi_def_cfa_offset 5
 881               		.cfi_offset 14, -4
 882 0006 FF92      		push r15
 883               	.LCFI28:
 884               		.cfi_def_cfa_offset 6
 885               		.cfi_offset 15, -5
 886 0008 0F93      		push r16
 887               	.LCFI29:
 888               		.cfi_def_cfa_offset 7
 889               		.cfi_offset 16, -6
 890 000a 1F93      		push r17
 891               	.LCFI30:
 892               		.cfi_def_cfa_offset 8
 893               		.cfi_offset 17, -7
 894 000c CF93      		push r28
 895               	.LCFI31:
 896               		.cfi_def_cfa_offset 9
 897               		.cfi_offset 28, -8
 898 000e DF93      		push r29
 899               	.LCFI32:
 900               		.cfi_def_cfa_offset 10
 901               		.cfi_offset 29, -9
 902 0010 CDB7      		in r28,__SP_L__
 903 0012 DEB7      		in r29,__SP_H__
 904               	.LCFI33:
 905               		.cfi_def_cfa_register 28
 906 0014 A097      		sbiw r28,32
 907               	.LCFI34:
 908               		.cfi_def_cfa_offset 42
 909 0016 0FB6      		in __tmp_reg__,__SREG__
 910 0018 F894      		cli
 911 001a DEBF      		out __SP_H__,r29
 912 001c 0FBE      		out __SREG__,__tmp_reg__
 913 001e CDBF      		out __SP_L__,r28
 914               	/* prologue: function */
 915               	/* frame size = 32 */
 916               	/* stack size = 40 */
 917               	.L__stack_usage = 40
 918 0020 7C01      		movw r14,r24
 919 0022 6B01      		movw r12,r22
 920               	.LVL121:
 505:prom.c        **** 	uint8_t buf[32];
 506:prom.c        **** 	uint8_t off = 0;
 507:prom.c        **** 	if (selected)
 921               		.loc 1 507 0
 922 0024 452B      		or r20,r21
 923 0026 01F0      		breq .L62
 924               	.LVL122:
 508:prom.c        **** 	{
 509:prom.c        **** 		buf[off++] = '*';
 925               		.loc 1 509 0
 926 0028 8AE2      		ldi r24,lo8(42)
 927               	.LVL123:
 928 002a 8983      		std Y+1,r24
 929               	.LVL124:
 510:prom.c        **** 		buf[off++] = '*';
 930               		.loc 1 510 0
 931 002c 8A83      		std Y+2,r24
 932               	.LVL125:
 511:prom.c        **** 		buf[off++] = '*';
 933               		.loc 1 511 0
 934 002e 8B83      		std Y+3,r24
 935               	.LVL126:
 512:prom.c        **** 		buf[off++] = ' ';
 936               		.loc 1 512 0
 937 0030 80E2      		ldi r24,lo8(32)
 938 0032 8C83      		std Y+4,r24
 939 0034 14E0      		ldi r17,lo8(4)
 940 0036 00C0      		rjmp .L60
 941               	.LVL127:
 942               	.L62:
 506:prom.c        **** 	if (selected)
 943               		.loc 1 506 0
 944 0038 10E0      		ldi r17,0
 945               	.LVL128:
 946               	.L60:
 513:prom.c        **** 	}
 514:prom.c        **** 	if (mode >= 16) {
 947               		.loc 1 514 0
 948 003a 80E1      		ldi r24,16
 949 003c E816      		cp r14,r24
 950 003e F104      		cpc r15,__zero_reg__
 951 0040 04F0      		brlt .L61
 515:prom.c        **** 	  buf[off++] = hexdigit(mode / 16);
 952               		.loc 1 515 0
 953 0042 01E0      		ldi r16,lo8(1)
 954 0044 010F      		add r16,r17
 955               	.LVL129:
 956 0046 C701      		movw r24,r14
 957 0048 24E0      		ldi r18,4
 958               		1:
 959 004a 9595      		asr r25
 960 004c 8795      		ror r24
 961 004e 2A95      		dec r18
 962 0050 01F4      		brne 1b
 963 0052 0E94 0000 		call hexdigit
 964               	.LVL130:
 965 0056 E1E0      		ldi r30,lo8(1)
 966 0058 F0E0      		ldi r31,0
 967 005a EC0F      		add r30,r28
 968 005c FD1F      		adc r31,r29
 969 005e E10F      		add r30,r17
 970 0060 F11D      		adc r31,__zero_reg__
 971 0062 8083      		st Z,r24
 972 0064 102F      		mov r17,r16
 973               	.LVL131:
 974               	.L61:
 516:prom.c        **** 	}
 517:prom.c        **** 	buf[off++] = hexdigit(mode % 16);
 975               		.loc 1 517 0
 976 0066 C701      		movw r24,r14
 977 0068 60E1      		ldi r22,lo8(16)
 978 006a 70E0      		ldi r23,0
 979 006c 0E94 0000 		call __divmodhi4
 980 0070 0E94 0000 		call hexdigit
 981               	.LVL132:
 982 0074 E1E0      		ldi r30,lo8(1)
 983 0076 F0E0      		ldi r31,0
 984 0078 EC0F      		add r30,r28
 985 007a FD1F      		adc r31,r29
 986 007c E10F      		add r30,r17
 987 007e F11D      		adc r31,__zero_reg__
 988 0080 8083      		st Z,r24
 989               	.LVL133:
 518:prom.c        **** 	buf[off++] = ' ';
 990               		.loc 1 518 0
 991 0082 81E0      		ldi r24,lo8(1)
 992 0084 810F      		add r24,r17
 993 0086 E1E0      		ldi r30,lo8(1)
 994 0088 F0E0      		ldi r31,0
 995 008a EC0F      		add r30,r28
 996 008c FD1F      		adc r31,r29
 997 008e E80F      		add r30,r24
 998 0090 F11D      		adc r31,__zero_reg__
 999 0092 80E2      		ldi r24,lo8(32)
 1000 0094 8083      		st Z,r24
 519:prom.c        **** 	memcpy(buf+off, prom->name, sizeof(prom->name));
 1001               		.loc 1 519 0
 1002 0096 82E0      		ldi r24,lo8(2)
 1003 0098 810F      		add r24,r17
 1004               	.LVL134:
 1005 009a A1E0      		ldi r26,lo8(1)
 1006 009c B0E0      		ldi r27,0
 1007 009e AC0F      		add r26,r28
 1008 00a0 BD1F      		adc r27,r29
 1009 00a2 A80F      		add r26,r24
 1010 00a4 B11D      		adc r27,__zero_reg__
 1011 00a6 80E1      		ldi r24,lo8(16)
 1012               	.LVL135:
 1013 00a8 F601      		movw r30,r12
 1014               		0:
 1015 00aa 0190      		ld r0,Z+
 1016 00ac 0D92      		st X+,r0
 1017 00ae 8A95      		dec r24
 1018 00b0 01F4      		brne 0b
 1019               	.LVL136:
 520:prom.c        **** 	off += sizeof(prom->name);
 521:prom.c        **** 	buf[off++] = '\r';
 1020               		.loc 1 521 0
 1021 00b2 82E1      		ldi r24,lo8(18)
 1022 00b4 810F      		add r24,r17
 1023 00b6 E1E0      		ldi r30,lo8(1)
 1024 00b8 F0E0      		ldi r31,0
 1025 00ba EC0F      		add r30,r28
 1026 00bc FD1F      		adc r31,r29
 1027 00be E80F      		add r30,r24
 1028 00c0 F11D      		adc r31,__zero_reg__
 1029 00c2 8DE0      		ldi r24,lo8(13)
 1030 00c4 8083      		st Z,r24
 1031               	.LVL137:
 522:prom.c        **** 	buf[off++] = '\n';
 1032               		.loc 1 522 0
 1033 00c6 83E1      		ldi r24,lo8(19)
 1034 00c8 810F      		add r24,r17
 1035 00ca E1E0      		ldi r30,lo8(1)
 1036 00cc F0E0      		ldi r31,0
 1037 00ce EC0F      		add r30,r28
 1038 00d0 FD1F      		adc r31,r29
 1039 00d2 E80F      		add r30,r24
 1040 00d4 F11D      		adc r31,__zero_reg__
 1041 00d6 8AE0      		ldi r24,lo8(10)
 1042 00d8 8083      		st Z,r24
 523:prom.c        **** 
 524:prom.c        **** 	usb_serial_write(buf, off);
 1043               		.loc 1 524 0
 1044 00da 1C5E      		subi r17,lo8(-(20))
 1045               	.LVL138:
 1046 00dc 612F      		mov r22,r17
 1047 00de 70E0      		ldi r23,0
 1048 00e0 CE01      		movw r24,r28
 1049 00e2 0196      		adiw r24,1
 1050 00e4 0E94 0000 		call usb_serial_write
 1051               	.LVL139:
 1052               	/* epilogue start */
 525:prom.c        **** }
 1053               		.loc 1 525 0
 1054 00e8 A096      		adiw r28,32
 1055 00ea 0FB6      		in __tmp_reg__,__SREG__
 1056 00ec F894      		cli
 1057 00ee DEBF      		out __SP_H__,r29
 1058 00f0 0FBE      		out __SREG__,__tmp_reg__
 1059 00f2 CDBF      		out __SP_L__,r28
 1060 00f4 DF91      		pop r29
 1061 00f6 CF91      		pop r28
 1062 00f8 1F91      		pop r17
 1063               	.LVL140:
 1064 00fa 0F91      		pop r16
 1065 00fc FF90      		pop r15
 1066 00fe EF90      		pop r14
 1067               	.LVL141:
 1068 0100 DF90      		pop r13
 1069 0102 CF90      		pop r12
 1070               	.LVL142:
 1071 0104 0895      		ret
 1072               		.cfi_endproc
 1073               	.LFE24:
 1075               		.section	.text.prom_read,"ax",@progbits
 1077               	prom_read:
 1078               	.LFB18:
 351:prom.c        **** 	if (prom->data_width == 0)
 1079               		.loc 1 351 0
 1080               		.cfi_startproc
 1081               	.LVL143:
 1082 0000 CF92      		push r12
 1083               	.LCFI35:
 1084               		.cfi_def_cfa_offset 3
 1085               		.cfi_offset 12, -2
 1086 0002 DF92      		push r13
 1087               	.LCFI36:
 1088               		.cfi_def_cfa_offset 4
 1089               		.cfi_offset 13, -3
 1090 0004 EF92      		push r14
 1091               	.LCFI37:
 1092               		.cfi_def_cfa_offset 5
 1093               		.cfi_offset 14, -4
 1094 0006 FF92      		push r15
 1095               	.LCFI38:
 1096               		.cfi_def_cfa_offset 6
 1097               		.cfi_offset 15, -5
 1098 0008 1F93      		push r17
 1099               	.LCFI39:
 1100               		.cfi_def_cfa_offset 7
 1101               		.cfi_offset 17, -6
 1102 000a CF93      		push r28
 1103               	.LCFI40:
 1104               		.cfi_def_cfa_offset 8
 1105               		.cfi_offset 28, -7
 1106 000c DF93      		push r29
 1107               	.LCFI41:
 1108               		.cfi_def_cfa_offset 9
 1109               		.cfi_offset 29, -8
 1110               	/* prologue: function */
 1111               	/* frame size = 0 */
 1112               	/* stack size = 7 */
 1113               	.L__stack_usage = 7
 1114 000e 6B01      		movw r12,r22
 1115 0010 7C01      		movw r14,r24
 352:prom.c        **** 		return isp_read(addr);
 1116               		.loc 1 352 0
 1117 0012 E091 0000 		lds r30,prom
 1118 0016 F091 0000 		lds r31,prom+1
 1119 001a 8389      		ldd r24,Z+19
 1120 001c 8111      		cpse r24,__zero_reg__
 1121 001e 00C0      		rjmp .L64
 1122               	.LVL144:
 1123               	.LBB77:
 1124               	.LBB78:
 231:prom.c        **** 	uint8_t b = (addr >>  0) & 0xFF;
 1125               		.loc 1 231 0
 1126 0020 DD2D      		mov r29,r13
 1127 0022 DF70      		andi r29,lo8(15)
 1128               	.LVL145:
 232:prom.c        **** 	isp_write(0x20 | (h ? 0x8 : 0));
 1129               		.loc 1 232 0
 1130 0024 CC2D      		mov r28,r12
 1131               	.LVL146:
 233:prom.c        **** 	isp_write(a);
 1132               		.loc 1 233 0
 1133 0026 9CE0      		ldi r25,12
 1134               		1:
 1135 0028 F694      		lsr r15
 1136 002a E794      		ror r14
 1137 002c D794      		ror r13
 1138 002e C794      		ror r12
 1139 0030 9A95      		dec r25
 1140 0032 01F4      		brne 1b
 1141 0034 C0FC      		sbrc r12,0
 1142 0036 00C0      		rjmp .L73
 1143 0038 80E2      		ldi r24,lo8(32)
 1144 003a 00C0      		rjmp .L65
 1145               	.L73:
 1146 003c 88E2      		ldi r24,lo8(40)
 1147               	.L65:
 1148 003e 0E94 0000 		call isp_write
 1149               	.LVL147:
 234:prom.c        **** 	isp_write(b);
 1150               		.loc 1 234 0
 1151 0042 8D2F      		mov r24,r29
 1152 0044 0E94 0000 		call isp_write
 1153               	.LVL148:
 235:prom.c        **** 	return isp_write(0);
 1154               		.loc 1 235 0
 1155 0048 8C2F      		mov r24,r28
 1156 004a 0E94 0000 		call isp_write
 1157               	.LVL149:
 236:prom.c        **** }
 1158               		.loc 1 236 0
 1159 004e 80E0      		ldi r24,0
 1160               	/* epilogue start */
 1161               	.LBE78:
 1162               	.LBE77:
 385:prom.c        **** 
 1163               		.loc 1 385 0
 1164 0050 DF91      		pop r29
 1165               	.LVL150:
 1166 0052 CF91      		pop r28
 1167 0054 1F91      		pop r17
 1168 0056 FF90      		pop r15
 1169 0058 EF90      		pop r14
 1170 005a DF90      		pop r13
 1171               	.LVL151:
 1172 005c CF90      		pop r12
 1173               	.LBB82:
 1174               	.LBB79:
 236:prom.c        **** }
 1175               		.loc 1 236 0
 1176 005e 0C94 0000 		jmp isp_write
 1177               	.LVL152:
 1178               	.L64:
 1179 0062 C089      		ldd r28,Z+16
 1180 0064 C270      		andi r28,lo8(2)
 1181               	.LVL153:
 1182               	.LBE79:
 1183               	.LBE82:
 356:prom.c        **** 	if (latch) {
 1184               		.loc 1 356 0
 1185 0066 E45B      		subi r30,-76
 1186 0068 FF4F      		sbci r31,-1
 1187 006a 8081      		ld r24,Z
 1188 006c 0E94 0000 		call prom_pin
 1189               	.LVL154:
 1190 0070 182F      		mov r17,r24
 1191               	.LVL155:
 357:prom.c        **** 		out(latch_pin,1);
 1192               		.loc 1 357 0
 1193 0072 CC23      		tst r28
 1194 0074 01F0      		breq .L66
 358:prom.c        **** 	}
 1195               		.loc 1 358 0
 1196 0076 61E0      		ldi r22,lo8(1)
 1197 0078 0E94 0000 		call out
 1198               	.LVL156:
 1199               	.L66:
 1200               	.LBB83:
 1201               	.LBB80:
 233:prom.c        **** 	isp_write(a);
 1202               		.loc 1 233 0
 1203 007c D0E0      		ldi r29,0
 1204               	.LVL157:
 1205               	.L67:
 1206               	.LBE80:
 1207               	.LBE83:
 1208               	.LBB84:
 1209               	.LBB85:
 322:prom.c        **** 	{
 1210               		.loc 1 322 0
 1211 007e E091 0000 		lds r30,prom
 1212 0082 F091 0000 		lds r31,prom+1
 1213 0086 8289      		ldd r24,Z+18
 1214 0088 D817      		cp r29,r24
 1215 008a 00F4      		brsh .L83
 324:prom.c        **** 		addr >>= 1;
 1216               		.loc 1 324 0
 1217 008c ED0F      		add r30,r29
 1218 008e F11D      		adc r31,__zero_reg__
 1219 0090 8489      		ldd r24,Z+20
 1220 0092 0E94 0000 		call prom_pin
 1221               	.LVL158:
 1222 0096 6C2D      		mov r22,r12
 1223 0098 6170      		andi r22,lo8(1)
 1224 009a 0E94 0000 		call out
 1225               	.LVL159:
 325:prom.c        **** 	}
 1226               		.loc 1 325 0
 1227 009e F694      		lsr r15
 1228 00a0 E794      		ror r14
 1229 00a2 D794      		ror r13
 1230 00a4 C794      		ror r12
 1231               	.LVL160:
 322:prom.c        **** 	{
 1232               		.loc 1 322 0
 1233 00a6 DF5F      		subi r29,lo8(-(1))
 1234               	.LVL161:
 1235 00a8 00C0      		rjmp .L67
 1236               	.L83:
 1237               	.LVL162:
 1238               	.LBE85:
 1239               	.LBE84:
 361:prom.c        **** 		out(latch_pin,0);
 1240               		.loc 1 361 0
 1241 00aa CC23      		tst r28
 1242 00ac 01F0      		breq .L69
 362:prom.c        **** 	}
 1243               		.loc 1 362 0
 1244 00ae 60E0      		ldi r22,0
 1245 00b0 812F      		mov r24,r17
 1246 00b2 0E94 0000 		call out
 1247               	.LVL163:
 1248               	.L69:
 1249               	.LBB86:
 1250               	.LBB81:
 233:prom.c        **** 	isp_write(a);
 1251               		.loc 1 233 0
 1252 00b6 8FEF      		ldi r24,lo8(-1)
 1253               	.LVL164:
 1254               	.L70:
 1255               	.LBE81:
 1256               	.LBE86:
 1257               	.LBB87:
 1258               	.LBB88:
 1259               	.LBB89:
 366:prom.c        **** 		asm("nop");
 1260               		.loc 1 366 0
 1261               	/* #APP */
 1262               	 ;  366 "prom.c" 1
 1263 00b8 0000      		nop
 1264               	 ;  0 "" 2
 367:prom.c        **** 		asm("nop");
 1265               		.loc 1 367 0
 1266               	 ;  367 "prom.c" 1
 1267 00ba 0000      		nop
 1268               	 ;  0 "" 2
 368:prom.c        **** 		asm("nop");
 1269               		.loc 1 368 0
 1270               	 ;  368 "prom.c" 1
 1271 00bc 0000      		nop
 1272               	 ;  0 "" 2
 369:prom.c        **** 	}
 1273               		.loc 1 369 0
 1274               	 ;  369 "prom.c" 1
 1275 00be 0000      		nop
 1276               	 ;  0 "" 2
 1277               	.LVL165:
 1278               	/* #NOAPP */
 1279 00c0 8150      		subi r24,lo8(-(-1))
 1280               	.LVL166:
 364:prom.c        **** 	{
 1281               		.loc 1 364 0
 1282 00c2 01F4      		brne .L70
 1283               	.LBE89:
 372:prom.c        **** 
 1284               		.loc 1 372 0
 1285 00c4 0E94 0000 		call _prom_read
 1286               	.LVL167:
 1287 00c8 C82F      		mov r28,r24
 1288               	.LVL168:
 1289 00ca D8E0      		ldi r29,lo8(8)
 1290               	.LVL169:
 1291               	.L72:
 1292               	.LBB90:
 1293               	.LBB91:
 378:prom.c        **** 		if (r == old_r)
 1294               		.loc 1 378 0
 1295 00cc 0E94 0000 		call _prom_read
 1296               	.LVL170:
 379:prom.c        **** 			break;
 1297               		.loc 1 379 0
 1298 00d0 8C17      		cp r24,r28
 1299 00d2 01F0      		breq .L71
 1300               	.LVL171:
 1301 00d4 D150      		subi r29,lo8(-(-1))
 1302               	.LVL172:
 1303 00d6 C82F      		mov r28,r24
 1304               	.LBE91:
 376:prom.c        **** 	{
 1305               		.loc 1 376 0
 1306 00d8 01F4      		brne .L72
 1307               	.LVL173:
 1308               	.L71:
 1309               	.LBE90:
 1310               	.LBE88:
 1311               	.LBE87:
 385:prom.c        **** 
 1312               		.loc 1 385 0
 1313 00da 8C2F      		mov r24,r28
 1314               	.LVL174:
 1315               	/* epilogue start */
 1316 00dc DF91      		pop r29
 1317 00de CF91      		pop r28
 1318               	.LVL175:
 1319 00e0 1F91      		pop r17
 1320               	.LVL176:
 1321 00e2 FF90      		pop r15
 1322 00e4 EF90      		pop r14
 1323 00e6 DF90      		pop r13
 1324 00e8 CF90      		pop r12
 1325               	.LVL177:
 1326 00ea 0895      		ret
 1327               		.cfi_endproc
 1328               	.LFE18:
 1330               		.section	.text.send_str,"ax",@progbits
 1331               	.global	send_str
 1333               	send_str:
 1334               	.LFB31:
 526:prom.c        **** 
 527:prom.c        **** 
 528:prom.c        **** /** List all of the PROM models supported */
 529:prom.c        **** static void
 530:prom.c        **** prom_list(void)
 531:prom.c        **** {
 532:prom.c        **** 	for (int i = 0 ; i < proms_count ; i++)
 533:prom.c        **** 	{
 534:prom.c        **** 		const prom_t * const p = &proms[i];
 535:prom.c        **** 		prom_list_send(i, p, p == prom );
 536:prom.c        **** 	}
 537:prom.c        **** }
 538:prom.c        **** 
 539:prom.c        **** static void
 540:prom.c        **** prom_mode(char* buffer)
 541:prom.c        **** {
 542:prom.c        ****   for (int i = 0; i < proms_count; i++) {
 543:prom.c        ****     const char* a = proms[i].name;
 544:prom.c        ****     const char* b = buffer;
 545:prom.c        ****     char match = 1;
 546:prom.c        ****     while (*a != '\0' && *b != '\0') {      
 547:prom.c        ****       if (*a != *b) { match = 0; break; }
 548:prom.c        ****       a++; b++;
 549:prom.c        ****     }
 550:prom.c        ****     if (match) {
 551:prom.c        **** 	prom = &proms[i];
 552:prom.c        **** 	prom_list_send(i, prom, 1);
 553:prom.c        **** 	return;
 554:prom.c        ****     }
 555:prom.c        ****   }    
 556:prom.c        ****   send_str(PSTR("- No such chip\r\n"));
 557:prom.c        **** }
 558:prom.c        **** 
 559:prom.c        **** 
 560:prom.c        **** /**
 561:prom.c        ****  * Scan the current chip against the EPROM definition given.
 562:prom.c        ****  * A "successful" scan should yield:
 563:prom.c        ****  * - Different data on each data pin
 564:prom.c        ****  * - Consistent data across multiple scans
 565:prom.c        ****  * - A check on high memory to ensure to disambiguate different
 566:prom.c        ****  *   memory grades on the same/similar pinouts
 567:prom.c        ****  * Return 1 on success, 0 otherwise.
 568:prom.c        ****  */
 569:prom.c        **** static uint8_t scan(const prom_t* use_prom) {
 570:prom.c        ****   prom = use_prom;
 571:prom.c        ****   prom_setup();
 572:prom.c        ****   // scan first 256 bytes for varying data
 573:prom.c        ****   uint8_t zeros = 0;
 574:prom.c        ****   uint8_t ones = 0;
 575:prom.c        ****   uint8_t block[16];
 576:prom.c        ****   for (uint32_t addr = 0; addr < 256; addr += 16) {
 577:prom.c        ****     for (uint8_t i = 0; i < 16; i++) {
 578:prom.c        ****       block[i] = prom_read(addr+i);
 579:prom.c        ****       zeros |= ~block[i];
 580:prom.c        ****       ones |= block[i];
 581:prom.c        ****     }
 582:prom.c        ****     // reread and confirm
 583:prom.c        ****     for (uint8_t i = 0; i < 16; i++) {
 584:prom.c        ****       if (block[i] != prom_read(addr+i)) {
 585:prom.c        **** 	return 0;
 586:prom.c        ****       }
 587:prom.c        ****     }
 588:prom.c        ****   }
 589:prom.c        ****   // ensure that we're not just getting the same bits again and again
 590:prom.c        ****   if (ones != 0xff || zeros != 0xff) { return 0; }
 591:prom.c        ****   // check top half of memory. If first 256 bytes mirrors low memory
 592:prom.c        ****   // or is the same byte, consider it a failure.
 593:prom.c        ****   const uint32_t top_half_addr = (((uint32_t) 1) << prom->addr_width) >> 1;
 594:prom.c        ****   uint8_t single_byte = prom_read(top_half_addr);
 595:prom.c        ****   uint8_t same_byte_check = 1;
 596:prom.c        ****   uint8_t same_data_check = 1;
 597:prom.c        ****   for (uint8_t i = 0; i < 256; i++) {
 598:prom.c        ****     uint8_t low = prom_read(i);
 599:prom.c        ****     uint8_t high = prom_read(top_half_addr+i);
 600:prom.c        ****     if (high != single_byte) { same_byte_check = 0; }
 601:prom.c        ****     if (low != high) { same_data_check = 0; }
 602:prom.c        ****   }
 603:prom.c        ****   if (same_data_check || same_byte_check) { return 0; }
 604:prom.c        ****   return 1;
 605:prom.c        **** }
 606:prom.c        **** 
 607:prom.c        **** /**
 608:prom.c        ****  * Automatically scan all known EPROM types and attempt to construct a list of candidates.
 609:prom.c        ****  */
 610:prom.c        **** static void autoscan(void) {
 611:prom.c        ****   prom_tristate();
 612:prom.c        ****   for (int i = 0; i < proms_count; i++) {
 613:prom.c        ****     if (scan(proms+i)) {
 614:prom.c        ****       prom_list_send(i, prom, 1);
 615:prom.c        ****     }
 616:prom.c        ****     prom_tristate();
 617:prom.c        ****   }
 618:prom.c        **** }
 619:prom.c        **** 
 620:prom.c        **** static xmodem_block_t xmodem_block;
 621:prom.c        **** 
 622:prom.c        **** /** Send the entire PROM memory via xmodem */
 623:prom.c        **** static void
 624:prom.c        **** prom_send(void)
 625:prom.c        **** {
 626:prom.c        **** 	if (xmodem_init(&xmodem_block) < 0)
 627:prom.c        **** 		return;
 628:prom.c        **** 
 629:prom.c        **** 	// Ending address
 630:prom.c        **** 	const uint32_t end_addr = (((uint32_t) 1) << prom->addr_width) - 1;
 631:prom.c        **** 
 632:prom.c        **** 	// Bring the pins up to level
 633:prom.c        **** 	prom_setup();
 634:prom.c        **** 
 635:prom.c        **** 	// Start sending!
 636:prom.c        **** 	uint32_t addr = 0;
 637:prom.c        **** 	while (1)
 638:prom.c        **** 	{
 639:prom.c        **** 		for (uint8_t off = 0 ; off < sizeof(xmodem_block.data) ; off++)
 640:prom.c        **** 			xmodem_block.data[off] = prom_read(addr++);
 641:prom.c        **** 
 642:prom.c        **** 		if (xmodem_send(&xmodem_block) < 0)
 643:prom.c        **** 			return;
 644:prom.c        **** 
 645:prom.c        **** 		// If we have wrapped the address, we are done
 646:prom.c        **** 		if (addr >= end_addr)
 647:prom.c        **** 			break;
 648:prom.c        **** 	}
 649:prom.c        **** 
 650:prom.c        **** 	xmodem_fini(&xmodem_block);
 651:prom.c        **** }
 652:prom.c        **** 
 653:prom.c        **** 
 654:prom.c        **** 
 655:prom.c        **** 
 656:prom.c        **** int main(void)
 657:prom.c        **** {
 658:prom.c        **** 	// set for 16 MHz clock
 659:prom.c        **** #define CPU_PRESCALE(n) (CLKPR = 0x80, CLKPR = (n))
 660:prom.c        **** 	CPU_PRESCALE(0);
 661:prom.c        **** 
 662:prom.c        **** 	// Disable the ADC
 663:prom.c        **** 	ADMUX = 0;
 664:prom.c        **** 
 665:prom.c        **** 	// initialize the USB, and then wait for the host
 666:prom.c        **** 	// to set configuration.  If the Teensy is powered
 667:prom.c        **** 	// without a PC connected to the USB port, this 
 668:prom.c        **** 	// will wait forever.
 669:prom.c        **** 	usb_init();
 670:prom.c        **** 	while (!usb_configured()) /* wait */ ;
 671:prom.c        **** 	_delay_ms(1000);
 672:prom.c        **** 
 673:prom.c        **** 	// wait for the user to run their terminal emulator program
 674:prom.c        **** 	// which sets DTR to indicate it is ready to receive.
 675:prom.c        **** 	while (!(usb_serial_get_control() & USB_SERIAL_DTR))
 676:prom.c        **** 		continue;
 677:prom.c        **** 
 678:prom.c        **** 
 679:prom.c        **** 	// discard anything that was received prior.  Sometimes the
 680:prom.c        **** 	// operating system or other software will send a modem
 681:prom.c        **** 	// "AT command", which can still be buffered.
 682:prom.c        **** 	usb_serial_flush_input();
 683:prom.c        **** 
 684:prom.c        **** 
 685:prom.c        **** #if 0
 686:prom.c        **** 	uint16_t addr = 0;
 687:prom.c        **** 	char line[64];
 688:prom.c        **** 	uint8_t off = 0;
 689:prom.c        **** 
 690:prom.c        **** 	send_str(PSTR("Looking for strings\r\n"));
 691:prom.c        **** 
 692:prom.c        **** 	while (1)
 693:prom.c        **** 	{
 694:prom.c        **** 		addr++;
 695:prom.c        **** 		if (addr == 0)
 696:prom.c        **** 			send_str(PSTR("wrap\r\n"));
 697:prom.c        **** 
 698:prom.c        **** 		uint8_t byte = read_byte(addr);
 699:prom.c        **** 		if (byte == 0)
 700:prom.c        **** 			continue;
 701:prom.c        **** 
 702:prom.c        **** 		if (off == 0)
 703:prom.c        **** 		{
 704:prom.c        **** 			line[off++] = hexdigit(addr >> 12);
 705:prom.c        **** 			line[off++] = hexdigit(addr >>  8);
 706:prom.c        **** 			line[off++] = hexdigit(addr >>  4);
 707:prom.c        **** 			line[off++] = hexdigit(addr >>  0);
 708:prom.c        **** 			line[off++] = '=';
 709:prom.c        **** 		}
 710:prom.c        **** 
 711:prom.c        **** 		if (printable(byte))
 712:prom.c        **** 		{
 713:prom.c        **** 			line[off++] = byte;
 714:prom.c        **** 			if (off < sizeof(line) - 2)
 715:prom.c        **** 				continue;
 716:prom.c        **** 		} else {
 717:prom.c        **** 			line[off++] = hexdigit(byte >> 4);
 718:prom.c        **** 			line[off++] = hexdigit(byte >> 0);
 719:prom.c        **** 		}
 720:prom.c        **** 
 721:prom.c        **** 		line[off++] = '\r';
 722:prom.c        **** 		line[off++] = '\n';
 723:prom.c        **** 		usb_serial_write(line, off);
 724:prom.c        **** 		off = 0;
 725:prom.c        **** 	}
 726:prom.c        **** #else
 727:prom.c        **** 	#define MAX_CMD 64
 728:prom.c        **** 	char buffer[MAX_CMD];
 729:prom.c        **** 	uint8_t buf_idx = 0;
 730:prom.c        **** 	while (1)
 731:prom.c        **** 	{
 732:prom.c        **** 		// always put the PROM into tristate so that it is safe
 733:prom.c        **** 		// to swap the chips in between readings, and 
 734:prom.c        **** 		prom_tristate();
 735:prom.c        **** 		send_str(PSTR("> "));
 736:prom.c        **** 
 737:prom.c        **** 		buf_idx = 0;
 738:prom.c        **** 		buffer[buf_idx] = 0;
 739:prom.c        **** 		while (1)
 740:prom.c        **** 		{
 741:prom.c        **** 		  // read in a line, processing on a newline, return, or
 742:prom.c        **** 		  // xmodem transfer nak
 743:prom.c        **** 		  char c = usb_serial_getchar_echo();
 744:prom.c        **** 		  if (c == XMODEM_NAK) { buffer[0] = XMODEM_NAK; buf_idx=1; break; }
 745:prom.c        **** 		  if (c == '\n') { send_str(PSTR("\r")); break; }
 746:prom.c        **** 		  if (c == '\r') { send_str(PSTR("\n")); break; }
 747:prom.c        **** 		  if (buf_idx < (MAX_CMD-1)) buffer[buf_idx++] = c;
 748:prom.c        **** 		}
 749:prom.c        **** 		buffer[buf_idx] = 0;
 750:prom.c        **** 		// process command
 751:prom.c        **** 		switch(buffer[0]) {
 752:prom.c        **** 		case XMODEM_NAK: prom_send(); break;
 753:prom.c        **** 		case 'r': read_addr(buffer+1); break;
 754:prom.c        **** 		case 'l': prom_list(); break;
 755:prom.c        **** 		case 'm': prom_mode(buffer+1); break;
 756:prom.c        **** 		case 'i': isp_read(0); break;
 757:prom.c        **** 		case 's': autoscan(); break;
 758:prom.c        **** 		case '\n': break;
 759:prom.c        **** 		case '\r': break;
 760:prom.c        **** 		default:
 761:prom.c        **** 			send_str(PSTR(
 762:prom.c        **** "r000000 Read a hex word from address\r\n"
 763:prom.c        **** "l       List chip modes\r\n"
 764:prom.c        **** "mTYPE   Select chip TYPE\r\n"
 765:prom.c        **** "s       Autoscan for chip type (POTENTIALLY DANGEROUS)\r\n"
 766:prom.c        **** 			));
 767:prom.c        **** 			break;
 768:prom.c        **** 		}
 769:prom.c        **** 	}
 770:prom.c        **** #endif
 771:prom.c        **** }
 772:prom.c        **** 
 773:prom.c        **** 
 774:prom.c        **** // Send a string to the USB serial port.  The string must be in
 775:prom.c        **** // flash memory, using PSTR
 776:prom.c        **** //
 777:prom.c        **** void send_str(const char *s)
 778:prom.c        **** {
 1335               		.loc 1 778 0
 1336               		.cfi_startproc
 1337               	.LVL178:
 1338 0000 CF93      		push r28
 1339               	.LCFI42:
 1340               		.cfi_def_cfa_offset 3
 1341               		.cfi_offset 28, -2
 1342 0002 DF93      		push r29
 1343               	.LCFI43:
 1344               		.cfi_def_cfa_offset 4
 1345               		.cfi_offset 29, -3
 1346               	/* prologue: function */
 1347               	/* frame size = 0 */
 1348               	/* stack size = 2 */
 1349               	.L__stack_usage = 2
 1350 0004 FC01      		movw r30,r24
 1351               	.LVL179:
 1352               	.L86:
 1353               	.LBB92:
 779:prom.c        **** 	char c;
 780:prom.c        **** 	while (1) {
 781:prom.c        **** 		c = pgm_read_byte(s++);
 1354               		.loc 1 781 0
 1355               	/* #APP */
 1356               	 ;  781 "prom.c" 1
 1357 0006 8491      		lpm r24, Z
 1358               		
 1359               	 ;  0 "" 2
 1360               	.LVL180:
 1361               	/* #NOAPP */
 1362 0008 EF01      		movw r28,r30
 1363 000a 2196      		adiw r28,1
 1364               	.LVL181:
 1365               	.LBE92:
 782:prom.c        **** 		if (!c) break;
 1366               		.loc 1 782 0
 1367 000c 8823      		tst r24
 1368 000e 01F0      		breq .L84
 783:prom.c        **** 		usb_serial_putchar(c);
 1369               		.loc 1 783 0
 1370 0010 0E94 0000 		call usb_serial_putchar
 1371               	.LVL182:
 1372 0014 FE01      		movw r30,r28
 784:prom.c        **** 	}
 1373               		.loc 1 784 0
 1374 0016 00C0      		rjmp .L86
 1375               	.LVL183:
 1376               	.L84:
 1377               	/* epilogue start */
 785:prom.c        **** }
 1378               		.loc 1 785 0
 1379 0018 DF91      		pop r29
 1380 001a CF91      		pop r28
 1381               	.LVL184:
 1382 001c 0895      		ret
 1383               		.cfi_endproc
 1384               	.LFE31:
 1386               		.section	.text.startup.main,"ax",@progbits
 1387               	.global	main
 1389               	main:
 1390               	.LFB30:
 657:prom.c        **** 	// set for 16 MHz clock
 1391               		.loc 1 657 0
 1392               		.cfi_startproc
 1393 0000 CF93      		push r28
 1394               	.LCFI44:
 1395               		.cfi_def_cfa_offset 3
 1396               		.cfi_offset 28, -2
 1397 0002 DF93      		push r29
 1398               	.LCFI45:
 1399               		.cfi_def_cfa_offset 4
 1400               		.cfi_offset 29, -3
 1401 0004 CDB7      		in r28,__SP_L__
 1402 0006 DEB7      		in r29,__SP_H__
 1403               	.LCFI46:
 1404               		.cfi_def_cfa_register 28
 1405 0008 CB59      		subi r28,-101
 1406 000a D109      		sbc r29,__zero_reg__
 1407               	.LCFI47:
 1408               		.cfi_def_cfa_offset 159
 1409 000c 0FB6      		in __tmp_reg__,__SREG__
 1410 000e F894      		cli
 1411 0010 DEBF      		out __SP_H__,r29
 1412 0012 0FBE      		out __SREG__,__tmp_reg__
 1413 0014 CDBF      		out __SP_L__,r28
 1414               	/* prologue: function */
 1415               	/* frame size = 155 */
 1416               	/* stack size = 157 */
 1417               	.L__stack_usage = 157
 660:prom.c        **** 
 1418               		.loc 1 660 0
 1419 0016 80E8      		ldi r24,lo8(-128)
 1420 0018 8093 6100 		sts 97,r24
 1421 001c 1092 6100 		sts 97,__zero_reg__
 663:prom.c        **** 
 1422               		.loc 1 663 0
 1423 0020 1092 7C00 		sts 124,__zero_reg__
 669:prom.c        **** 	while (!usb_configured()) /* wait */ ;
 1424               		.loc 1 669 0
 1425 0024 0E94 0000 		call usb_init
 1426               	.LVL185:
 1427               	.L88:
 670:prom.c        **** 	_delay_ms(1000);
 1428               		.loc 1 670 0 discriminator 1
 1429 0028 0E94 0000 		call usb_configured
 1430               	.LVL186:
 1431 002c 8823      		tst r24
 1432 002e 01F0      		breq .L88
 1433               	.LVL187:
 1434               	.LBB143:
 1435               	.LBB144:
 187:/usr/lib/avr/include/util/delay.h **** 
 1436               		.loc 2 187 0
 1437 0030 2FEF      		ldi r18,lo8(3199999)
 1438 0032 33ED      		ldi r19,hi8(3199999)
 1439 0034 40E3      		ldi r20,hlo8(3199999)
 1440 0036 2150      	1:	subi r18,1
 1441 0038 3040      		sbci r19,0
 1442 003a 4040      		sbci r20,0
 1443 003c 01F4      		brne 1b
 1444 003e 00C0      		rjmp .
 1445 0040 0000      		nop
 1446               	.L89:
 1447               	.LBE144:
 1448               	.LBE143:
 675:prom.c        **** 		continue;
 1449               		.loc 1 675 0
 1450 0042 0E94 0000 		call usb_serial_get_control
 1451               	.LVL188:
 1452 0046 80FF      		sbrs r24,0
 1453 0048 00C0      		rjmp .L89
 682:prom.c        **** 
 1454               		.loc 1 682 0
 1455 004a 0E94 0000 		call usb_serial_flush_input
 1456               	.LVL189:
 1457 004e 8091 0000 		lds r24,proms_count
 1458 0052 9091 0000 		lds r25,proms_count+1
 1459 0056 C656      		subi r28,lo8(-154)
 1460 0058 DF4F      		sbci r29,hi8(-154)
 1461 005a 9983      		std Y+1,r25
 1462 005c 8883      		st Y,r24
 1463 005e CA59      		subi r28,lo8(154)
 1464 0060 D040      		sbci r29,hi8(154)
 1465 0062 DE01      		movw r26,r28
 1466 0064 5196      		adiw r26,17
 1467 0066 CF56      		subi r28,lo8(-145)
 1468 0068 DF4F      		sbci r29,hi8(-145)
 1469 006a B983      		std Y+1,r27
 1470 006c A883      		st Y,r26
 1471 006e C159      		subi r28,lo8(145)
 1472 0070 D040      		sbci r29,hi8(145)
 1473               	.LVL190:
 1474               	.L156:
 734:prom.c        **** 		send_str(PSTR("> "));
 1475               		.loc 1 734 0
 1476 0072 0E94 0000 		call prom_tristate
 1477               	.LVL191:
 735:prom.c        **** 
 1478               		.loc 1 735 0
 1479 0076 80E0      		ldi r24,lo8(__c.2338)
 1480 0078 90E0      		ldi r25,hi8(__c.2338)
 1481 007a 0E94 0000 		call send_str
 1482               	.LVL192:
 738:prom.c        **** 		while (1)
 1483               		.loc 1 738 0
 1484 007e 6296      		adiw r28,81-63
 1485 0080 1FAE      		std Y+63,__zero_reg__
 1486 0082 6297      		sbiw r28,81-63
 737:prom.c        **** 		buffer[buf_idx] = 0;
 1487               		.loc 1 737 0
 1488 0084 10E0      		ldi r17,0
 1489               	.LVL193:
 1490               	.L92:
 1491               	.LBB145:
 1492               	.LBB146:
 1493               	.LBB147:
 393:prom.c        **** 			continue;
 1494               		.loc 1 393 0
 1495 0086 0E94 0000 		call usb_serial_available
 1496               	.LVL194:
 1497 008a 8823      		tst r24
 1498 008c 01F0      		breq .L92
 396:prom.c        **** 		if (c == -1)
 1499               		.loc 1 396 0
 1500 008e 0E94 0000 		call usb_serial_getchar
 1501               	.LVL195:
 1502 0092 7C01      		movw r14,r24
 1503               	.LVL196:
 397:prom.c        **** 			continue;
 1504               		.loc 1 397 0
 1505 0094 8F3F      		cpi r24,-1
 1506 0096 BFEF      		ldi r27,-1
 1507 0098 9B07      		cpc r25,r27
 1508 009a 01F0      		breq .L92
 399:prom.c        **** 		return c;
 1509               		.loc 1 399 0
 1510 009c 082F      		mov r16,r24
 1511 009e 0E94 0000 		call usb_serial_putchar
 1512               	.LVL197:
 1513               	.LBE147:
 1514               	.LBE146:
 744:prom.c        **** 		  if (c == '\n') { send_str(PSTR("\r")); break; }
 1515               		.loc 1 744 0
 1516 00a2 0531      		cpi r16,lo8(21)
 1517 00a4 01F4      		brne .L94
 744:prom.c        **** 		  if (c == '\n') { send_str(PSTR("\r")); break; }
 1518               		.loc 1 744 0 is_stmt 0 discriminator 1
 1519 00a6 6296      		adiw r28,81-63
 1520 00a8 EFAE      		std Y+63,r14
 1521 00aa 6297      		sbiw r28,81-63
 1522               	.LVL198:
 1523 00ac 11E0      		ldi r17,lo8(1)
 1524 00ae 00C0      		rjmp .L95
 1525               	.LVL199:
 1526               	.L94:
 745:prom.c        **** 		  if (c == '\r') { send_str(PSTR("\n")); break; }
 1527               		.loc 1 745 0 is_stmt 1
 1528 00b0 0A30      		cpi r16,lo8(10)
 1529 00b2 01F4      		brne .L96
 745:prom.c        **** 		  if (c == '\r') { send_str(PSTR("\n")); break; }
 1530               		.loc 1 745 0 is_stmt 0 discriminator 1
 1531 00b4 80E0      		ldi r24,lo8(__c.2342)
 1532 00b6 90E0      		ldi r25,hi8(__c.2342)
 1533 00b8 00C0      		rjmp .L165
 1534               	.L96:
 746:prom.c        **** 		  if (buf_idx < (MAX_CMD-1)) buffer[buf_idx++] = c;
 1535               		.loc 1 746 0 is_stmt 1
 1536 00ba 0D30      		cpi r16,lo8(13)
 1537 00bc 01F4      		brne .L97
 746:prom.c        **** 		  if (buf_idx < (MAX_CMD-1)) buffer[buf_idx++] = c;
 1538               		.loc 1 746 0 is_stmt 0 discriminator 1
 1539 00be 80E0      		ldi r24,lo8(__c.2344)
 1540 00c0 90E0      		ldi r25,hi8(__c.2344)
 1541               	.L165:
 1542 00c2 0E94 0000 		call send_str
 1543               	.LVL200:
 1544 00c6 00C0      		rjmp .L95
 1545               	.L97:
 747:prom.c        **** 		}
 1546               		.loc 1 747 0 is_stmt 1
 1547 00c8 1F33      		cpi r17,lo8(63)
 1548 00ca 00F4      		brsh .L92
 1549               	.LVL201:
 747:prom.c        **** 		}
 1550               		.loc 1 747 0 is_stmt 0 discriminator 1
 1551 00cc E1E5      		ldi r30,lo8(81)
 1552 00ce F0E0      		ldi r31,0
 1553 00d0 EC0F      		add r30,r28
 1554 00d2 FD1F      		adc r31,r29
 1555 00d4 E10F      		add r30,r17
 1556 00d6 F11D      		adc r31,__zero_reg__
 1557 00d8 E082      		st Z,r14
 1558 00da 1F5F      		subi r17,lo8(-(1))
 1559               	.LVL202:
 1560 00dc 00C0      		rjmp .L92
 1561               	.LVL203:
 1562               	.L95:
 1563               	.LBE145:
 749:prom.c        **** 		// process command
 1564               		.loc 1 749 0 is_stmt 1
 1565 00de E1E5      		ldi r30,lo8(81)
 1566 00e0 F0E0      		ldi r31,0
 1567 00e2 EC0F      		add r30,r28
 1568 00e4 FD1F      		adc r31,r29
 1569 00e6 E10F      		add r30,r17
 1570 00e8 F11D      		adc r31,__zero_reg__
 1571 00ea 1082      		st Z,__zero_reg__
 751:prom.c        **** 		case XMODEM_NAK: prom_send(); break;
 1572               		.loc 1 751 0
 1573 00ec 6296      		adiw r28,81-63
 1574 00ee 8FAD      		ldd r24,Y+63
 1575 00f0 6297      		sbiw r28,81-63
 1576 00f2 8936      		cpi r24,lo8(105)
 1577 00f4 01F4      		brne .+2
 1578 00f6 00C0      		rjmp .L101
 1579 00f8 00F4      		brsh .L102
 1580 00fa 8D30      		cpi r24,lo8(13)
 1581 00fc 01F4      		brne .+2
 1582 00fe 00C0      		rjmp .L156
 1583 0100 8531      		cpi r24,lo8(21)
 1584 0102 01F0      		breq .L103
 1585 0104 8A30      		cpi r24,lo8(10)
 1586 0106 01F0      		breq .+2
 1587 0108 00C0      		rjmp .L100
 1588 010a 00C0      		rjmp .L156
 1589               	.L102:
 1590 010c 8D36      		cpi r24,lo8(109)
 1591 010e 01F4      		brne .+2
 1592 0110 00C0      		rjmp .L104
 1593 0112 00F4      		brsh .L105
 1594 0114 8C36      		cpi r24,lo8(108)
 1595 0116 01F0      		breq .+2
 1596 0118 00C0      		rjmp .L100
 1597 011a E0E0      		ldi r30,lo8(proms)
 1598 011c EE2E      		mov r14,r30
 1599 011e E0E0      		ldi r30,hi8(proms)
 1600 0120 FE2E      		mov r15,r30
 1601 0122 00E0      		ldi r16,0
 1602 0124 10E0      		ldi r17,0
 1603               	.LBB148:
 1604               	.LBB149:
 532:prom.c        **** 	{
 1605               		.loc 1 532 0
 1606 0126 C090 0000 		lds r12,proms_count
 1607 012a D090 0000 		lds r13,proms_count+1
 1608 012e 00C0      		rjmp .L110
 1609               	.L105:
 1610               	.LBE149:
 1611               	.LBE148:
 751:prom.c        **** 		case XMODEM_NAK: prom_send(); break;
 1612               		.loc 1 751 0
 1613 0130 8237      		cpi r24,lo8(114)
 1614 0132 01F0      		breq .L107
 1615 0134 8337      		cpi r24,lo8(115)
 1616 0136 01F0      		breq .+2
 1617 0138 00C0      		rjmp .L100
 1618               	.LBB152:
 1619               	.LBB153:
 611:prom.c        ****   for (int i = 0; i < proms_count; i++) {
 1620               		.loc 1 611 0
 1621 013a 0E94 0000 		call prom_tristate
 1622               	.LVL204:
 1623 013e 30E0      		ldi r19,lo8(proms)
 1624 0140 A32E      		mov r10,r19
 1625 0142 30E0      		ldi r19,hi8(proms)
 1626 0144 B32E      		mov r11,r19
 1627               	.LBB154:
 612:prom.c        ****     if (scan(proms+i)) {
 1628               		.loc 1 612 0
 1629 0146 212C      		mov r2,__zero_reg__
 1630 0148 312C      		mov r3,__zero_reg__
 1631 014a E091 0000 		lds r30,proms_count
 1632 014e F091 0000 		lds r31,proms_count+1
 1633 0152 C856      		subi r28,lo8(-152)
 1634 0154 DF4F      		sbci r29,hi8(-152)
 1635 0156 F983      		std Y+1,r31
 1636 0158 E883      		st Y,r30
 1637 015a C859      		subi r28,lo8(152)
 1638 015c D040      		sbci r29,hi8(152)
 1639 015e 00C0      		rjmp .L130
 1640               	.LVL205:
 1641               	.L107:
 1642               	.LBE154:
 1643               	.LBE153:
 1644               	.LBE152:
 751:prom.c        **** 		case XMODEM_NAK: prom_send(); break;
 1645               		.loc 1 751 0
 1646 0160 80E0      		ldi r24,0
 1647 0162 C12C      		mov r12,__zero_reg__
 1648 0164 D12C      		mov r13,__zero_reg__
 1649 0166 7601      		movw r14,r12
 1650 0168 00C0      		rjmp .L109
 1651               	.L103:
 1652               	.LBB173:
 1653               	.LBB174:
 626:prom.c        **** 		return;
 1654               		.loc 1 626 0
 1655 016a 80E0      		ldi r24,lo8(xmodem_block)
 1656 016c 90E0      		ldi r25,hi8(xmodem_block)
 1657 016e 0E94 0000 		call xmodem_init
 1658               	.LVL206:
 1659 0172 97FD      		sbrc r25,7
 1660 0174 00C0      		rjmp .L156
 630:prom.c        **** 
 1661               		.loc 1 630 0
 1662 0176 E091 0000 		lds r30,prom
 1663 017a F091 0000 		lds r31,prom+1
 1664 017e 81E0      		ldi r24,lo8(1)
 1665 0180 90E0      		ldi r25,0
 1666 0182 A0E0      		ldi r26,0
 1667 0184 B0E0      		ldi r27,0
 1668 0186 0288      		ldd r0,Z+18
 1669 0188 00C0      		rjmp 2f
 1670               		1:
 1671 018a 880F      		lsl r24
 1672 018c 991F      		rol r25
 1673 018e AA1F      		rol r26
 1674 0190 BB1F      		rol r27
 1675               		2:
 1676 0192 0A94      		dec r0
 1677 0194 02F4      		brpl 1b
 1678 0196 9C01      		movw r18,r24
 1679 0198 AD01      		movw r20,r26
 1680 019a 2150      		subi r18,1
 1681 019c 3109      		sbc r19,__zero_reg__
 1682 019e 4109      		sbc r20,__zero_reg__
 1683 01a0 5109      		sbc r21,__zero_reg__
 1684 01a2 CD56      		subi r28,lo8(-147)
 1685 01a4 DF4F      		sbci r29,hi8(-147)
 1686 01a6 2883      		st Y,r18
 1687 01a8 3983      		std Y+1,r19
 1688 01aa 4A83      		std Y+2,r20
 1689 01ac 5B83      		std Y+3,r21
 1690 01ae C359      		subi r28,lo8(147)
 1691 01b0 D040      		sbci r29,hi8(147)
 1692               	.LVL207:
 633:prom.c        **** 
 1693               		.loc 1 633 0
 1694 01b2 0E94 0000 		call prom_setup
 1695               	.LVL208:
 1696 01b6 812C      		mov r8,__zero_reg__
 1697 01b8 912C      		mov r9,__zero_reg__
 1698 01ba 5401      		movw r10,r8
 1699               	.LVL209:
 1700               	.L114:
 1701 01bc 00E0      		ldi r16,lo8(xmodem_block+3)
 1702 01be 10E0      		ldi r17,hi8(xmodem_block+3)
 1703 01c0 7501      		movw r14,r10
 1704 01c2 6401      		movw r12,r8
 1705               	.LVL210:
 1706               	.L112:
 1707               	.LBB175:
 639:prom.c        **** 			xmodem_block.data[off] = prom_read(addr++);
 1708               		.loc 1 639 0
 1709 01c4 B0E0      		ldi r27,hi8(xmodem_block+131)
 1710 01c6 0030      		cpi r16,lo8(xmodem_block+131)
 1711 01c8 1B07      		cpc r17,r27
 1712 01ca 01F0      		breq .L167
 640:prom.c        **** 
 1713               		.loc 1 640 0
 1714 01cc 2601      		movw r4,r12
 1715 01ce 3701      		movw r6,r14
 1716 01d0 3FEF      		ldi r19,-1
 1717 01d2 431A      		sub r4,r19
 1718 01d4 530A      		sbc r5,r19
 1719 01d6 630A      		sbc r6,r19
 1720 01d8 730A      		sbc r7,r19
 1721               	.LVL211:
 1722 01da C701      		movw r24,r14
 1723 01dc B601      		movw r22,r12
 1724 01de 0E94 0000 		call prom_read
 1725               	.LVL212:
 1726 01e2 D801      		movw r26,r16
 1727 01e4 8D93      		st X+,r24
 1728 01e6 8D01      		movw r16,r26
 1729               	.LVL213:
 1730 01e8 7301      		movw r14,r6
 1731 01ea 6201      		movw r12,r4
 1732 01ec 00C0      		rjmp .L112
 1733               	.LVL214:
 1734               	.L167:
 1735               	.LBE175:
 642:prom.c        **** 			return;
 1736               		.loc 1 642 0
 1737 01ee 80E0      		ldi r24,lo8(xmodem_block)
 1738 01f0 90E0      		ldi r25,hi8(xmodem_block)
 1739 01f2 0E94 0000 		call xmodem_send
 1740               	.LVL215:
 1741 01f6 97FD      		sbrc r25,7
 1742 01f8 00C0      		rjmp .L156
 1743 01fa E0E8      		ldi r30,-128
 1744 01fc 8E0E      		add r8,r30
 1745 01fe 911C      		adc r9,__zero_reg__
 1746 0200 A11C      		adc r10,__zero_reg__
 1747 0202 B11C      		adc r11,__zero_reg__
 1748               	.LVL216:
 646:prom.c        **** 			break;
 1749               		.loc 1 646 0
 1750 0204 CD56      		subi r28,lo8(-147)
 1751 0206 DF4F      		sbci r29,hi8(-147)
 1752 0208 2881      		ld r18,Y
 1753 020a 3981      		ldd r19,Y+1
 1754 020c 4A81      		ldd r20,Y+2
 1755 020e 5B81      		ldd r21,Y+3
 1756 0210 C359      		subi r28,lo8(147)
 1757 0212 D040      		sbci r29,hi8(147)
 1758 0214 C216      		cp r12,r18
 1759 0216 D306      		cpc r13,r19
 1760 0218 E406      		cpc r14,r20
 1761 021a F506      		cpc r15,r21
 1762 021c 00F0      		brlo .L114
 650:prom.c        **** }
 1763               		.loc 1 650 0
 1764 021e 80E0      		ldi r24,lo8(xmodem_block)
 1765 0220 90E0      		ldi r25,hi8(xmodem_block)
 1766 0222 0E94 0000 		call xmodem_fini
 1767               	.LVL217:
 1768 0226 00C0      		rjmp .L156
 1769               	.LVL218:
 1770               	.L169:
 1771               	.LBE174:
 1772               	.LBE173:
 1773               	.LBB176:
 1774               	.LBB177:
 1775               	.LBB178:
 1776               	.LBB179:
 1777               	.LBB180:
 409:prom.c        **** 		return c - '0';
 1778               		.loc 1 409 0
 1779 0228 90ED      		ldi r25,lo8(-48)
 1780 022a 980F      		add r25,r24
 1781 022c 9A30      		cpi r25,lo8(10)
 1782 022e 00F4      		brsh .L168
 1783               	.L117:
 1784               	.LVL219:
 1785               	.LBE180:
 1786               	.LBE179:
 478:prom.c        **** 	}
 1787               		.loc 1 478 0
 1788 0230 84E0      		ldi r24,4
 1789               		1:
 1790 0232 CC0C      		lsl r12
 1791 0234 DD1C      		rol r13
 1792 0236 EE1C      		rol r14
 1793 0238 FF1C      		rol r15
 1794 023a 8A95      		dec r24
 1795 023c 01F4      		brne 1b
 1796               	.LVL220:
 1797 023e C92A      		or r12,r25
 1798               	.LVL221:
 471:prom.c        **** 	  if (c == '\0')
 1799               		.loc 1 471 0
 1800 0240 822F      		mov r24,r18
 1801               	.LVL222:
 1802               	.L109:
 1803 0242 21E0      		ldi r18,lo8(1)
 1804 0244 280F      		add r18,r24
 1805               	.LVL223:
 1806 0246 E2E5      		ldi r30,lo8(82)
 1807 0248 F0E0      		ldi r31,0
 1808 024a EC0F      		add r30,r28
 1809 024c FD1F      		adc r31,r29
 1810 024e E80F      		add r30,r24
 1811 0250 F11D      		adc r31,__zero_reg__
 1812 0252 8081      		ld r24,Z
 1813               	.LVL224:
 472:prom.c        **** 	    break;
 1814               		.loc 1 472 0
 1815 0254 8111      		cpse r24,__zero_reg__
 1816 0256 00C0      		rjmp .L169
 1817 0258 00C0      		rjmp .L116
 1818               	.LVL225:
 1819               	.L168:
 1820               	.LBB182:
 1821               	.LBB181:
 411:prom.c        **** 		return c - 'A' + 0xA;
 1822               		.loc 1 411 0
 1823 025a 9FEB      		ldi r25,lo8(-65)
 1824 025c 980F      		add r25,r24
 1825 025e 9630      		cpi r25,lo8(6)
 1826 0260 00F4      		brsh .L118
 412:prom.c        **** 	if ('a' <= c && c <= 'f')
 1827               		.loc 1 412 0
 1828 0262 99EC      		ldi r25,lo8(-55)
 1829 0264 00C0      		rjmp .L166
 1830               	.L118:
 413:prom.c        **** 		return c - 'a' + 0xA;
 1831               		.loc 1 413 0
 1832 0266 9FE9      		ldi r25,lo8(-97)
 1833 0268 980F      		add r25,r24
 1834 026a 9630      		cpi r25,lo8(6)
 1835 026c 00F0      		brlo .+2
 1836 026e 00C0      		rjmp .L119
 414:prom.c        **** 	return 0xFF;
 1837               		.loc 1 414 0
 1838 0270 99EA      		ldi r25,lo8(-87)
 1839               	.L166:
 1840 0272 980F      		add r25,r24
 1841 0274 00C0      		rjmp .L117
 1842               	.LVL226:
 1843               	.L116:
 1844               	.LBE181:
 1845               	.LBE182:
 1846               	.LBE178:
 481:prom.c        **** 
 1847               		.loc 1 481 0
 1848 0276 80E0      		ldi r24,lo8(__c.2244)
 1849 0278 90E0      		ldi r25,hi8(__c.2244)
 1850               	.LVL227:
 1851 027a 0E94 0000 		call send_str
 1852               	.LVL228:
 483:prom.c        **** 
 1853               		.loc 1 483 0
 1854 027e 0E94 0000 		call prom_setup
 1855               	.LVL229:
 1856               	.LBB183:
 485:prom.c        **** 	{
 1857               		.loc 1 485 0
 1858 0282 412C      		mov r4,__zero_reg__
 1859 0284 1E01      		movw r2,r28
 1860 0286 31E3      		ldi r19,49
 1861 0288 230E      		add r2,r19
 1862 028a 311C      		adc r3,__zero_reg__
 1863               	.LVL230:
 1864               	.L122:
 1865               	.LBB184:
 1866               	.LBB185:
 1867               	.LBB186:
 1868               	.LBB187:
 424:prom.c        **** 	buf[6] = hexdigit(addr & 0xF); addr >>= 4;
 1869               		.loc 1 424 0
 1870 028c 8C2D      		mov r24,r12
 1871 028e 8F70      		andi r24,lo8(15)
 1872 0290 0E94 0000 		call hexdigit
 1873               	.LVL231:
 1874 0294 8887      		std Y+8,r24
 1875 0296 D701      		movw r26,r14
 1876 0298 C601      		movw r24,r12
 1877 029a 44E0      		ldi r20,4
 1878               		1:
 1879 029c B695      		lsr r27
 1880 029e A795      		ror r26
 1881 02a0 9795      		ror r25
 1882 02a2 8795      		ror r24
 1883 02a4 4A95      		dec r20
 1884 02a6 01F4      		brne 1b
 1885               	.LVL232:
 425:prom.c        **** 	buf[5] = hexdigit(addr & 0xF); addr >>= 4;
 1886               		.loc 1 425 0
 1887 02a8 8F70      		andi r24,lo8(15)
 1888 02aa 0E94 0000 		call hexdigit
 1889               	.LVL233:
 1890 02ae 8F83      		std Y+7,r24
 1891               	.LVL234:
 426:prom.c        **** 	buf[4] = hexdigit(addr & 0xF); addr >>= 4;
 1892               		.loc 1 426 0
 1893 02b0 8D2D      		mov r24,r13
 1894 02b2 8F70      		andi r24,lo8(15)
 1895 02b4 0E94 0000 		call hexdigit
 1896               	.LVL235:
 1897 02b8 8E83      		std Y+6,r24
 1898 02ba D701      		movw r26,r14
 1899 02bc C601      		movw r24,r12
 1900 02be 5CE0      		ldi r21,12
 1901               		1:
 1902 02c0 B695      		lsr r27
 1903 02c2 A795      		ror r26
 1904 02c4 9795      		ror r25
 1905 02c6 8795      		ror r24
 1906 02c8 5A95      		dec r21
 1907 02ca 01F4      		brne 1b
 1908               	.LVL236:
 427:prom.c        **** 	buf[3] = hexdigit(addr & 0xF); addr >>= 4;
 1909               		.loc 1 427 0
 1910 02cc 8F70      		andi r24,lo8(15)
 1911 02ce 0E94 0000 		call hexdigit
 1912               	.LVL237:
 1913 02d2 8D83      		std Y+5,r24
 1914               	.LVL238:
 428:prom.c        **** 	buf[2] = hexdigit(addr & 0xF); addr >>= 4;
 1915               		.loc 1 428 0
 1916 02d4 8E2D      		mov r24,r14
 1917 02d6 8F70      		andi r24,lo8(15)
 1918 02d8 0E94 0000 		call hexdigit
 1919               	.LVL239:
 1920 02dc 8C83      		std Y+4,r24
 1921 02de D701      		movw r26,r14
 1922 02e0 C601      		movw r24,r12
 1923 02e2 64E1      		ldi r22,20
 1924               		1:
 1925 02e4 B695      		lsr r27
 1926 02e6 A795      		ror r26
 1927 02e8 9795      		ror r25
 1928 02ea 8795      		ror r24
 1929 02ec 6A95      		dec r22
 1930 02ee 01F4      		brne 1b
 1931               	.LVL240:
 429:prom.c        **** 	buf[1] = hexdigit(addr & 0xF); addr >>= 4;
 1932               		.loc 1 429 0
 1933 02f0 8F70      		andi r24,lo8(15)
 1934 02f2 0E94 0000 		call hexdigit
 1935               	.LVL241:
 1936 02f6 8B83      		std Y+3,r24
 1937               	.LVL242:
 430:prom.c        **** 	buf[0] = hexdigit(addr & 0xF); addr >>= 4;
 1938               		.loc 1 430 0
 1939 02f8 8F2D      		mov r24,r15
 1940 02fa 8F70      		andi r24,lo8(15)
 1941 02fc 0E94 0000 		call hexdigit
 1942               	.LVL243:
 1943 0300 8A83      		std Y+2,r24
 1944               	.LVL244:
 431:prom.c        **** }
 1945               		.loc 1 431 0
 1946 0302 D701      		movw r26,r14
 1947 0304 C601      		movw r24,r12
 1948 0306 7CE1      		ldi r23,28
 1949               		1:
 1950 0308 B695      		lsr r27
 1951 030a A795      		ror r26
 1952 030c 9795      		ror r25
 1953 030e 8795      		ror r24
 1954 0310 7A95      		dec r23
 1955 0312 01F4      		brne 1b
 1956 0314 0E94 0000 		call hexdigit
 1957               	.LVL245:
 1958 0318 8983      		std Y+1,r24
 1959               	.LVL246:
 1960 031a 8E01      		movw r16,r28
 1961 031c 0F5F      		subi r16,-1
 1962 031e 1F4F      		sbci r17,-1
 1963 0320 3E01      		movw r6,r28
 1964 0322 4BE3      		ldi r20,59
 1965 0324 640E      		add r6,r20
 1966 0326 711C      		adc r7,__zero_reg__
 1967 0328 C701      		movw r24,r14
 1968 032a B601      		movw r22,r12
 1969 032c CD56      		subi r28,lo8(-147)
 1970 032e DF4F      		sbci r29,hi8(-147)
 1971 0330 0883      		st Y,r16
 1972 0332 C359      		subi r28,lo8(147)
 1973 0334 D040      		sbci r29,hi8(147)
 1974 0336 C956      		subi r28,lo8(-151)
 1975 0338 DF4F      		sbci r29,hi8(-151)
 1976 033a 1883      		st Y,r17
 1977 033c C759      		subi r28,lo8(151)
 1978 033e D040      		sbci r29,hi8(151)
 1979               	.LVL247:
 1980               	.L121:
 1981               	.LBE187:
 1982               	.LBE186:
 1983               	.LBB188:
 1984               	.LBB189:
 445:prom.c        **** 		uint8_t x = 8 + i * 3;
 1985               		.loc 1 445 0
 1986 0340 4B01      		movw r8,r22
 1987 0342 5C01      		movw r10,r24
 1988 0344 5FEF      		ldi r21,-1
 1989 0346 851A      		sub r8,r21
 1990 0348 950A      		sbc r9,r21
 1991 034a A50A      		sbc r10,r21
 1992 034c B50A      		sbc r11,r21
 1993               	.LVL248:
 1994 034e 0E94 0000 		call prom_read
 1995               	.LVL249:
 1996 0352 582E      		mov r5,r24
 1997               	.LVL250:
 447:prom.c        **** 		buf[x+1] = hexdigit(w >> 4);
 1998               		.loc 1 447 0
 1999 0354 E0E2      		ldi r30,lo8(32)
 2000 0356 D801      		movw r26,r16
 2001 0358 1896      		adiw r26,8
 2002 035a EC93      		st X,r30
 448:prom.c        **** 		buf[x+2] = hexdigit(w >> 0);
 2003               		.loc 1 448 0
 2004 035c 8295      		swap r24
 2005 035e 8F70      		andi r24,lo8(15)
 2006 0360 0E94 0000 		call hexdigit
 2007               	.LVL251:
 2008 0364 D801      		movw r26,r16
 2009 0366 1996      		adiw r26,9
 2010 0368 8C93      		st X,r24
 449:prom.c        **** 
 2011               		.loc 1 449 0
 2012 036a 852D      		mov r24,r5
 2013 036c 0E94 0000 		call hexdigit
 2014               	.LVL252:
 2015 0370 F801      		movw r30,r16
 2016 0372 8287      		std Z+10,r24
 2017               	.LVL253:
 2018               	.LBB190:
 2019               	.LBB191:
  41:prom.c        **** 		return 1;
 2020               		.loc 1 41 0
 2021 0374 852D      		mov r24,r5
 2022 0376 8F7D      		andi r24,lo8(-33)
 2023 0378 8154      		subi r24,lo8(-(-65))
 2024 037a 8A31      		cpi r24,lo8(26)
 2025 037c 00F0      		brlo .L140
  45:prom.c        **** 		return 1;
 2026               		.loc 1 45 0
 2027 037e 80ED      		ldi r24,lo8(-48)
 2028 0380 850D      		add r24,r5
 2029 0382 8A30      		cpi r24,lo8(10)
 2030 0384 00F0      		brlo .L140
  47:prom.c        **** 		return 1;
 2031               		.loc 1 47 0
 2032 0386 F0E2      		ldi r31,lo8(32)
 2033 0388 5F12      		cpse r5,r31
 2034 038a 00C0      		rjmp .L141
 2035               	.LBE191:
 2036               	.LBE190:
 445:prom.c        **** 		uint8_t x = 8 + i * 3;
 2037               		.loc 1 445 0
 2038 038c 80E2      		ldi r24,lo8(32)
 2039 038e 00C0      		rjmp .L120
 2040               	.L140:
 2041               	.LBB193:
 2042               	.LBB192:
  45:prom.c        **** 		return 1;
 2043               		.loc 1 45 0
 2044 0390 852D      		mov r24,r5
 2045 0392 00C0      		rjmp .L120
 2046               	.L141:
 2047               	.LBE192:
 2048               	.LBE193:
 451:prom.c        **** 	}
 2049               		.loc 1 451 0
 2050 0394 8EE2      		ldi r24,lo8(46)
 2051               	.L120:
 2052 0396 D301      		movw r26,r6
 2053 0398 8D93      		st X+,r24
 2054 039a 3D01      		movw r6,r26
 2055 039c 0D5F      		subi r16,-3
 2056 039e 1F4F      		sbci r17,-1
 445:prom.c        **** 		uint8_t x = 8 + i * 3;
 2057               		.loc 1 445 0
 2058 03a0 C501      		movw r24,r10
 2059 03a2 B401      		movw r22,r8
 2060               	.LBE189:
 443:prom.c        **** 	{
 2061               		.loc 1 443 0
 2062 03a4 2016      		cp r2,r16
 2063 03a6 3106      		cpc r3,r17
 2064 03a8 01F4      		brne .L121
 2065               	.LBE188:
 454:prom.c        **** 	buf[8 + 16 * 3 + 1] = ' ';
 2066               		.loc 1 454 0
 2067 03aa B0E2      		ldi r27,lo8(32)
 2068 03ac B9AF      		std Y+57,r27
 455:prom.c        **** 	buf[8 + 16 * 3 + 18] = '\r';
 2069               		.loc 1 455 0
 2070 03ae BAAF      		std Y+58,r27
 456:prom.c        **** 	buf[8 + 16 * 3 + 19] = '\n';
 2071               		.loc 1 456 0
 2072 03b0 EDE0      		ldi r30,lo8(13)
 2073 03b2 2C96      		adiw r28,75-63
 2074 03b4 EFAF      		std Y+63,r30
 2075 03b6 2C97      		sbiw r28,75-63
 457:prom.c        **** 
 2076               		.loc 1 457 0
 2077 03b8 FAE0      		ldi r31,lo8(10)
 2078 03ba 2D96      		adiw r28,76-63
 2079 03bc FFAF      		std Y+63,r31
 2080 03be 2D97      		sbiw r28,76-63
 459:prom.c        **** }
 2081               		.loc 1 459 0
 2082 03c0 6CE4      		ldi r22,lo8(76)
 2083 03c2 70E0      		ldi r23,0
 2084 03c4 CD56      		subi r28,lo8(-147)
 2085 03c6 DF4F      		sbci r29,hi8(-147)
 2086 03c8 8881      		ld r24,Y
 2087 03ca C359      		subi r28,lo8(147)
 2088 03cc D040      		sbci r29,hi8(147)
 2089 03ce C956      		subi r28,lo8(-151)
 2090 03d0 DF4F      		sbci r29,hi8(-151)
 2091 03d2 9881      		ld r25,Y
 2092 03d4 C759      		subi r28,lo8(151)
 2093 03d6 D040      		sbci r29,hi8(151)
 2094 03d8 0E94 0000 		call usb_serial_write
 2095               	.LVL254:
 2096               	.LBE185:
 2097               	.LBE184:
 488:prom.c        **** 	}
 2098               		.loc 1 488 0
 2099 03dc 20E1      		ldi r18,16
 2100 03de C20E      		add r12,r18
 2101 03e0 D11C      		adc r13,__zero_reg__
 2102 03e2 E11C      		adc r14,__zero_reg__
 2103 03e4 F11C      		adc r15,__zero_reg__
 2104               	.LVL255:
 485:prom.c        **** 	{
 2105               		.loc 1 485 0
 2106 03e6 4394      		inc r4
 2107               	.LVL256:
 2108 03e8 34E0      		ldi r19,lo8(4)
 2109 03ea 4312      		cpse r4,r19
 2110 03ec 00C0      		rjmp .L122
 2111 03ee 00C0      		rjmp .L156
 2112               	.LVL257:
 2113               	.L124:
 2114               	.LBE183:
 2115               	.LBE177:
 2116               	.LBE176:
 2117               	.LBB195:
 2118               	.LBB151:
 2119               	.LBB150:
 535:prom.c        **** 	}
 2120               		.loc 1 535 0
 2121 03f0 41E0      		ldi r20,lo8(1)
 2122 03f2 50E0      		ldi r21,0
 2123 03f4 8091 0000 		lds r24,prom
 2124 03f8 9091 0000 		lds r25,prom+1
 2125 03fc 8E15      		cp r24,r14
 2126 03fe 9F05      		cpc r25,r15
 2127 0400 01F0      		breq .L123
 2128 0402 40E0      		ldi r20,0
 2129 0404 50E0      		ldi r21,0
 2130               	.L123:
 2131 0406 B701      		movw r22,r14
 2132 0408 C801      		movw r24,r16
 2133 040a 0E94 0000 		call prom_list_send
 2134               	.LVL258:
 2135               	.LBE150:
 532:prom.c        **** 	{
 2136               		.loc 1 532 0
 2137 040e 0F5F      		subi r16,-1
 2138 0410 1F4F      		sbci r17,-1
 2139               	.LVL259:
 2140 0412 46E5      		ldi r20,86
 2141 0414 E40E      		add r14,r20
 2142 0416 F11C      		adc r15,__zero_reg__
 2143               	.LVL260:
 2144               	.L110:
 2145 0418 0C15      		cp r16,r12
 2146 041a 1D05      		cpc r17,r13
 2147 041c 00F0      		brlo .L124
 2148 041e 00C0      		rjmp .L156
 2149               	.LVL261:
 2150               	.L104:
 2151 0420 60E0      		ldi r22,lo8(proms)
 2152 0422 70E0      		ldi r23,hi8(proms)
 2153               	.LBE151:
 2154               	.LBE195:
 2155               	.LBB196:
 2156               	.LBB197:
 2157               	.LBB198:
 542:prom.c        ****     const char* a = proms[i].name;
 2158               		.loc 1 542 0
 2159 0424 80E0      		ldi r24,0
 2160 0426 90E0      		ldi r25,0
 2161               	.L138:
 2162               	.LVL262:
 2163 0428 C656      		subi r28,lo8(-154)
 2164 042a DF4F      		sbci r29,hi8(-154)
 2165 042c A881      		ld r26,Y
 2166 042e B981      		ldd r27,Y+1
 2167 0430 CA59      		subi r28,lo8(154)
 2168 0432 D040      		sbci r29,hi8(154)
 2169 0434 8A17      		cp r24,r26
 2170 0436 9B07      		cpc r25,r27
 2171 0438 01F0      		breq .L170
 2172               	.LVL263:
 2173 043a E1E5      		ldi r30,lo8(81)
 2174 043c F0E0      		ldi r31,0
 2175 043e EC0F      		add r30,r28
 2176 0440 FD1F      		adc r31,r29
 2177 0442 3196      		adiw r30,1
 2178               	.LBB199:
 543:prom.c        ****     const char* b = buffer;
 2179               		.loc 1 543 0
 2180 0444 DB01      		movw r26,r22
 2181               	.LVL264:
 2182               	.L125:
 546:prom.c        ****       if (*a != *b) { match = 0; break; }
 2183               		.loc 1 546 0
 2184 0446 3D91      		ld r19,X+
 2185               	.LVL265:
 2186 0448 3323      		tst r19
 2187 044a 01F4      		brne .+2
 2188 044c 00C0      		rjmp .L127
 2189 044e 2191      		ld r18,Z+
 2190 0450 2223      		tst r18
 2191 0452 01F4      		brne .+2
 2192 0454 00C0      		rjmp .L127
 547:prom.c        ****       a++; b++;
 2193               		.loc 1 547 0
 2194 0456 3217      		cp r19,r18
 2195 0458 01F0      		breq .L125
 2196               	.LVL266:
 2197               	.LBE199:
 542:prom.c        ****     const char* a = proms[i].name;
 2198               		.loc 1 542 0
 2199 045a 0196      		adiw r24,1
 2200               	.LVL267:
 2201 045c 6A5A      		subi r22,-86
 2202 045e 7F4F      		sbci r23,-1
 2203 0460 00C0      		rjmp .L138
 2204               	.LVL268:
 2205               	.L170:
 2206               	.LBE198:
 556:prom.c        **** }
 2207               		.loc 1 556 0
 2208 0462 80E0      		ldi r24,lo8(__c.2280)
 2209 0464 90E0      		ldi r25,hi8(__c.2280)
 2210               	.LVL269:
 2211 0466 00C0      		rjmp .L164
 2212               	.L101:
 2213               	.LVL270:
 2214               	.LBE197:
 2215               	.LBE196:
 2216               	.LBB205:
 2217               	.LBB206:
 233:prom.c        **** 	isp_write(a);
 2218               		.loc 1 233 0
 2219 0468 80E2      		ldi r24,lo8(32)
 2220 046a 0E94 0000 		call isp_write
 2221               	.LVL271:
 234:prom.c        **** 	isp_write(b);
 2222               		.loc 1 234 0
 2223 046e 80E0      		ldi r24,0
 2224 0470 0E94 0000 		call isp_write
 2225               	.LVL272:
 235:prom.c        **** 	return isp_write(0);
 2226               		.loc 1 235 0
 2227 0474 80E0      		ldi r24,0
 2228 0476 0E94 0000 		call isp_write
 2229               	.LVL273:
 236:prom.c        **** }
 2230               		.loc 1 236 0
 2231 047a 80E0      		ldi r24,0
 2232 047c 0E94 0000 		call isp_write
 2233               	.LVL274:
 2234 0480 00C0      		rjmp .L156
 2235               	.LVL275:
 2236               	.L171:
 2237 0482 BFEF      		ldi r27,-1
 2238 0484 4B1A      		sub r4,r27
 2239 0486 5B0A      		sbc r5,r27
 2240 0488 6B0A      		sbc r6,r27
 2241 048a 7B0A      		sbc r7,r27
 2242               	.LBE206:
 2243               	.LBE205:
 2244               	.LBB207:
 2245               	.LBB171:
 2246               	.LBB169:
 2247               	.LBB155:
 2248               	.LBB156:
 2249               	.LBB157:
 2250               	.LBB158:
 583:prom.c        ****       if (block[i] != prom_read(addr+i)) {
 2251               		.loc 1 583 0
 2252 048c CF56      		subi r28,lo8(-145)
 2253 048e DF4F      		sbci r29,hi8(-145)
 2254 0490 E881      		ld r30,Y
 2255 0492 F981      		ldd r31,Y+1
 2256 0494 C159      		subi r28,lo8(145)
 2257 0496 D040      		sbci r29,hi8(145)
 2258 0498 E017      		cp r30,r16
 2259 049a F107      		cpc r31,r17
 2260 049c 01F0      		breq .+2
 2261 049e 00C0      		rjmp .L134
 2262               	.LBE158:
 576:prom.c        ****     for (uint8_t i = 0; i < 16; i++) {
 2263               		.loc 1 576 0
 2264 04a0 F0E1      		ldi r31,16
 2265 04a2 CF0E      		add r12,r31
 2266 04a4 D11C      		adc r13,__zero_reg__
 2267 04a6 E11C      		adc r14,__zero_reg__
 2268 04a8 F11C      		adc r15,__zero_reg__
 2269               	.LVL276:
 2270 04aa C114      		cp r12,__zero_reg__
 2271 04ac 21E0      		ldi r18,1
 2272 04ae D206      		cpc r13,r18
 2273 04b0 E104      		cpc r14,__zero_reg__
 2274 04b2 F104      		cpc r15,__zero_reg__
 2275 04b4 01F4      		brne .+2
 2276 04b6 00C0      		rjmp .L135
 2277               	.LVL277:
 2278               	.L131:
 2279 04b8 8E01      		movw r16,r28
 2280 04ba 0F5F      		subi r16,-1
 2281 04bc 1F4F      		sbci r17,-1
 2282               	.LBE157:
 2283               	.LBE156:
 2284               	.LBE155:
 2285               	.LBE169:
 2286               	.LBE171:
 2287               	.LBE207:
 2288               	.LBB208:
 2289               	.LBB203:
 2290               	.LBB201:
 542:prom.c        ****     const char* a = proms[i].name;
 2291               		.loc 1 542 0
 2292 04be 4801      		movw r8,r16
 2293 04c0 2601      		movw r4,r12
 2294 04c2 3701      		movw r6,r14
 2295               	.LVL278:
 2296               	.L132:
 2297               	.LBE201:
 2298               	.LBE203:
 2299               	.LBE208:
 2300               	.LBB209:
 2301               	.LBB172:
 2302               	.LBB170:
 2303               	.LBB167:
 2304               	.LBB165:
 2305               	.LBB161:
 2306               	.LBB159:
 578:prom.c        ****       zeros |= ~block[i];
 2307               		.loc 1 578 0
 2308 04c4 C301      		movw r24,r6
 2309 04c6 B201      		movw r22,r4
 2310 04c8 0E94 0000 		call prom_read
 2311               	.LVL279:
 2312 04cc D401      		movw r26,r8
 2313 04ce 8D93      		st X+,r24
 2314 04d0 4D01      		movw r8,r26
 579:prom.c        ****       ones |= block[i];
 2315               		.loc 1 579 0
 2316 04d2 982F      		mov r25,r24
 2317 04d4 9095      		com r25
 2318 04d6 CD56      		subi r28,lo8(-147)
 2319 04d8 DF4F      		sbci r29,hi8(-147)
 2320 04da B881      		ld r27,Y
 2321 04dc C359      		subi r28,lo8(147)
 2322 04de D040      		sbci r29,hi8(147)
 2323 04e0 B92B      		or r27,r25
 2324 04e2 CD56      		subi r28,lo8(-147)
 2325 04e4 DF4F      		sbci r29,hi8(-147)
 2326 04e6 B883      		st Y,r27
 2327 04e8 C359      		subi r28,lo8(147)
 2328 04ea D040      		sbci r29,hi8(147)
 2329               	.LVL280:
 580:prom.c        ****     }
 2330               		.loc 1 580 0
 2331 04ec C956      		subi r28,lo8(-151)
 2332 04ee DF4F      		sbci r29,hi8(-151)
 2333 04f0 E881      		ld r30,Y
 2334 04f2 C759      		subi r28,lo8(151)
 2335 04f4 D040      		sbci r29,hi8(151)
 2336 04f6 E82B      		or r30,r24
 2337 04f8 C956      		subi r28,lo8(-151)
 2338 04fa DF4F      		sbci r29,hi8(-151)
 2339 04fc E883      		st Y,r30
 2340 04fe C759      		subi r28,lo8(151)
 2341 0500 D040      		sbci r29,hi8(151)
 2342               	.LVL281:
 2343 0502 FFEF      		ldi r31,-1
 2344 0504 4F1A      		sub r4,r31
 2345 0506 5F0A      		sbc r5,r31
 2346 0508 6F0A      		sbc r6,r31
 2347 050a 7F0A      		sbc r7,r31
 2348               	.LVL282:
 577:prom.c        ****       block[i] = prom_read(addr+i);
 2349               		.loc 1 577 0
 2350 050c CF56      		subi r28,lo8(-145)
 2351 050e DF4F      		sbci r29,hi8(-145)
 2352 0510 2881      		ld r18,Y
 2353 0512 3981      		ldd r19,Y+1
 2354 0514 C159      		subi r28,lo8(145)
 2355 0516 D040      		sbci r29,hi8(145)
 2356 0518 2815      		cp r18,r8
 2357 051a 3905      		cpc r19,r9
 2358 051c 01F4      		brne .L132
 2359 051e 2601      		movw r4,r12
 2360 0520 3701      		movw r6,r14
 2361               	.LVL283:
 2362               	.L134:
 2363               	.LBE159:
 2364               	.LBB160:
 584:prom.c        **** 	return 0;
 2365               		.loc 1 584 0
 2366 0522 D801      		movw r26,r16
 2367 0524 9D90      		ld r9,X+
 2368 0526 8D01      		movw r16,r26
 2369 0528 C301      		movw r24,r6
 2370 052a B201      		movw r22,r4
 2371 052c 0E94 0000 		call prom_read
 2372               	.LVL284:
 2373 0530 9816      		cp r9,r24
 2374 0532 01F4      		brne .+2
 2375 0534 00C0      		rjmp .L171
 2376               	.L133:
 2377               	.LVL285:
 2378               	.LBE160:
 2379               	.LBE161:
 2380               	.LBE165:
 2381               	.LBE167:
 616:prom.c        ****   }
 2382               		.loc 1 616 0
 2383 0536 0E94 0000 		call prom_tristate
 2384               	.LVL286:
 612:prom.c        ****     if (scan(proms+i)) {
 2385               		.loc 1 612 0
 2386 053a 5FEF      		ldi r21,-1
 2387 053c 251A      		sub r2,r21
 2388 053e 350A      		sbc r3,r21
 2389               	.LVL287:
 2390 0540 86E5      		ldi r24,86
 2391 0542 A80E      		add r10,r24
 2392 0544 B11C      		adc r11,__zero_reg__
 2393               	.LVL288:
 2394               	.L130:
 2395 0546 C856      		subi r28,lo8(-152)
 2396 0548 DF4F      		sbci r29,hi8(-152)
 2397 054a A881      		ld r26,Y
 2398 054c B981      		ldd r27,Y+1
 2399 054e C859      		subi r28,lo8(152)
 2400 0550 D040      		sbci r29,hi8(152)
 2401 0552 2A16      		cp r2,r26
 2402 0554 3B06      		cpc r3,r27
 2403 0556 00F0      		brlo .+2
 2404 0558 00C0      		rjmp .L156
 2405               	.LVL289:
 2406               	.LBB168:
 2407               	.LBB166:
 570:prom.c        ****   prom_setup();
 2408               		.loc 1 570 0
 2409 055a B092 0000 		sts prom+1,r11
 2410 055e A092 0000 		sts prom,r10
 571:prom.c        ****   // scan first 256 bytes for varying data
 2411               		.loc 1 571 0
 2412 0562 0E94 0000 		call prom_setup
 2413               	.LVL290:
 573:prom.c        ****   uint8_t ones = 0;
 2414               		.loc 1 573 0
 2415 0566 CD56      		subi r28,lo8(-147)
 2416 0568 DF4F      		sbci r29,hi8(-147)
 2417 056a 1882      		st Y,__zero_reg__
 2418 056c C359      		subi r28,lo8(147)
 2419 056e D040      		sbci r29,hi8(147)
 574:prom.c        ****   uint8_t block[16];
 2420               		.loc 1 574 0
 2421 0570 C956      		subi r28,lo8(-151)
 2422 0572 DF4F      		sbci r29,hi8(-151)
 2423 0574 1882      		st Y,__zero_reg__
 2424 0576 C759      		subi r28,lo8(151)
 2425 0578 D040      		sbci r29,hi8(151)
 2426               	.LBB162:
 576:prom.c        ****     for (uint8_t i = 0; i < 16; i++) {
 2427               		.loc 1 576 0
 2428 057a C12C      		mov r12,__zero_reg__
 2429 057c D12C      		mov r13,__zero_reg__
 2430 057e 7601      		movw r14,r12
 2431 0580 00C0      		rjmp .L131
 2432               	.LVL291:
 2433               	.L135:
 2434               	.LBE162:
 590:prom.c        ****   // check top half of memory. If first 256 bytes mirrors low memory
 2435               		.loc 1 590 0
 2436 0582 C956      		subi r28,lo8(-151)
 2437 0584 DF4F      		sbci r29,hi8(-151)
 2438 0586 3881      		ld r19,Y
 2439 0588 C759      		subi r28,lo8(151)
 2440 058a D040      		sbci r29,hi8(151)
 2441 058c 3F3F      		cpi r19,lo8(-1)
 2442 058e 01F4      		brne .L133
 2443 0590 CD56      		subi r28,lo8(-147)
 2444 0592 DF4F      		sbci r29,hi8(-147)
 2445 0594 4881      		ld r20,Y
 2446 0596 C359      		subi r28,lo8(147)
 2447 0598 D040      		sbci r29,hi8(147)
 2448 059a 4F3F      		cpi r20,lo8(-1)
 2449 059c 01F4      		brne .L133
 593:prom.c        ****   uint8_t single_byte = prom_read(top_half_addr);
 2450               		.loc 1 593 0
 2451 059e E091 0000 		lds r30,prom
 2452 05a2 F091 0000 		lds r31,prom+1
 2453 05a6 C12C      		mov r12,__zero_reg__
 2454 05a8 D12C      		mov r13,__zero_reg__
 2455 05aa 7601      		movw r14,r12
 2456 05ac C394      		inc r12
 2457               	.LVL292:
 2458 05ae 0288      		ldd r0,Z+18
 2459 05b0 00C0      		rjmp 2f
 2460               		1:
 2461 05b2 CC0C      		lsl r12
 2462 05b4 DD1C      		rol r13
 2463 05b6 EE1C      		rol r14
 2464 05b8 FF1C      		rol r15
 2465               		2:
 2466 05ba 0A94      		dec r0
 2467 05bc 02F4      		brpl 1b
 2468 05be F694      		lsr r15
 2469 05c0 E794      		ror r14
 2470 05c2 D794      		ror r13
 2471 05c4 C794      		ror r12
 2472               	.LVL293:
 594:prom.c        ****   uint8_t same_byte_check = 1;
 2473               		.loc 1 594 0
 2474 05c6 C701      		movw r24,r14
 2475 05c8 B601      		movw r22,r12
 2476 05ca 0E94 0000 		call prom_read
 2477               	.LVL294:
 2478               	.LBB163:
 597:prom.c        ****     uint8_t low = prom_read(i);
 2479               		.loc 1 597 0
 2480 05ce 10E0      		ldi r17,0
 2481               	.LVL295:
 2482               	.L136:
 2483               	.LBB164:
 598:prom.c        ****     uint8_t high = prom_read(top_half_addr+i);
 2484               		.loc 1 598 0
 2485 05d0 812E      		mov r8,r17
 2486 05d2 912C      		mov r9,__zero_reg__
 2487 05d4 A12C      		mov r10,__zero_reg__
 2488 05d6 B12C      		mov r11,__zero_reg__
 2489 05d8 C501      		movw r24,r10
 2490 05da B401      		movw r22,r8
 2491 05dc 0E94 0000 		call prom_read
 2492               	.LVL296:
 599:prom.c        ****     if (high != single_byte) { same_byte_check = 0; }
 2493               		.loc 1 599 0
 2494 05e0 C701      		movw r24,r14
 2495 05e2 B601      		movw r22,r12
 2496 05e4 680D      		add r22,r8
 2497 05e6 791D      		adc r23,r9
 2498 05e8 8A1D      		adc r24,r10
 2499 05ea 9B1D      		adc r25,r11
 2500 05ec 0E94 0000 		call prom_read
 2501               	.LVL297:
 2502               	.LBE164:
 597:prom.c        ****     uint8_t low = prom_read(i);
 2503               		.loc 1 597 0
 2504 05f0 1F5F      		subi r17,lo8(-(1))
 2505               	.LVL298:
 2506 05f2 00C0      		rjmp .L136
 2507               	.LVL299:
 2508               	.L100:
 2509               	.LBE163:
 2510               	.LBE166:
 2511               	.LBE168:
 2512               	.LBE170:
 2513               	.LBE172:
 2514               	.LBE209:
 761:prom.c        **** "r000000 Read a hex word from address\r\n"
 2515               		.loc 1 761 0
 2516 05f4 80E0      		ldi r24,lo8(__c.2357)
 2517 05f6 90E0      		ldi r25,hi8(__c.2357)
 2518 05f8 00C0      		rjmp .L164
 2519               	.LVL300:
 2520               	.L119:
 2521               	.LDL1:
 2522               	.LBB210:
 2523               	.LBB194:
 493:prom.c        **** }
 2524               		.loc 1 493 0
 2525 05fa 80E0      		ldi r24,lo8(__c.2250)
 2526 05fc 90E0      		ldi r25,hi8(__c.2250)
 2527               	.LVL301:
 2528               	.L164:
 2529 05fe 0E94 0000 		call send_str
 2530               	.LVL302:
 2531 0602 00C0      		rjmp .L156
 2532               	.LVL303:
 2533               	.L127:
 2534               	.LBE194:
 2535               	.LBE210:
 2536               	.LBB211:
 2537               	.LBB204:
 2538               	.LBB202:
 2539               	.LBB200:
 551:prom.c        **** 	prom_list_send(i, prom, 1);
 2540               		.loc 1 551 0
 2541 0604 7093 0000 		sts prom+1,r23
 2542 0608 6093 0000 		sts prom,r22
 552:prom.c        **** 	return;
 2543               		.loc 1 552 0
 2544 060c 41E0      		ldi r20,lo8(1)
 2545 060e 50E0      		ldi r21,0
 2546 0610 0E94 0000 		call prom_list_send
 2547               	.LVL304:
 2548 0614 00C0      		rjmp .L156
 2549               	.LBE200:
 2550               	.LBE202:
 2551               	.LBE204:
 2552               	.LBE211:
 2553               		.cfi_endproc
 2554               	.LFE30:
 2556               		.section	.text.send_mem_str,"ax",@progbits
 2557               	.global	send_mem_str
 2559               	send_mem_str:
 2560               	.LFB32:
 786:prom.c        **** 
 787:prom.c        **** void send_mem_str(const char *s)
 788:prom.c        **** {
 2561               		.loc 1 788 0
 2562               		.cfi_startproc
 2563               	.LVL305:
 2564 0000 CF93      		push r28
 2565               	.LCFI48:
 2566               		.cfi_def_cfa_offset 3
 2567               		.cfi_offset 28, -2
 2568 0002 DF93      		push r29
 2569               	.LCFI49:
 2570               		.cfi_def_cfa_offset 4
 2571               		.cfi_offset 29, -3
 2572               	/* prologue: function */
 2573               	/* frame size = 0 */
 2574               	/* stack size = 2 */
 2575               	.L__stack_usage = 2
 2576 0004 EC01      		movw r28,r24
 2577               	.LVL306:
 2578               	.L174:
 2579               	.LBB212:
 789:prom.c        **** 	while (1) {
 790:prom.c        **** 	  char c = *(s++);
 2580               		.loc 1 790 0
 2581 0006 8991      		ld r24,Y+
 2582               	.LVL307:
 791:prom.c        **** 	  if (!c) break;
 2583               		.loc 1 791 0
 2584 0008 8823      		tst r24
 2585 000a 01F0      		breq .L172
 792:prom.c        **** 	  usb_serial_putchar(c);
 2586               		.loc 1 792 0
 2587 000c 0E94 0000 		call usb_serial_putchar
 2588               	.LVL308:
 2589               	.LBE212:
 793:prom.c        **** 	}
 2590               		.loc 1 793 0
 2591 0010 00C0      		rjmp .L174
 2592               	.LVL309:
 2593               	.L172:
 2594               	/* epilogue start */
 794:prom.c        **** }
 2595               		.loc 1 794 0
 2596 0012 DF91      		pop r29
 2597 0014 CF91      		pop r28
 2598               	.LVL310:
 2599 0016 0895      		ret
 2600               		.cfi_endproc
 2601               	.LFE32:
 2603               		.section	.progmem.data,"a",@progbits
 2606               	__c.2280:
 2607 0000 2D20 4E6F 		.string	"- No such chip\r\n"
 2607      2073 7563 
 2607      6820 6368 
 2607      6970 0D0A 
 2607      00
 2610               	__c.2250:
 2611 0011 3F0D 0A00 		.string	"?\r\n"
 2614               	__c.2244:
 2615 0015 0D0A 00   		.string	"\r\n"
 2618               	__c.2357:
 2619 0018 7230 3030 		.string	"r000000 Read a hex word from address\r\nl       List chip modes\r\nmTYPE   Select chip TY
 2619      3030 3020 
 2619      5265 6164 
 2619      2061 2068 
 2619      6578 2077 
 2622               	__c.2344:
 2623 00aa 0A00      		.string	"\n"
 2626               	__c.2342:
 2627 00ac 0D00      		.string	"\r"
 2630               	__c.2338:
 2631 00ae 3E20 00   		.string	"> "
 2632               		.local	xmodem_block
 2633               		.comm	xmodem_block,132,1
 2634               		.data
 2637               	prom:
 2638 0000 0000      		.word	proms
 2639               		.section	.rodata
 2642               	ports:
 2643 0000 00        		.zero	1
 2644 0001 B6        		.byte	-74
 2645 0002 B5        		.byte	-75
 2646 0003 B4        		.byte	-76
 2647 0004 B3        		.byte	-77
 2648 0005 B2        		.byte	-78
 2649 0006 B1        		.byte	-79
 2650 0007 B0        		.byte	-80
 2651 0008 E7        		.byte	-25
 2652 0009 E6        		.byte	-26
 2653 000a A2        		.byte	-94
 2654 000b A1        		.byte	-95
 2655 000c F0        		.byte	-16
 2656 000d F1        		.byte	-15
 2657 000e F2        		.byte	-14
 2658 000f F3        		.byte	-13
 2659 0010 F4        		.byte	-12
 2660 0011 F5        		.byte	-11
 2661 0012 F6        		.byte	-10
 2662 0013 F7        		.byte	-9
 2663 0014 A3        		.byte	-93
 2664 0015 A7        		.byte	-89
 2665 0016 C7        		.byte	-57
 2666 0017 C6        		.byte	-58
 2667 0018 C5        		.byte	-59
 2668 0019 C4        		.byte	-60
 2669 001a C3        		.byte	-61
 2670 001b C2        		.byte	-62
 2671 001c C1        		.byte	-63
 2672 001d C0        		.byte	-64
 2673 001e E1        		.byte	-31
 2674 001f E0        		.byte	-32
 2675 0020 D7        		.byte	-41
 2676 0021 D6        		.byte	-42
 2677 0022 D5        		.byte	-43
 2678 0023 D4        		.byte	-44
 2679 0024 D3        		.byte	-45
 2680 0025 D2        		.byte	-46
 2681 0026 D1        		.byte	-47
 2682 0027 D0        		.byte	-48
 2683 0028 B7        		.byte	-73
 2684               		.text
 2685               	.Letext0:
 2686               		.file 3 "/usr/lib/avr/include/stdint.h"
 2687               		.file 4 "xmodem.h"
 2688               		.file 5 "chips.h"
 2689               		.file 6 "bits.h"
 2690               		.file 7 "usb_serial.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 prom.c
     /tmp/ccS0XVxC.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccS0XVxC.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccS0XVxC.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccS0XVxC.s:5      *ABS*:000000000000003b __RAMPZ__
     /tmp/ccS0XVxC.s:6      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccS0XVxC.s:7      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccS0XVxC.s:13     .text.hexdigit:0000000000000000 hexdigit
     /tmp/ccS0XVxC.s:45     .text.prom_pin:0000000000000000 prom_pin
     /tmp/ccS0XVxC.s:2637   .data:0000000000000000 prom
     /tmp/ccS0XVxC.s:2642   .rodata:0000000000000000 ports
     /tmp/ccS0XVxC.s:83     .text.prom_tristate:0000000000000000 prom_tristate
     /tmp/ccS0XVxC.s:139    .text.isp_clock:0000000000000000 isp_clock
     /tmp/ccS0XVxC.s:229    .text.isp_write:0000000000000000 isp_write
     /tmp/ccS0XVxC.s:365    .text.prom_setup:0000000000000000 prom_setup
     /tmp/ccS0XVxC.s:794    .text._prom_read:0000000000000000 _prom_read
     /tmp/ccS0XVxC.s:865    .text.prom_list_send:0000000000000000 prom_list_send
     /tmp/ccS0XVxC.s:1077   .text.prom_read:0000000000000000 prom_read
     /tmp/ccS0XVxC.s:1333   .text.send_str:0000000000000000 send_str
     /tmp/ccS0XVxC.s:1389   .text.startup.main:0000000000000000 main
     /tmp/ccS0XVxC.s:2630   .progmem.data:00000000000000ae __c.2338
     /tmp/ccS0XVxC.s:2626   .progmem.data:00000000000000ac __c.2342
     /tmp/ccS0XVxC.s:2622   .progmem.data:00000000000000aa __c.2344
                             .bss:0000000000000000 xmodem_block
     /tmp/ccS0XVxC.s:2614   .progmem.data:0000000000000015 __c.2244
     /tmp/ccS0XVxC.s:2606   .progmem.data:0000000000000000 __c.2280
     /tmp/ccS0XVxC.s:2618   .progmem.data:0000000000000018 __c.2357
     /tmp/ccS0XVxC.s:2610   .progmem.data:0000000000000011 __c.2250
     /tmp/ccS0XVxC.s:2559   .text.send_mem_str:0000000000000000 send_mem_str

UNDEFINED SYMBOLS
ddr
out
in
usb_serial_write
__divmodhi4
usb_serial_putchar
usb_init
usb_configured
usb_serial_get_control
usb_serial_flush_input
proms_count
usb_serial_available
usb_serial_getchar
proms
xmodem_init
xmodem_send
xmodem_fini
__do_copy_data
__do_clear_bss
